// 'use strict';

// // // Повідомлення, надіслані клієнтом, називаються запитами, а повідомлення, надіслані сервером як відповідь, називаються відповідями.
// // //     HTTP — це клієнт - серверний протокол: запити надсилаються однією сутністю, агентом користувача(або проксі - сервером від його імені).У більшості випадків агентом користувача є веб - браузер, але це може бути що завгодно, наприклад, робот, який сканує Інтернет, щоб заповнити та підтримувати індекс пошукової системи.
// // // Кожен окремий запит надсилається на сервер, який обробляє його та надає відповідь, яка називається відповіддю.Між клієнтом і сервером є численні об’єкти, які разом називаються проксі - серверами, які виконують різні операції та діють, наприклад, як шлюзи або кеші.
// // // Client: the user-agent
// // // Агент користувача - це будь-який інструмент, який діє від імені користувача. Цю роль в основному виконує веб-браузер, але її також можуть виконувати програми, які використовуються інженерами та веб-розробниками для налагодження своїх програм.

// // // Браузер завжди ініціює запит.Це ніколи не сервер

// // // Щоб відобразити веб-сторінку, браузер надсилає оригінальний запит для отримання HTML-документа, який представляє сторінку. Потім він аналізує цей файл, роблячи додаткові запити, що відповідають сценаріям виконання, інформації про макет (CSS) для відображення та підресурсів, що містяться на сторінці (зазвичай зображення та відео). Потім веб-браузер поєднує ці ресурси, щоб представити повний документ, веб-сторінку. Сценарії, які виконує браузер, можуть отримати більше ресурсів на наступних етапах, і браузер відповідно оновлює веб-сторінку.

// // //     Веб - сторінка — це гіпертекстовий документ.Це означає, що деякі частини відображуваного вмісту є посиланнями, які можна активувати(зазвичай клацанням миші) для отримання нової веб - сторінки, дозволяючи користувачеві керувати своїм агентом користувача та переходити в Інтернеті.Браузер перетворює ці вказівки в HTTP - запити, а потім інтерпретує відповіді HTTP, щоб надати користувачеві чітку відповідь.
// // // Веб-сервер Web server
// // // На протилежній стороні каналу зв'язку знаходиться сервер, який обслуговує документ за запитом клієнта. Сервер віртуально виглядає лише як одна машина; але насправді це може бути сукупність серверів, які розподіляють навантаження (балансування навантаження), або інше програмне забезпечення (таке як кеш-пам’ять, сервер бази даних або сервери електронної комерції), яке повністю або частково генерує документ на вимогу.
// // // Проксі
// // // Між веб-браузером і сервером багато комп’ютерів і машин передають HTTP-повідомлення. Завдяки багаторівневій структурі веб-стеку більшість із них працюють на транспортному, мережевому або фізичному рівнях, стаючи прозорими на рівні HTTP та потенційно маючи значний вплив на продуктивність. Ті, що працюють на прикладних рівнях, зазвичай називаються проксі . Вони можуть бути прозорими, пересилаючи отримані запити, не змінюючи їх жодним чином, або непрозорими, у цьому випадку вони певним чином змінять запит перед тим, як передати його на сервер. Проксі можуть виконувати численні функції:

// // // кешування (кеш може бути публічним або приватним, як кеш браузера)
// // // фільтрація (наприклад, антивірусне сканування або батьківський контроль)
// // // балансування навантаження (щоб дозволити кільком серверам обслуговувати різні запити)
// // // аутентифікація (для контролю доступу до різних ресурсів)
// // // журналювання (що дозволяє зберігати історичну інформацію)

// // //                                                                     HTTP
// // // HyperText Transfer Protocol (протокол передачі гіпертексту) — поширений протокол для передачі вебресурсів різних типів: html, css, javascript, зображень, аудіо та відео тощо.
// // HTTP ґрунтується на структурі клієнт-сервер і моделі запит-відповідь.

// // Як це працює?
// // 1) Клієнтський застосунок ініціює з'єднання, формує запит і відправляє його на сервер.
// // 2) сервер обробляє цей запит, формує відповідь і передає її назад клієнтові.
// // 3) Зв'язок між ними здійснюється за допомогою низки перемежованих HTTP-запитів і HTTP-відповідей.

// //     Запит відбувається в кілька етапів:
// // 1) DNS-запит — пошук найближчого DNS-сервера, щоб перетворити адресу (наприклад google.com) в її числове вираження, IP-адресу (74.125.87.99).
// // 2) З'єднання — встановлення з'єднання з сервером за отриманою IP-адресою.
// // 3) Передача даних — пересилання пакетів з клієнта на сервер.
// // 4) Очікування відповіді — очікування, доки пакети даних дійдуть до сервера, він їх обробить, і відповідь повернеться назад до клієнта.
// // 5) Отримання даних — пакети надійшли, можна отримувати з них дані.

// // //                                                                     Протокол HTTPS
// // HyperText Transfer Protocol Secure — це налаштування над протоколом HTTP, у якому всі повідомлення між клієнтом і сервером шифруються з метою підвищення безпеки.

// // HTTPS протокол забезпечує захист від атак, що базуються на “прослуховуванні” з'єднання. Дані передаються з використанням криптографічних протоколів SSL або TLS.

// // Під час обміну через звичайне HTTP - з'єднання всі дані передаються у вигляді тексту і можуть бути прочитані всіма, хто отримав доступ до з'єднання між клієнтом і сервером.

// // Протокол HTTPS гарантує, що інформація про клієнта, наприклад номери кредитних карток, зашифрована і не може бути перехоплена в розшифрованому вигляді.Відвідувачі можуть переконатися, що сайт безпечний, подивившись на іконку зліва від адресного рядка, захищені з'єднання позначаються іконкою замка.

// // //                                                                        HTTP-запити
//  API (application programming interface, интерфейс программирования приложения) - набір чітко визначених правил зв'язку між різними програмними компонентами. Інтерфейс описує, що можна попросити програму зробити і що буде в результаті.

// REST (representational state transfer) — стиль бекенд-архітектури. Він ґрунтується на наборі принципів, які описують, яким чином визначаються й адресуються мережеві ресурси.

// REST API — бекенд побудований за принципом REST. Слугує прошарком між вебзастосунком і базою даних. Має стандартний інтерфейс для звернення до ресурсів. Працює як вебсайт, ми посилаємо HTTP-запит із клієнта на сервер, а у відповідь, замість HTML-сторінки, отримуємо дані в JSON-форматі.

// Існують тисячі бекендів, і кожен з них унікальний.З іншого боку, REST API побудовані за стандартною архітектурою.Отже, можна зрозуміти принцип їх роботи, після чого все, що потрібно зробити — це ознайомитися з документацією того бекенду, який необхідно

//                                                            Шлях до ресурсу

// Запити на бекенд повинні містити шлях до ресурсу, над яким виконується операція. Доступні шляхи (ендпоінти, ресурси) описуються в документації бекенду.

//     Endpoints(Ендпоінти) в контексті вебсервісів та API —  конкретні URL - адреси, через які можна отримати доступ до певних функцій або ресурсів сервера.Tочка входу для взаємодії між клієнтом і сервером, дозволяючи отримувати, надсилати, оновлювати чи видаляти дані.
//                                                                JSONPlaceholder API
// це публічний REST API для швидкого прототипування, який надає кілька різних колекцій уявних даних.
// https://jsonplaceholder.typicode.com/users
// Цей шлях складається з таких частин:
// https://jsonplaceholder.typicode.com — це базовий URL, точка входу в API.
// /users — ресурс, до якого звертаємося.

// //                                                                Fetch API
// Fetch API —  інтерфейс, який вбудований у браузер і доступний через об'єкт window. Він надає набір властивостей і методів, які дозволяють відправляти, отримувати та обробляти ресурси із сервера.

// Метод fetch() - сучасний інтерфейс для формування запитів до сервера і побудований на промісах. Метод fetch ПОВЕРТАЭ ПРОМІС, тому до результату його виклику додаємо ланцюжок методів then() і catch() для обробки відповіді.

//     fetch(url, options)
// url — шлях до даних на бекенді, які необхідно отримати, створити або змінити. Обов'язковий аргумент.
// options — об'єкт налаштувань запиту: метод, заголовки, тіло тощо. Необов'язковий аргумент.

// ЕХ робимо запит до вебсервісу, щоб отримати колекцію користувачів (ресурс /users).
// fetch('https://jsonplaceholder.typicode.com/users')
//   .then(response => {
//     // Response handling
//   })
//   .then(data => {
//     // Data handling
//   })
//   .catch(error => {
//     // Error handling
//   });
// //                                                                 Вкладка Network
// В інструментах розробника на вкладці Network(Мережа) відображаються всі HTTP - запити, що виконуються на сторінці.
// Як це зробити?
// Вибери фільтр асинхронні HTTP/HTTPS-запити, зроблені за допомогою Fetch API або XMLHttpRequest, XHR або Fetch/XHR — так залишаться тільки асинхронні HTTP/HTTPS-запити, зроблені за допомогою Fetch API або XMLHttpRequest.
// Після запуску скрипта з викликом методу fetch, через деякий час запит відобразиться у списку.
// Вибери цей запит, щоб подивитися всю інформацію по ньому на підвкладках
//     - Headers(Заголовки),
//     -Preview(Попередній перегляд)
//     - Response(Відповідь).
//                                                                           Коди відповідей

// На запит клієнта сервер відправляє відповідь, яка містить код стану, щоб інформувати клієнта про результат операції.

// Код відповіді можна подивитися на вкладці Network у полі Status Code.
// Коди діляться на групи (з якої цифри починається код помилки):
// 1XX — мають інформаційне призначення.
// 2XX — коди успішного проведення операції.
// 3XX — описують усе, що пов'язано з перенаправленням (redirect).
// 4XX — вказують на помилки з боку клієнта.
// 5XX — вказують на помилки з боку сервера.

// Достатньо знатинайпоширеніші коди з кожної групи. Решту  можна подивитися в довіднику HTTP-кодів (https://httpstatuses.com/).
// 200 (OK) — стандартна відповідь для успішних HTTP-запитів.
// 201 (Created) — стандартна відповідь для HTTP-запиту, який привів до успішного створення ресурсу.
// 400 (Bad Request) — запит не може бути оброблений через неправильний синтаксис запиту або іншу помилку клієнта.
// 401 (Unauthorized) — для доступу до ресурсу вимагається авторизація.
// 403 (Forbidden) — у клієнта немає дозволу на доступ до цього ресурсу.
// 404 (Not Found) — у цей час ресурс не знайдений. Можливо, він був видалений або ще не існує.
// 500 (Internal Server Error) — загальна відповідь на непередбачений збій сервера, якщо відсутня конкретніша інформація.

//                                                               Class Response
// Метод fetch() поверта проміс значення якого —  об'єкт зі службовою інформацією про стан відповіді сервера. Цей об’єкт є ЕКЗЕМПЛЯРОМ КЛАСУ Response, який включає різні методи та властивості. Щоб перетворити тіло відповіді у дані використовують вбудовані методи (залежно від типу отримуваного контенту):
//      - json() — парсить дані у JSON-форматі.
//      - text() — парсить дані у простому текстовому форматі, наприклад .csv (табличні дані).
//      - blob() — парсить дані, що описують файл, наприклад, зображення, аудіо або відео.
// ех перший then() - перевірка статусу відповіді й ПЕРЕТВОРЕННЯ ДАННИХ У ПРАВИЛЬНИЙ (парсинг) у разі успішного результату або явне створення помилки, щоб обробити невдалий HTTP-запит у методі catch().
fetch('https://jsonplaceholder.typicode.com/users')
  .then(response => {
    if (!response.ok) {
      throw new Error(response.status);
    }
    return response.json();
  })
  .then(data => {
    // Data handling
    console.log(data);
  })
  .catch(error => {
    // Error handling
    console.log(error);
  });

//                                                      HTTP-методи
//  HTTP-методів для роботи з REST-сервісом:
// POST — створити новий ресурс.
// GET — отримати набір ресурсів або один ресурс.
// PUT — оновити існуючий або створити новий ресурс.
// PATCH — оновити існуючий ресурс.
// DELETE — видалити ресурс.

//  вказати HTTP - метод необхідно в другий аргумент методу fetch(об'єкт налаштувань запиту). У його властивості method необхідно передати рядок, що описує HTTP-метод.
const options69 = {
  method: 'GET',
};

fetch('https://jsonplaceholder.typicode.com/users', options69)
  .then(response => {
    if (!response.ok) {
      throw new Error(response.status);
    }
    return response.json();
  })
  .then(data => {
    // Data handling
  })
  .catch(error => {
    // Error handling
  });

//   !!!!!!!!!!!GET-запит вказувати  в опціях fetch не потрібно, це метод запиту ЗА ЗАМОВЧУВАННЯМ.
// Список можливих методів для кожного ресурсу описується в документації самого бекенда.

//                                                               HTTP-заголовки (HEADERS in Network)
// Заголовки містять службову інформацію, що стосується запиту або відповіді. Заголовок складається з імені та значення, наприклад:

// - заголовок Accept визначає ТИП КОНТЕНТУ, який клієнт може прийняти та правильно обробити у відповіді від сервера ;
// - заголовок Content-Type описує ТИП РЕСУРСУ в запиті або відповіді, щоб отримувач знав, як правильно ці дані інтерпретувати.
// Accept: text/html
// Content - Type: application / json

// Значення заголовка — це MIME-тип (тип контенту), який використовується для вказівки типу контенту запиту чи відповіді і складається з типу і підтипу, розділених косою рискою (/).
// - text/html - текстовий файл, який містить HTML
// - text/css - текстовий файл містить CSS
// - application/json - дані у форматі JSON

// Всі заголовки ВІДПОВІДІ в секції Response Headers, а заголовки ЗАПИТУ — в секції Request Headers.

// Для складання заголовків запиту використовують літерал об'єкта з властивостями, де кожен заголовок і його значення описується окремою властивістю. Усе це описується в об'єкті налаштувань методу fetch у властивості headers.
// fetch('url', {
//   headers: {
//     'Content-Type': 'application/json',
//     'X-Custom-Header': 'custom value',
//   },
// });
// Наприклад, якщо ми хочемо явно вказати, що у відповіді від бекенда ми очікуємо тільки JSON, то для цього додаємо заголовок Accept зі значенням application/json.
fetch('https://jsonplaceholder.typicode.com/users', {
  headers: {
    Accept: 'application/json',
  },
}).then(response => {
  // ...
});

// Сучасні браузери додають багато заголовків за замовчуванням, тому немає потреби явно вказувати СТАНДАРТІ ЗАГОЛОВКИ:
//   - User-Agent: Ідентифікує клієнтське програмне забезпечення, яке виконує запит.
//   - Accept: Вказує, які типи медіа клієнт може обробляти.
//   - Content-Type: Вказує тип контенту в тілі запиту або відповіді.
//   - Authorization: Використовується для передачі облікових даних для аутентифікації.
//   - Cache-Control: Директиви для керування кешуванням.
//   - Host: Доменне ім'я ресурсу, до якого виконується запит.

//                                           Кросдоменні запити Cross-Origin Resource Sharing (CORS)
// CORS - політика браузерів, «спільне використання ресурсів між різними джерелами», де Origin — це і є домен, порт або протокол.
//  ЗА ЗАМОВЧУВАННЯМ HTTP - запит МОЖНА РОБИТИ ТІЛЬКИ В РАМКАХ ПОТОЧНОГО САЙТУ.При спробі запиту на інший домен, порт або протокол(тобто при спробі виконати кросдоменний запит), браузер видає помилку.Це зроблено з міркувань безпеки, і права доступу налаштовуються на бекенді.Якщо бекенд не підтримує кросдоменні запити, фронтенд - розробник нічого не зможе з цим зробити у своєму коді.

//  На кожному запиті браузер сам додає HTTP-заголовок Origin, де вказує адресу вебсторінки, яка хоче зробити HTTP-запит. Наприклад, якщо ми робимо fetch-запит із вебсторінки https://my-site.com/about на https://my-api.com/users, то заголовки будуть наступними:
// GET /users
// Host: my-api.com
// Origin: https://my-site.com

//                      HTTP-заголовок Access-Control-Allow-Origin
// Сервер перевіряє заголовок Origin і, якщо він(САЙТ З ЯКОГО РОБЛЯТЬ ЗАПИТ) підтримує кросдоменні запити, додає у відповідь спеціальний HTTP - заголовок Access - Control - Allow - Origin.
// Заголовок Access - Control - Allow - Origin ВИЗНАЧАЄ ДОЗВОЛЕНІ ДЖЕРЕЛА, які мають право отримувати відповідь на кросдоменні запити.Для приватного бекенду значенням цього заголовку буде https://my-site.com, а ДЛЯ ПУБЛІЧНОГО — СПЕЦСИМВОЛ *, що дозволяє доступ для всіх:
// # Private API
// Access-Control-Allow-Origin: <https://my-site.com>

// # Public API
// Access-Control-Allow-Origin: *

// Отже, БРАУЗЕР - ЦЕ ПОСЕРЕДНИК між JavaScript-кодом і бекендом. Він додає кожному запиту заголовок Origin з правильним значенням і перевіряє наявність заголовка Access-Control-Allow-Origin у відповіді. Якщо заголовок є і його значення підходить, виконається оригінальний запит і JavaScript-код отримає його результат, в іншому випадку буде помилка CORS.

//                                                                         AJAX
// AJAX (Asynchronous JavaScript and XML) — метод отримання або відправлення даних з подальшим оновленням інтерфейсу за цими даними, БЕЗ ПОТРЕБИ ПЕРЕЗАВАНТАЖЕННЯ СТОРІНКИ. Завдяки цьому зменшується час відгуку і вебсторінка стає інтерактивнішою.

// в назві технології присутній XML, у сучасному інтернеті його замінив JSON, а назву залишили як данину пам'яті. AJAX трактується як будь-яке спілкування з сервером без перезавантаження сторінки.
//  процес можна розібрати на прикладі завантаження даних.
// 1) На вебсторінці відбувається подія (сторінка завантажується, натискається кнопка “Показати більше”, відправляється форма тощо).
// 2) На клієнті за допомогою JavaScript реакцією на цю подію буде виконуватися функція для роботи з сервером, де створюється і відправляється HTTP-запит.
// 3) Сервер отримує й обробляє HTTP-запит, відправляючи назад у відповіді дані у форматі JSON.
// 4) На клієнті за допомогою JavaScript відповідь від сервера обробляється, зчитуються дані і оновлюється інтерфейс.

// ех Оновлення інтерфейсу
// за допомогою точки доступу до даних серверу JSONPlaceholder API отримуємо масив користувачів за допомогою методу fetch і відтворюємо його в інтерфейсі (на сторінці).
// 1) При кліку на кнопку Fetch users виконуємо HTTP-запит, використовуючи вже знайомий нам метод fetch.
// у першому then -перевірка статусу відповіді й ПЕРЕТВОРЕННЯ ДАННИХ У ПРАВИЛЬНИЙ (парсинг). У другому then отримуємо доступ до даних відповіді від бекенда. Саме тут можна використати ці дані й оновити інтерфейс, створити HTML-розмітку і додати її в DOM у якийсь уже наявний елемент.
// 2)створення HTML-розмітки можна використовувати будь-який зручний спосіб, наприклад createElement або insertAdjacentHTML. Розглянемо одну зі стандартних технік.
// - Перебираємо масив об'єктів методом .map().
// - На кожній ітерації повертаємо HTML-розмітку для одного елемента колекції.
// - Результуючий масив рядків зшиваємо в один рядок методом .join("").
// - Додаємо рядок з HTML-розміткою в DOM методом .insertAdjacentHTML().
const fetchUsersBtn = document.querySelector('.btn-for-ajax');
const userList = document.querySelector('.user-list-ex');

fetchUsersBtn.addEventListener('click', () => {
  fetch('https://jsonplaceholder.typicode.com/users')
    .then(response => {
      if (!response.ok) {
        throw new Error(response.status);
      }
      return response.json();
    })
    .then(users => {
      console.log(users);

      const markup = users
        .map(user => {
          return `<li>
	          <p><b>Name</b>: ${user.name}</p>
	          <p><b>Email</b>: ${user.email}</p>
	          <p><b>Company</b>: ${user.company.name}</p>
	        </li>`;
        })
        .join('');

      userList.insertAdjacentHTML('beforeend', markup);
    })
    .catch(error => console.log(error));
});
// refactoring
// fetchUsersBtn.addEventListener('click', () => {
//   fetchUsers()
//     .then(users => renderUsers(users))
//     .catch(error => console.log(error));
// });

// function fetchUsers() {
//   return fetch('https://jsonplaceholder.typicode.com/users').then(response => {
//     if (!response.ok) {
//       throw new Error(response.status);
//     }
//     return response.json();
//   });
// }

// function renderUsers(users) {
//   const markup = users
//     .map(user => {
//       return `<li>
//           <p><b>Name</b>: ${user.name}</p>
//           <p><b>Email</b>: ${user.email}</p>
//           <p><b>Company</b>: ${user.company.name}</p>
//         </li>`;
//     })
//     .join('');
//   userList.insertAdjacentHTML('beforeend', markup);
// }

// TIPICAL mistake
// // Зовні колбека методу then у синхронному коді немає доступу до даних асинхронної відповіді бекенда, БУДЕ UNDEFINED
// Тому дуже важливо пам'ятати, що спроба записати результат асинхронної операції в зовнішню змінну й використовувати його в синхронному коді — неефективний підхід. Замість цього краще використовувати методи .then() та .catch() для обробки результатів асинхронних операцій одразу після їх отримання.

//                                    Параметри рядка запиту
// СИМВОЛ ? вказує на початок параметрів запиту.Кожен параметр — це пара ім'я=значення.
// У рядку запиту параметри між собою розділяються СИМВОЛОМ &.
// Параметри запиту дозволяють вказати бекенду додаткові критерії, наприклад:
// _limit,  кількість елементів у відповіді;
// _sort,  порядок сортування об'єктів у масиві.
// обмежити вибірку тощо.

// Список параметрів запиту, їх назви і можливі значення залежать від бекенду і описані в документації до нього.

//     fetch("https://jsonplaceholder.typicode.com/users?_limit=7&_sort=name")
// GET-запит у прикладі вище поверне масив із семи користувачів (загалом їх 10), відсортованих за ім'ям (поле name) за алфавітним порядком. Підкреслення в іменах параметрів специфічні для цього бекенда,

//
//                                             Клас URLSearchParams
// Під час складання рядків параметрів, створюється екземпляр класу URLSearchParams та ініціалізується об'єктом. Результатом буде спеціальний об'єкт (ітератор) з методами, який у рядковому перетворенні повертає результат виклику методу toString() — своє рядкове відображення.

// const searchParams = new URLSearchParams({
//   _limit: 5,
//   _sort: "name",
// });

// console.log(searchParams.toString()); // "_limit=5&_sort=name"
// const url = `https://jsonplaceholder.typicode.com/users?${searchParams}`;
// console.log(url); // "https://jsonplaceholder.typicode.com/users?_limit=5&_sort=name"

// У рядковому вигляді властивості об'єкта стануть параметрами та їх значеннями. Параметри будуть розділені символом &. У разі інтерполяції значення в шаблонних рядках відбувається його неявне перетворення в рядок, тому не потрібно викликати метод toString() під час складання URL. Не забувай вказувати початок рядка запиту символом ?.

// ex
// fetch() робить запит на сервер тому це асинхронна операція
// проміс що повертає fetch ми бачимо в 1 then, якщо успішно витягли дані з сервера ВЛАСТИВІСТЬ - ок - в об*єкті проміс буде true
// ОБОВ*ЯЗКОВО розпарсюємо дані методом .json();
// ОБОВ*ЯЗКОВО створити екземпляр класу throw new Error() щоб вловити помилку в 1 then (помилка 404 не знайдено - для fetch не помилка бо результат повернувся і відпрацює 2 then не так як треба потім відпрацює в самом низу catch  )
const params = new URLSearchParams({
  _limit: 5,
  _page: 2,
});
const listJsonPlaceholder = document.querySelector('.list-JSONPlaceholder');
fetch(`https://jsonplaceholder.typicode.com/todos?${params}`)
  .then(response => {
    console.log(response);
    if (!response.ok) {
      // якщо статис виконання не успішний -
      // викинь екземпляр помилки (він виведеться в блоці .catch)
      throw new Error(`Oppppppps it's error - ${response.status}`);
    }
    return response.json();
  })
  .then(data => {
    console.log(data);
    listJsonPlaceholder.insertAdjacentHTML('beforeend', createMarkup2(data));
  })
  .catch(err => {
    listJsonPlaceholder.insertAdjacentHTML(
      'beforeend',
      `<p>${err.message}</p>`
    );
    console.log(err);
  });

function createMarkup2(arr) {
  return arr.map(
    //    true/false       true   повернеться значення останнього true і стане атрибутом у розмітці
    //  ${completed && 'checked'}
    ({ id, title, completed }) =>
      `<li data-id="${id}" class="itemJsonPlaceholder">
  <input type="checkbox" ${completed && 'checked'}>
    <p>${title}</p>
  </li>`
  );
}
//  екземпляр класу URLSearchParams
const params3 = new URLSearchParams({
  _limit: 5,
  _page: 2,
});
console.log(params3);

// автоматизуємо запит на сервер для різних посилань щоб не дублювати код кожного разу
function foo2(url) {
  return fetch(url).then(response => {
    if (!response.ok) {
      throw new Error(response.statusText);
    }

    return response.json();
  });
}

console.log(foo2('https://jsonplaceholder.typicode.com/users'));

foo2('https://jsonplaceholder.typicode.com/users')
  .then(data => console.log(data))
  .catch(err => console.log('catch', err));

//Авторизація запитів з ключами буває:
// - у query string (в параметрі url у fetch)
// - у ключі хедерс в обєкті параметрів
// fetch('https://pixabay.com/api/', {
//   headers: {
//     Authorisation: `Bearer ${PIXABAY_KEY}`
//   }
// });

// EX
// працюємо з публічним API  сервер з фото і відео https://pixabay.com/api/docs/
// ключ отримати при реєстрації , на одну пошту - один ключ дають
const pixabayList = document.querySelector('.pixabay-list');

const PIXABAY_KEY = '47506069-50a24acca197abc732faaa7f2';
// запрашуємо фото по пошуковому слові з серверу, якщо треба більше 1 слова то:
// - прямо в url прописати в ${encodeURIComponent('red rose')}
// - краще створ екземпляр URLSearchParams:
const params5 = new URLSearchParams({
  key: PIXABAY_KEY,
  q: 'red rose',
});
fetch(`https://pixabay.com/api/?${params5}`)
  .then(response => {
    if (!response.ok) {
      throw new Error(response.message);
    }
    return response.json();
  })
  .then(data => {
    console.log(data);
    return pixabayList.insertAdjacentHTML(
      'beforeend',
      createMarkupPixabay(data.hits)
    );
  })
  .catch(err => console.log(err));

function createMarkupPixabay(arr) {
  return arr
    .map(
      ({ id, previewURL, tags }) =>
        `<li data-id="${id}">
  <img class="pixabay-img" src="${previewURL}" alt="${tags}" width="300"/>
  <h2 class="pixabay-tags">${tags}</h2>
  </li>`
    )
    .join('');
}

// EX створ функціонал показу погоди згідно міста - викор публічний API https://www.weatherapi.com/
// use ENDPOINT Forecast щоб отримати прогноз погоди
// після сабміту форми відмалюй картки з: зображення з погодою icon, text, date, avgtemp_c (середня темп в цельсіях)
const WHEATHER_KEY = '2fe29d20322d49ab8fc180940240812';
const BASE_URL = 'http://api.weatherapi.com/v1';

const weatherList = document.querySelector('.wheather-list');
const wheatherForm = document.querySelector('.wheather-form');

wheatherForm.addEventListener('submit', handleSearchWheather);
function handleSearchWheather(event) {
  event.preventDefault();
  const { cityWheather, quantityDays } = event.target.elements;
  console.log(cityWheather.value, quantityDays.value);
  fetchWheather(BASE_URL, cityWheather.value, quantityDays.value)
    .then(data => {
      console.log(data);
      weatherList.innerHTML = createWheatherMarkup(data);
    })
    .catch(err =>
      weatherList.insertAdjacentHTML(
        'beforeend',
        `<h2>Sorry, we have a problem ${err}</h2>`
      )
    )
    .finally(() => event.target.reset());
}

function fetchWheather(url, city = '', days = 1) {
  const paramsWheather = new URLSearchParams({
    key: WHEATHER_KEY,
    q: city,
    days,
    lang: 'en',
  });
  //                 breakpoint
  return fetch(`${url}/forecast.json?${paramsWheather}`).then(response => {
    if (!response.ok) {
      throw new Error(response.statusText);
    }
    return response.json();
  });
}

function createWheatherMarkup({ forecast: { forecastday } }) {
  console.log(forecastday);
  return forecastday
    .map(
      ({
        date,
        day: {
          avgtemp_c,
          condition: { icon, text },
        },
      }) => `
    <img src="${icon}" alt="${text}" width="200" >
    <h3>${date}</h3>
    <h2>${text}</h2>
    <h3>The average temrature - ${avgtemp_c}C*</h3>`
    )
    .join('');
}

//                                           CRUD
// Для взаємодії з ресурсами бекенду використовується чотири операції:
// C - створення (create),
// R - читання (read),
// U - оновлення (update),
// D - видалення(delete)'

//   METHODS BY CRUD:
// POST (Create) — створити новий ресурс.
// GET (Read) — отримати набір ресурсів або один ресурс за ідентифікатором.
// PUT і PATCH (Update) — оновити ресурс за ідентифікатором.
// DELETE (Delete) — видалити ресурс за ідентифікатором.
