{"version":3,"file":"index.js","sources":["../src/js/modul-12.js"],"sourcesContent":["'use strict';\n// npm install axios\n\nimport axios from 'axios';\n\nimport iziToast from 'izitoast';\nimport 'izitoast/dist/css/iziToast.min.css';\n// Бібліотека Axios — це простий HTTP-клієнт, що базується на Promise і автоматизує багато рутинних завдань при роботі з HTTP-запитами, а саме дозволяє:\n\n// ⭐️Axios є зручною альтернативою стандартному Fetch API.\n// Синтаксис запиту:\n// 1)Запити можна робити, викликавши axios і передаючи відповідний об'єкт конфігурації. Напишемо код, який виконує GET-запит.\n// Після виконання функції axios ми отримуємо проміс, який обробляємо стандартними методами then і catch.\n\naxios({\n  method: 'get',\n  url: 'https://jsonplaceholder.typicode.com/users',\n})\n  .then(response => console.log(response))\n  .catch(error => console.log(error));\n// 2)or Псевдоніми методів запиту\n// У бібліотеці Axios існують псевдоніми (однойменні методи) для всіх підтримуваних методів запиту, які спрощують синтаксис запиту та додають стандартні налаштування.\n\naxios\n  .get('https://jsonplaceholder.typicode.com/users')\n  .then(response => console.log(response))\n  .catch(error => console.log(error));\n// ⭐️ метод axios.get потребує обов'язково лише адреси запиту, а метод GET автоматично підставляється сам.\n// ⭐️ Axios додає до запиту стандартні HTTP-заголовки, наприклад, Accept, у якому вказує application/json, оскільки найчастіше ми очікуємо саме JSON від сервера.\n\n//                        ⭐️Об'єкт відповіді на запит\n// {\n//   data: {},\n//   status: 200,\n//   statusText: 'OK',\n//   headers: {},\n//   config: {},\n//   request: {}\n// }\n// ⭐️data — відповідь, надана сервером;\n// status — код стану HTTP з відповіді сервера;\n// statusText — повідомлення про стан HTTP від відповіді сервера;\n// headers — заголовки HTTP, з якими відповів сервер;\n// config — конфігурація, яка була надана Axios для запиту;\n// request — запит, який створив цю відповідь;\n\n// У методі then ти отримаєш наступні властивості в об'єкті відповіді.\naxios\n  .get('https://jsonplaceholder.typicode.com/users')\n  .then(response => {\n    console.log(response.data);\n    console.log(response.status);\n    console.log(response.statusText);\n    console.log(response.headers);\n    console.log(response.config);\n  })\n  .catch(error => {\n    console.log(error);\n  });\n\n// Зверни увагу, на властивість data, у якій зберігаються дані відповіді.\n\n// ⭐️не потрібно парсити дані відповіді методом response.json().Це робиться автоматично і додається до властивості data.\n// ⭐️не потрібно перевіряти статус відповіді у властивості response.ok.Бібліотека Axios робить це автоматично і відхиляє проміс з помилкою для будь - якого невдалого HTTP - коду відповіді, включаючи 404.\n\n//                                        Конфігурація за замовчуванням\n// Можна вказати стандартні налаштування конфігурації у властивості axios.defaults, які будуть застосовані до кожного\naxios.defaults.baseURL = 'https://jsonplaceholder.typicode.com';\n\n// axios.get('/users').then().catch();\n\n// axios.get('/posts').then().catch();\n\n// axios.get('/images').then().catch();\n\n//                                                 Заголовки за замовчуванням\n// Наприклад, якщо у тебе є унікальний ключ API, який необхідно додавати до кожного запиту у вигляді HTTP-заголовка, ти можеш додати його до властивості axios.defaults.headers.common.\n\nconst myApiKey = 'secret-api-key-for-every-request';\n\naxios.defaults.headers.common['header-name'] = myApiKey;\n\n// Замість рядка \"header-name\" вказуємо потрібну назву заголовка у вигляді рядка.\n// Іншими словами, ми буквально додаємо нову властивість із ключем \"header-name\" до об'єкта axios.defaults.headers.common. Після цього Axios автоматично додасть цей заголовок із вказаним значенням до кожного запиту.\n\n//                                               Параметри рядка запиту\n// -вказати їх у URL.\n// - використати клас URLSearchParams\n// -Axios надає нам зручніший спосіб. В об'єкті конфігурації (параметр config) ти можеш вказати об'єкт параметрів у властивості params.\naxios.get('https://jsonplaceholder.typicode.com/users', {\n  params: {\n    _limit: 7,\n    _sort: 'name',\n  },\n});\n\n//                                                 Асинхронні функції\n// Синтаксис async/await — це зручний спосіб написання асинхронного коду, був доданий до стандарту ECMAScript 2017 (ES8) і став дуже популярним\n// Для оголошення асинхронної функції додається async\n// -перед ключовим словом function\nasync function fetchData() {\n  // ...\n}\n//-y функціональному виразі також перед ключовим словом function додається async.\nconst fetchData6 = async function () {\n  // ...\n};\n// -y стрілкової функції перед списком параметрів\nconst fetchData7 = async () => {\n  // ...\n};\n// -y методу об'єкта async додається перед іменем методу.\nconst user = {\n  async getUsername() {\n    // ...\n  },\n};\n// В основі async/await лежать проміси, тому він не блокує основний потік виконання програми. По суті, це сучасний спосіб роботи з промісами всередині функції, і це є альтернативою конструкції then/catch.\n\n// будь - яке значення, що повертається з функції(return), стане значенням проміса.\n// Якщо не вказувати значення для повернення, буде створений проміс зі значенням undefined.\n\n//                                                           Оператор await\n// ТІЛЬКИ всередині АСИНХРОННИХ функцій можна використовувати оператор await, розмістивши його праворуч від будь-якого виразу, який повертає проміс.\n// Коли інтерпретатор зустрічає await, він ПРИЗУПИНЯЄ ВИКОНАННЯ Ф-ЦІЇ і чекає, ДОКИ ЗАВЕРШИТЬСЯ ВИКОНАННЯ ПРОМІСУ, який  ПРАВОРУЧ від await.\n//\n// Підсумуємо:\n// ⭐️Оператор await можна використовувати тільки всередині асинхронних функцій (async).\n// ⭐️await не може використовуватись без async, але async може використовуватися без await.\n// ⭐️Оператор await призупиняє виконання функції до завершення відповідного промісу (fulfilled або rejected).\n// ⭐️Якщо проміс завершується успішно (fulfilled), оператор await повертає його значення.\n// ⭐️Якщо проміс завершується з помилкою (rejected), оператор await генерує помилку.\n// ⭐️Асинхронна функція завжди повертає проміс, отже, будь-яке значення, що повертається, стає значенням цього промісу.\n// ⭐️Якщо не вказати значення для повернення, буде створений проміс зі значенням undefined.\n\n// HTTP-запити\n// Використаємо синтаксис async/await при роботі з HTTP-запитами, щоб зробити код більш читабельним.\n// ЕХ перепишемо функцію fetchUsers, використовуючи синтаксис async/await\n// const fetchUsers = () => {\n//   axios.get('https://jsonplaceholder.typicode.com/users').then(response => {\n//     console.log(response.data);\n//   });\n// };\n//1) додаємо ключове слово async\n// 2)використовуємо оператор await, щоб зачекати завершення axios.get та отримати об'єкт відповіді у змінну response\n// 3) поверни значення результатy HTTP-запитуз асинхронної функції та оброби його в методі then, якщо потрібно використовувати в зовнішньому коді\nconst fetchUsers = async () => {\n  const response = await axios.get(\n    'https://jsonplaceholder.typicode.com/users'\n  );\n  console.log(response.data);\n  return response.data;\n};\n\nfetchUsers().then(users => console.log(users));\n\n//                                                         Конструкція try…catch\n// Конструкція try...catch — це механізм обробки винятків.Конструкція try...catch виконує код у блоці try, і якщо в цьому блоці виникає помилка (виняток), виконання коду у try зупиняється, і контроль передається до блоку catch.\n// Параметр error представляє об'єкт помилки, в якому зазвичай міститься інформація про помилку, така як повідомлення про помилку.\n\n// try {\n//   const result = 10 / 0;\n//   console.log(result); // Цей рядок не виконається через помилку\n// } catch (error) {\n//   // Обробимо помилку\n//   console.error(error.message);\n// }\n//                                              ОТЖЕ ОБРОБКА ПОМИЛОК:\n// ⭐️Якщо результат асинхронної функції (проміс) НЕ ВИКОРИСТОВУЄТЬСЯ В ЗОВН КОДІ, помилки оброблюються у самому тілі функції за допомогою конструкції ⭐️TRY...CATCH . Значення параметра error у блоці catch — це помилка, яку генерує await, якщо проміс був відхилений.\nconst fetchUsers2 = async () => {\n  try {\n    const response = await axios.get(\n      'https://jsonplaceholder.typicode.com/users'\n    );\n    console.log(response.data);\n  } catch (error) {\n    console.log(error);\n  }\n};\n//⭐️Якщо результат асинхронної функції (проміс) ВИКОРИСТОВУЄТЬСЯ В ЗОВН КОДІ, тобто за межами інших асинхронних функцій, помилки оброблюються методом CATCH() колбеку. Значення параметра error ⭐️у методі catch() — це помилка, яку генерує await, якщо проміс буде відхилений.\nconst fetchUsers3 = async () => {\n  const response = await axios.get(\n    'https://jsonplaceholder.typicode.com/users'\n  );\n  return response.data;\n};\n\nfetchUsers3()\n  .then(users => console.log(users))\n  .catch(error => console.log(error));\n//⭐️Якщо результат асинхронної функції ВИКОР В ІНШІЙ АСИНХРОННІЙ Ф-ЦІЇ, помилки оброблюються конструкцією ⭐️TRY...CATCH. Значення параметра error у блоці catch представляє помилку, яку генерує await, якщо проміс буде відхилений.\nconst fetchUsers4 = async () => {\n  const response = await axios.get(\n    'https://jsonplaceholder.typicode.com/users'\n  );\n  return response.data;\n};\n\nconst doStuff = async () => {\n  try {\n    const users = await fetchUsers4();\n    console.log(users);\n  } catch (error) {\n    console.log(error);\n  }\n};\n\ndoStuff();\n\n//                                                    Пагінація (pagination)\n//Пагінація - РОЗБИВКА НА СТОРІНКИ результату GET-запиту. Пагінація передбачає, що сервер повертає не всю колекцію, а лише певну частину записів при кожному GET-запиті. Пагінацію реалізують на сервері та використовують її на клієнтському боці завдяки спеціальним параметрам у запиті.\n// ЕХ\n// Для прикладу роботи з колекцією даних ми використовуємо публічний JSONPlaceholder API та отримуємо масив постів з ендпоінта /posts.\nconst fetchPosts = async () => {\n  const response = await axios.get(\n    'https://jsonplaceholder.typicode.com/posts'\n  );\n  console.log('Posts: ', response.data);\n};\n// 1)Перший параметр per_page -  визначає кількість елементів у відповіді від сервера.\n// _limit - параметр JSONPlaceholder API що контролює кількість елементів у відповіді\n// 2)Другий параметр пагінації page - контролює зміщення всередині колекції, тобто номер групи елементів, яку ми хочемо отримати. Якщо сервер реалізує пагінацію, то значення цього параметра за замовчуванням дорівнює одиниці — перша група або «сторінка» елементів.\n// _page - параметр у JSONPlaceholder API , що контролює групу елементів.\n// Щоб визначити, коли елементи в колекції закінчаться, і вивести користувачу повідомлення про це, сервер може повертати не тільки масив елементів, але й:\n// -метадані про доступну кількість груп, що залежить від значення параметра per_page,\n// або\n// -просто загальну кількість елементів у колекції.\n// ех\n// const fetchPostsBtn = document.querySelector('.btn-pagination');\n// const postList = document.querySelector('.posts');\n\n// fetchPostsBtn.addEventListener('click', async () => {\n//   try {\n//     const posts = await fetchPosts();\n//     renderPosts(posts);\n//   } catch (error) {\n//     console.log(error);\n//   }\n// });\n\n// async function fetchPosts() {\n//   const params = new URLSearchParams({\n//     _limit: 5,\n//     // Change the group number here\n//     _page: 3,\n//   });\n\n//   const response = await axios.get(\n//     `https://jsonplaceholder.typicode.com/posts?${params}`\n//   );\n//   return response.data;\n// }\n\n// function renderPosts(posts) {\n//   const markup = posts\n//     .map(({ id, title, body, userId }) => {\n//       return `<li>\n//           <h2 class=\"post-title\">${title.slice(0, 30)}</h2>\n//           <p><b>Post id</b>: ${id}</p>\n//           <p><b>Author id</b>: ${userId}</p>\n//           <p class=\"post-body\">${body}</p>\n//         </li>`;\n//     })\n//     .join('');\n//   postList.innerHTML = markup;\n// }\n//                                            Прийом «Завантажити ще»\n// Для динамічної зміни номера групи при кожному наступному запиті :\n// 1)Оголосимо ще одну глобальну змінну, назвемо її page і встановимо початкове значення 1 — перша група елементів.\n// 2)Після кожного успішного запиту в обробнику методу then() ми будемо збільшувати значення page на одиницю. Потім ми використовуємо це значення при складанні параметрів запиту.\nconst fetchPostsBtn = document.querySelector('.btn-pagination');\nconst postList = document.querySelector('.posts');\n\n// Controls the group number\nlet page = 1;\n// Controls the number of items in the group\nlet perPage = 10;\n\nfetchPostsBtn.addEventListener('click', async () => {\n  try {\n    const posts = await fetchPosts3();\n    renderPosts(posts);\n    // Increase the group number\n    page += 1;\n\n    // Replace button text after first request\n    if (page > 1) {\n      fetchPostsBtn.textContent = 'Fetch more posts';\n    }\n  } catch (error) {\n    console.log(error);\n  }\n});\n\nasync function fetchPosts3() {\n  const params = new URLSearchParams({\n    _limit: perPage,\n    _page: page,\n  });\n\n  const response = await axios.get(\n    `https://jsonplaceholder.typicode.com/posts?${params}`\n  );\n  return response.data;\n}\n\nfunction renderPosts(posts) {\n  const markup = posts\n    .map(({ id, title, body, userId }) => {\n      return `<li>\n          <h2 class=\"post-title\">${title.slice(0, 30)}</h2>\n          <p><b>Post id</b>: ${id}</p>\n          <p><b>Author id</b>: ${userId}</p>\n          <p class=\"post-body\">${body}</p>\n        </li>`;\n    })\n    .join('');\n  postList.insertAdjacentHTML('beforeend', markup);\n}\n//                                           Перевірка кінця колекції\n// Відсутність постів для завантаження під час кліку на кнопку \"Fetch posts\" означає, що користувач досяг кінця колекції. Коли це трапляється, необхідно відобразити сповіщення.\n// Для цього ми використовуємо бібліотеку iziToast.\n// ЕХ  додали перевірку кінця колекції на фронтенді, оскільки JSONPlaceholder API не реалізує цей функціонал на бекенді. У нашому випадку достатньо розділити загальну кількість елементів у колекції (100) на кількість елементів в одній групі.\n// Контролює кількість елементів в групі\n// let limit = 30;\n// // Кількість груп в колекції\n// const totalPages = Math.ceil(100 / limit);\n// //\n// // Перед кожним наступним запитом ми порівнюємо поточний номер групи і загальну кількість груп і виводимо сповіщення, не виконуючи HTTP-запиту.\n// if (page > totalPages) {\n//   return iziToast.error({\n//     position: 'topRight',\n//     message: \"We're sorry, there are no more posts to load\",\n//   });\n// }\n// ЕХ\n// const fetchPostsBtn = document.querySelector('.btn');\n// const postList = document.querySelector('.posts');\n\n// Controls the group number\nlet pagee = 1;\n// Controls the number of items in the group\nlet limit = 40;\n// In our case total number of pages is calculated on frontend\nconst totalPages = Math.ceil(100 / limit);\n\nfetchPostsBtn.addEventListener('click', async () => {\n  // Check the end of the collection to display an alert\n  if (pagee > totalPages) {\n    return iziToast.error({\n      position: 'topRight',\n      message: \"We're sorry, there are no more posts to load\",\n    });\n  }\n\n  try {\n    const posts = await fetchPosts4();\n    renderPosts3(posts);\n    // Increase the group number\n    pagee += 1;\n\n    // Replace button text after first request\n    if (pagee > 1) {\n      fetchPostsBtn.textContent = 'Fetch more posts';\n    }\n  } catch (error) {\n    console.log(error);\n  }\n});\n\nasync function fetchPosts4() {\n  const params = new URLSearchParams({\n    _limit: limit,\n    _page: pagee,\n  });\n\n  const response = await axios.get(\n    `https://jsonplaceholder.typicode.com/posts?${params}`\n  );\n  return response.data;\n}\n\nfunction renderPosts3(posts) {\n  const markup = posts\n    .map(({ id, title, body, userId }) => {\n      return `<li>\n          <h2 class=\"post-title\">${title.slice(0, 30)}</h2>\n          <p><b>Post id</b>: ${id}</p>\n          <p><b>Author id</b>: ${userId}</p>\n          <p class=\"post-body\">${body}</p>\n        </li>`;\n    })\n    .join('');\n  postList.insertAdjacentHTML('beforeend', markup);\n}\n//\n//                                           partial of url\n// https://example.com/over/there?name=ferret\n// - PROTOCOL https://\n// - HOST example.com\n// - PATH TO RESOURCE /over/there\n// - PARAMETERS ?name=ferret\n//                                                     Lection\n// ❌ex у цьому коді відбудеться 3 послідовні запроси на сервер за різними ДИНАМІЧНИМИ параметрами , і витратиться час (див вкладку Network), можна оптимізувати це\nconst BASE_URL_JSONPLACEHOLDER = 'https://jsonplaceholder.typicode.com';\n\nasync function foo6() {\n  const todo1 = await axios(`${BASE_URL_JSONPLACEHOLDER}/users/1/todos`);\n  const todo2 = await axios(`${BASE_URL_JSONPLACEHOLDER}/users/2/todos`);\n  const todo3 = await axios(`${BASE_URL_JSONPLACEHOLDER}/users/3/todos`);\n\n  return [todo1, todo2, todo3];\n}\n\nfoo6()\n  .then(data => console.log(data))\n  .catch(error => console.log(error));\n// ✅REFACTORING\n//refactoring the previous code - move dinamic parametr by url in array and iterating his with the method .map(). Results [promises] to proccessed with the method Promise.all([promises])\nasync function foo7() {\n  const dinamicParams = [1, 2, 3];\n\n  const prpmisesArr = dinamicParams.map(async par => {\n    const res = await axios(`${BASE_URL_JSONPLACEHOLDER}/users/${par}/todos`);\n    console.log(res.data);\n\n    return res.data;\n  });\n\n  const todos = await Promise.all(prpmisesArr);\n  console.log(todos);\n\n  return todos;\n}\n\nfoo7()\n  .then(data => {\n    const [arr1, arr2, arr3] = data;\n    console.log(arr1);\n  })\n  .catch(error => console.log(error));\n\n//  .......................................the start of EX\nconst todoForm = document.querySelector('.todoForm');\nconst todoContainer = document.querySelector('.todoList');\n// '/users/1/todos'\nasync function todoService(url = BASE_URL_JSONPLACEHOLDER, options = {}) {\n  const response = await axios(`${url}/users/1/todos`, options);\n  console.log(response.data);\n\n  return response.data;\n}\n\nfunction createTodoMarkup(array) {\n  return array\n    .map(\n      ({ id, title, completed }) => `\n  <li class='todoCard' data-id='${id}'>\n  <input type='checkbox' class='todoCheckbox' ${completed ? 'checked' : ''}/>\n  <h2 class='todoTitle'>${title.slice(0, 20)}</h2>\n  <button class='todoBtnDel'>X</button>\n  </li>`\n    )\n    .join('');\n}\ntodoService(BASE_URL_JSONPLACEHOLDER, { params: { _limit: 5 } })\n  .then(data =>\n    todoContainer.insertAdjacentHTML('beforeend', createTodoMarkup(data))\n  )\n  .catch(err => {\n    return iziToast.error({\n      position: 'topRight',\n      message: `Sorry, we are have a problem...${err.message}`,\n      displayMode: 1,\n    });\n  });\n\ntodoForm.addEventListener('submit', handlePostDataToService);\n// функція робить запит на сервер (створює) отже вона АСИНХРОННА\nasync function handlePostDataToService(event) {\n  event.preventDefault();\n  const userSTask = event.target.elements.todo.value;\n\n  if (!userSTask.trim()) {\n    return;\n  }\n  // запит на сервер - трай кетч\n  try {\n    const data = await todoService(`${BASE_URL_JSONPLACEHOLDER}`, {\n      method: 'POST',\n      data: {\n        title: userSTask,\n        completed: false,\n      },\n    });\n    console.log(data);\n\n    todoContainer.insertAdjacentHTML('beforeend', createTodoMarkup([data]));\n  } catch (err) {\n    return iziToast.error({\n      position: 'topRight',\n      message: `Sorry...${err.message}`,\n      displayMode: 1,\n    });\n  } finally {\n    event.target.reset();\n  }\n}\n// оновляємо дані якщо відмітили чексбокс\ntodoContainer.addEventListener('click', handlePatch);\nasync function handlePatch(event) {\n  if (!event.target.classList.contains('todoCheckbox')) {\n    console.log('ops it is not a checkbox!');\n    return;\n  }\n  // щоб чекбкс не змінювався без зміни даних на сервері\n  event.preventDefault();\n  // найближчий батьківський елемент івент таргета , отримуємо айді для серверного запросу\n  const parent = event.target.closest('.todoCard');\n  console.log(parent);\n  const id = parent.dataset.id;\n  console.log(id);\n  // запит на сервер - трай кетч\n  try {\n    console.log(event.target.checked);\n\n    const data = await todoService(`${BASE_URL_JSONPLACEHOLDER}/${id}`, {\n      method: 'PATCH',\n      data: { completed: event.target.checked },\n    });\n    // add changes on the cite\n    event.target.checked = data.completed;\n  } catch (error) {\n    return iziToast.error({\n      position: 'topRight',\n      message: `Sorry...${error.message}`,\n      displayMode: 1,\n    });\n  }\n}\n\n// 1.делегування подій на списку справ 2.отримуємо id елемента лішки по якій клікнули 3.звертаємось до сервера і видаляємо дані за id\ntodoContainer.addEventListener('click', handleDeletTask);\nasync function handleDeletTask(event) {\n  if (!event.target.classList.contains('todoBtnDel')) {\n    return;\n  }\n  const parent = event.target.closest('.todoCard');\n  const id = parent.dataset.id;\n  try {\n    await todoService(`${BASE_URL_JSONPLACEHOLDER}/${id}`, {\n      method: 'DELETE',\n    });\n\n    parent.remove();\n  } catch (error) {\n    return iziToast.error({\n      position: 'topRight',\n      message: `Sorry...${error.message}`,\n      displayMode: 1,\n    });\n  }\n}\n// ......................................................the end of EX\n// ..................................the start of EX the film's library\n// create the film's library with popular movie . use https://developer.themoviedb.org/reference/trending-movies\n// API_KEY put in params => headers.Authorozation: 'Bearer ${KEY}'\nconst API_Read_Access_Token =\n  'eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJhMWIxNTk0NzI5ZDlhODRlZjZkZTU2MmRiMjJiOTRkZSIsIm5iZiI6MTczNDUzMDE1Ny43ODIsInN1YiI6IjY3NjJkNDZkMTYxYWI3ZGVjNWZmZTgzMiIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.n11YprEyAIsNVgOqkidenCI4yQs_Y4WRKkJJKM74lkc';\n// put base url + dinamic url from object by service that getting the film's POSTER\n// 1)CREATE MARKUP WITH THE FILM'S CARD\n// 2)implement pagination:\n// 1 the button \"Load More\"\n// 2 INFINITY SCROLL ('https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API')\nconst filmsList = document.querySelector('.jsMovieList');\nconst loadMoreBTN = document.querySelector('.jsLoadMore');\nconst BASE_URL_MOVIE = 'https://api.themoviedb.org/3';\nconst END_POINT = '/trending/movie/week';\nconst MY_MOVIE_API_KEY = 'a1b1594729d9a84ef6de562db22b94de';\n\n// let pageMovie = 1;\n\n// async function fetchService(method, pageMovie) {\n//   const options = {\n//     method,\n//     headers: {\n//       accept: 'application/json',\n//       Authorization: `Bearer ${API_Read_Access_Token}`,\n//     },\n//   };\n//   const params = new URLSearchParams({\n//     page: `${pageMovie}`,\n//   });\n\n//   const response = await fetch(\n//     `https://api.themoviedb.org/3${END_POINT}?${params}`,\n//     options\n//   );\n\n//   return response.json();\n// }\n// fetchService('GET', pageMovie)\n//   .then(res => {\n//     console.log(res);\n\n//     filmsList.insertAdjacentHTML('beforeend', createMovieMarkup(res.results));\n//     if (res.page < res.total_pages) {\n//       loadMoreBTN.classList.replace('loadMoreHidden', 'loadMoreVisible');\n//     }\n//   })\n//   .catch(err => {\n//     return iziToast.error({\n//       position: 'topRight',\n//       message: `Sorry...${err.message}`,\n//       displayMode: 1,\n//     });\n//   });\n\n// function createMovieMarkup(array) {\n//   return array.map(\n//     ({\n//       poster_path,\n//       id,\n//       title,\n//       release_date,\n//       overview,\n//       vote_average,\n//     }) => `<li class='movieCard' data-id='${id}'>\n//     <div class='posterContainer'>\n// <a href=\"#\"><img class='moviePoster' src=\"https://image.tmdb.org/t/p/w300${poster_path}\" alt=\"${overview}\" ></a>\n// </div>\n// <div class=\"movieInfo\">\n//   <h2>${title}</h2>\n//   <p>${overview.slice(0, 350)}</p>\n// <p>The vote average: ${vote_average}</p>\n// <p>The release date: ${release_date}</p>\n// </div>\n// </li>`\n//   );\n// }\n// loadMoreBTN.addEventListener('click', handleLoadMoreMovie);\n// async function handleLoadMoreMovie(event) {\n//   pageMovie += 1;\n//   loadMoreBTN.disabled = true;\n//   fetchService('GET', pageMovie)\n//     .then(res => {\n//       filmsList.insertAdjacentHTML('beforeend', createMovieMarkup(res.results));\n//       if (res.page >= res.total_pages) {\n//         loadMoreBTN.classList.replace('loadMoreVisible', 'loadMoreHidden');\n//       }\n//       const cardMovie = document.querySelector('.movieCard');\n//       const cardHeight = cardMovie.getBoundingClientRect().height;\n//       window.scrollBy({\n//         left: 0,\n//         top: cardHeight * 2,\n//         behavior: 'smooth',\n//       });\n//     })\n//     .catch(err => {\n//       return iziToast.error({\n//         position: 'topRight',\n//         message: `Sorry...${err.message}`,\n//         displayMode: 1,\n//       });\n//     })\n//     .finally(() => (loadMoreBTN.disabled = false));\n// }\n\n//                               той самий код але замість кнопки INFINITY SCROLL\n// Intersection Observer API дозволяє коду реєструвати функцію зворотного виклику, яка виконується щоразу, коли певний елемент входить або виходить із перетину з іншим елементом (або вікном перегляду ), або коли перетин між двома елементами змінюється на вказану величину. Таким чином, сайтам більше не потрібно нічого робити в основному потоці, щоб спостерігати за таким перетином елементів, а браузер може вільно оптимізувати керування перетинаннями, як вважає за потрібне.\n\n// Одного не може зробити Intersection Observer API: запускати логіку на основі точної кількості пікселів, які перекриваються, або конкретно на тому, які з них є. Це вирішує лише поширений випадок використання: «Якщо вони перетинаються десь приблизно на N %, мені потрібно щось зробити».\n// Щоб спостерігати за перетином відносно вікна перегляду пристрою, вкажіть nullопцію root.\n// Створіть спостерігач перетину, викликавши його конструктор і передавши йому функцію зворотного виклику, яка буде запускатися щоразу, коли поріг перетинається в одному або іншому напрямку:\nconst options = {\n  root: null,\n  rootMargin: '300px',\n  // Порогове значення 1,0 означає, що коли 100% цілі видно в елементі, визначеному параметром root, викликається зворотний виклик.\n  threshold: 1.0,\n};\nconst observer = new IntersectionObserver(handleLoadMoreMovie, options);\nconst guard = document.querySelector('.jsGuard');\nlet pageMovie = 1;\n\nasync function fetchService(method, pageMovie) {\n  const options = {\n    method,\n    headers: {\n      accept: 'application/json',\n      Authorization: `Bearer ${API_Read_Access_Token}`,\n    },\n  };\n  const params = new URLSearchParams({\n    page: `${pageMovie}`,\n  });\n\n  const response = await fetch(\n    `https://api.themoviedb.org/3${END_POINT}?${params}`,\n    options\n  );\n\n  return response.json();\n}\nfetchService('GET', pageMovie)\n  .then(res => {\n    console.log(res);\n\n    filmsList.insertAdjacentHTML('beforeend', createMovieMarkup(res.results));\n    if (res.page < res.total_pages) {\n      observer.observe(guard);\n    }\n  })\n  .catch(err => {\n    return iziToast.error({\n      position: 'topRight',\n      message: `Sorry...${err.message}`,\n      displayMode: 1,\n    });\n  });\n\nfunction createMovieMarkup(array) {\n  return array\n    .map(\n      ({\n        poster_path,\n        id,\n        title,\n        release_date,\n        overview,\n        vote_average,\n      }) => `<li class='movieCard' data-id='${id}'>\n    <div class='posterContainer'>\n<a href=\"#\"><img class='moviePoster' src=\"https://image.tmdb.org/t/p/w300${poster_path}\" alt=\"${overview}\" ></a>\n</div>\n<div class=\"movieInfo\">\n  <h2>${title}</h2>\n  <p>${overview.slice(0, 350)}</p>\n<p>The vote average: ${vote_average}</p>\n<p>The release date: ${release_date}</p>\n</div>\n</li>`\n    )\n    .join('');\n}\n// функція автоматично відпрацьовує один раз як загружається сторінка, щоб вона відпрацьовувала тільки під час перетинання window - додаємо перевірку із документації\nasync function handleLoadMoreMovie(entries, observer) {\n  entries.forEach(entry => {\n    if (entry.intersectionRatio) {\n      pageMovie += 1;\n      fetchService('GET', pageMovie)\n        .then(res => {\n          filmsList.insertAdjacentHTML(\n            'beforeend',\n            createMovieMarkup(res.results)\n          );\n          // припинити слідкувати за гуард (або entry.target) якщо остання сторінка\n          if (res.page >= res.total_pages) {\n            observer.unobserve(guard);\n          }\n          const cardMovie = document.querySelector('.movieCard');\n          const cardHeight = cardMovie.getBoundingClientRect().height;\n          window.scrollBy({\n            left: 0,\n            top: cardHeight * 2,\n            behavior: 'smooth',\n          });\n        })\n        .catch(err => {\n          return iziToast.error({\n            position: 'topRight',\n            message: `Sorry...${err.message}`,\n            displayMode: 1,\n          });\n        });\n    }\n  });\n\n  // .finally(() => (loadMoreBTN.disabled = false));\n}\n"],"names":["axios","response","error","myApiKey","fetchUsers","users","fetchUsers3","fetchUsers4","doStuff","fetchPostsBtn","postList","page","perPage","posts","fetchPosts3","renderPosts","params","markup","id","title","body","userId","pagee","limit","totalPages","iziToast","fetchPosts4","renderPosts3","BASE_URL_JSONPLACEHOLDER","foo6","todo1","todo2","todo3","data","foo7","prpmisesArr","par","res","todos","arr1","arr2","arr3","todoForm","todoContainer","todoService","url","options","createTodoMarkup","array","completed","err","handlePostDataToService","event","userSTask","handlePatch","parent","handleDeletTask","API_Read_Access_Token","filmsList","END_POINT","observer","handleLoadMoreMovie","guard","pageMovie","fetchService","method","createMovieMarkup","poster_path","release_date","overview","vote_average","entries","entry","cardHeight"],"mappings":"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"}