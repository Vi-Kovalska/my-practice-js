{"version":3,"file":"index.js","sources":["../src/js/modul-12.js","../src/js/modul-11.js","../src/js/modul-10.js","../src/js/modul-9.js","../src/js/modul-8.js","../src/js/modul-7.js","../src/js/modul-6.js","../src/js/modul-5.js","../src/js/modul-4.js","../src/js/modul-3.js","../src/js/modul-2.js","../src/main.js"],"sourcesContent":["'use strict';\n// npm install axios\n\nimport axios from 'axios';\n\nimport iziToast from 'izitoast';\nimport 'izitoast/dist/css/iziToast.min.css';\n// Бібліотека Axios — це простий HTTP-клієнт, що базується на Promise і автоматизує багато рутинних завдань при роботі з HTTP-запитами, а саме дозволяє:\n\n// ⭐️Axios є зручною альтернативою стандартному Fetch API.\n// Синтаксис запиту:\n// 1)Запити можна робити, викликавши axios і передаючи відповідний об'єкт конфігурації. Напишемо код, який виконує GET-запит.\n// Після виконання функції axios ми отримуємо проміс, який обробляємо стандартними методами then і catch.\n\naxios({\n  method: 'get',\n  url: 'https://jsonplaceholder.typicode.com/users',\n})\n  .then(response => console.log(response))\n  .catch(error => console.log(error));\n// 2)or Псевдоніми методів запиту\n// У бібліотеці Axios існують псевдоніми (однойменні методи) для всіх підтримуваних методів запиту, які спрощують синтаксис запиту та додають стандартні налаштування.\n\naxios\n  .get('https://jsonplaceholder.typicode.com/users')\n  .then(response => console.log(response))\n  .catch(error => console.log(error));\n// ⭐️ метод axios.get потребує обов'язково лише адреси запиту, а метод GET автоматично підставляється сам.\n// ⭐️ Axios додає до запиту стандартні HTTP-заголовки, наприклад, Accept, у якому вказує application/json, оскільки найчастіше ми очікуємо саме JSON від сервера.\n\n//                        ⭐️Об'єкт відповіді на запит\n// {\n//   data: {},\n//   status: 200,\n//   statusText: 'OK',\n//   headers: {},\n//   config: {},\n//   request: {}\n// }\n// ⭐️data — відповідь, надана сервером;\n// status — код стану HTTP з відповіді сервера;\n// statusText — повідомлення про стан HTTP від відповіді сервера;\n// headers — заголовки HTTP, з якими відповів сервер;\n// config — конфігурація, яка була надана Axios для запиту;\n// request — запит, який створив цю відповідь;\n\n// У методі then ти отримаєш наступні властивості в об'єкті відповіді.\naxios\n  .get('https://jsonplaceholder.typicode.com/users')\n  .then(response => {\n    console.log(response.data);\n    console.log(response.status);\n    console.log(response.statusText);\n    console.log(response.headers);\n    console.log(response.config);\n  })\n  .catch(error => {\n    console.log(error);\n  });\n\n// Зверни увагу, на властивість data, у якій зберігаються дані відповіді.\n\n// ⭐️не потрібно парсити дані відповіді методом response.json().Це робиться автоматично і додається до властивості data.\n// ⭐️не потрібно перевіряти статус відповіді у властивості response.ok.Бібліотека Axios робить це автоматично і відхиляє проміс з помилкою для будь - якого невдалого HTTP - коду відповіді, включаючи 404.\n\n//                                        Конфігурація за замовчуванням\n// Можна вказати стандартні налаштування конфігурації у властивості axios.defaults, які будуть застосовані до кожного\naxios.defaults.baseURL = 'https://jsonplaceholder.typicode.com';\n\n// axios.get('/users').then().catch();\n\n// axios.get('/posts').then().catch();\n\n// axios.get('/images').then().catch();\n\n//                                                 Заголовки за замовчуванням\n// Наприклад, якщо у тебе є унікальний ключ API, який необхідно додавати до кожного запиту у вигляді HTTP-заголовка, ти можеш додати його до властивості axios.defaults.headers.common.\n\nconst myApiKey = 'secret-api-key-for-every-request';\n\naxios.defaults.headers.common['header-name'] = myApiKey;\n\n// Замість рядка \"header-name\" вказуємо потрібну назву заголовка у вигляді рядка.\n// Іншими словами, ми буквально додаємо нову властивість із ключем \"header-name\" до об'єкта axios.defaults.headers.common. Після цього Axios автоматично додасть цей заголовок із вказаним значенням до кожного запиту.\n\n//                                               Параметри рядка запиту\n// -вказати їх у URL.\n// - використати клас URLSearchParams\n// -Axios надає нам зручніший спосіб. В об'єкті конфігурації (параметр config) ти можеш вказати об'єкт параметрів у властивості params.\naxios.get('https://jsonplaceholder.typicode.com/users', {\n  params: {\n    _limit: 7,\n    _sort: 'name',\n  },\n});\n\n//                                                 Асинхронні функції\n// Синтаксис async/await — це зручний спосіб написання асинхронного коду, був доданий до стандарту ECMAScript 2017 (ES8) і став дуже популярним\n// Для оголошення асинхронної функції додається async\n// -перед ключовим словом function\nasync function fetchData() {\n  // ...\n}\n//-y функціональному виразі також перед ключовим словом function додається async.\nconst fetchData6 = async function () {\n  // ...\n};\n// -y стрілкової функції перед списком параметрів\nconst fetchData7 = async () => {\n  // ...\n};\n// -y методу об'єкта async додається перед іменем методу.\nconst user = {\n  async getUsername() {\n    // ...\n  },\n};\n// В основі async/await лежать проміси, тому він не блокує основний потік виконання програми. По суті, це сучасний спосіб роботи з промісами всередині функції, і це є альтернативою конструкції then/catch.\n\n// будь - яке значення, що повертається з функції(return), стане значенням проміса.\n// Якщо не вказувати значення для повернення, буде створений проміс зі значенням undefined.\n\n//                                                           Оператор await\n// ТІЛЬКИ всередині АСИНХРОННИХ функцій можна використовувати оператор await, розмістивши його праворуч від будь-якого виразу, який повертає проміс.\n// Коли інтерпретатор зустрічає await, він ПРИЗУПИНЯЄ ВИКОНАННЯ Ф-ЦІЇ і чекає, ДОКИ ЗАВЕРШИТЬСЯ ВИКОНАННЯ ПРОМІСУ, який  ПРАВОРУЧ від await.\n//\n// Підсумуємо:\n// ⭐️Оператор await можна використовувати тільки всередині асинхронних функцій (async).\n// ⭐️await не може використовуватись без async, але async може використовуватися без await.\n// ⭐️Оператор await призупиняє виконання функції до завершення відповідного промісу (fulfilled або rejected).\n// ⭐️Якщо проміс завершується успішно (fulfilled), оператор await повертає його значення.\n// ⭐️Якщо проміс завершується з помилкою (rejected), оператор await генерує помилку.\n// ⭐️Асинхронна функція завжди повертає проміс, отже, будь-яке значення, що повертається, стає значенням цього промісу.\n// ⭐️Якщо не вказати значення для повернення, буде створений проміс зі значенням undefined.\n\n// HTTP-запити\n// Використаємо синтаксис async/await при роботі з HTTP-запитами, щоб зробити код більш читабельним.\n// ЕХ перепишемо функцію fetchUsers, використовуючи синтаксис async/await\n// const fetchUsers = () => {\n//   axios.get('https://jsonplaceholder.typicode.com/users').then(response => {\n//     console.log(response.data);\n//   });\n// };\n//1) додаємо ключове слово async\n// 2)використовуємо оператор await, щоб зачекати завершення axios.get та отримати об'єкт відповіді у змінну response\n// 3) поверни значення результатy HTTP-запитуз асинхронної функції та оброби його в методі then, якщо потрібно використовувати в зовнішньому коді\nconst fetchUsers = async () => {\n  const response = await axios.get(\n    'https://jsonplaceholder.typicode.com/users'\n  );\n  console.log(response.data);\n  return response.data;\n};\n\nfetchUsers().then(users => console.log(users));\n\n//                                                         Конструкція try…catch\n// Конструкція try...catch — це механізм обробки винятків.Конструкція try...catch виконує код у блоці try, і якщо в цьому блоці виникає помилка (виняток), виконання коду у try зупиняється, і контроль передається до блоку catch.\n// Параметр error представляє об'єкт помилки, в якому зазвичай міститься інформація про помилку, така як повідомлення про помилку.\n\n// try {\n//   const result = 10 / 0;\n//   console.log(result); // Цей рядок не виконається через помилку\n// } catch (error) {\n//   // Обробимо помилку\n//   console.error(error.message);\n// }\n//                                              ОТЖЕ ОБРОБКА ПОМИЛОК:\n// ⭐️Якщо результат асинхронної функції (проміс) НЕ ВИКОРИСТОВУЄТЬСЯ В ЗОВН КОДІ, помилки оброблюються у самому тілі функції за допомогою конструкції ⭐️TRY...CATCH . Значення параметра error у блоці catch — це помилка, яку генерує await, якщо проміс був відхилений.\nconst fetchUsers2 = async () => {\n  try {\n    const response = await axios.get(\n      'https://jsonplaceholder.typicode.com/users'\n    );\n    console.log(response.data);\n  } catch (error) {\n    console.log(error);\n  }\n};\n//⭐️Якщо результат асинхронної функції (проміс) ВИКОРИСТОВУЄТЬСЯ В ЗОВН КОДІ, тобто за межами інших асинхронних функцій, помилки оброблюються методом CATCH() колбеку. Значення параметра error ⭐️у методі catch() — це помилка, яку генерує await, якщо проміс буде відхилений.\nconst fetchUsers3 = async () => {\n  const response = await axios.get(\n    'https://jsonplaceholder.typicode.com/users'\n  );\n  return response.data;\n};\n\nfetchUsers3()\n  .then(users => console.log(users))\n  .catch(error => console.log(error));\n//⭐️Якщо результат асинхронної функції ВИКОР В ІНШІЙ АСИНХРОННІЙ Ф-ЦІЇ, помилки оброблюються конструкцією ⭐️TRY...CATCH. Значення параметра error у блоці catch представляє помилку, яку генерує await, якщо проміс буде відхилений.\nconst fetchUsers4 = async () => {\n  const response = await axios.get(\n    'https://jsonplaceholder.typicode.com/users'\n  );\n  return response.data;\n};\n\nconst doStuff = async () => {\n  try {\n    const users = await fetchUsers4();\n    console.log(users);\n  } catch (error) {\n    console.log(error);\n  }\n};\n\ndoStuff();\n\n//                                                    Пагінація (pagination)\n//Пагінація - РОЗБИВКА НА СТОРІНКИ результату GET-запиту. Пагінація передбачає, що сервер повертає не всю колекцію, а лише певну частину записів при кожному GET-запиті. Пагінацію реалізують на сервері та використовують її на клієнтському боці завдяки спеціальним параметрам у запиті.\n// ЕХ\n// Для прикладу роботи з колекцією даних ми використовуємо публічний JSONPlaceholder API та отримуємо масив постів з ендпоінта /posts.\nconst fetchPosts = async () => {\n  const response = await axios.get(\n    'https://jsonplaceholder.typicode.com/posts'\n  );\n  console.log('Posts: ', response.data);\n};\n// 1)Перший параметр per_page -  визначає кількість елементів у відповіді від сервера.\n// _limit - параметр JSONPlaceholder API що контролює кількість елементів у відповіді\n// 2)Другий параметр пагінації page - контролює зміщення всередині колекції, тобто номер групи елементів, яку ми хочемо отримати. Якщо сервер реалізує пагінацію, то значення цього параметра за замовчуванням дорівнює одиниці — перша група або «сторінка» елементів.\n// _page - параметр у JSONPlaceholder API , що контролює групу елементів.\n// Щоб визначити, коли елементи в колекції закінчаться, і вивести користувачу повідомлення про це, сервер може повертати не тільки масив елементів, але й:\n// -метадані про доступну кількість груп, що залежить від значення параметра per_page,\n// або\n// -просто загальну кількість елементів у колекції.\n// ех\n// const fetchPostsBtn = document.querySelector('.btn-pagination');\n// const postList = document.querySelector('.posts');\n\n// fetchPostsBtn.addEventListener('click', async () => {\n//   try {\n//     const posts = await fetchPosts();\n//     renderPosts(posts);\n//   } catch (error) {\n//     console.log(error);\n//   }\n// });\n\n// async function fetchPosts() {\n//   const params = new URLSearchParams({\n//     _limit: 5,\n//     // Change the group number here\n//     _page: 3,\n//   });\n\n//   const response = await axios.get(\n//     `https://jsonplaceholder.typicode.com/posts?${params}`\n//   );\n//   return response.data;\n// }\n\n// function renderPosts(posts) {\n//   const markup = posts\n//     .map(({ id, title, body, userId }) => {\n//       return `<li>\n//           <h2 class=\"post-title\">${title.slice(0, 30)}</h2>\n//           <p><b>Post id</b>: ${id}</p>\n//           <p><b>Author id</b>: ${userId}</p>\n//           <p class=\"post-body\">${body}</p>\n//         </li>`;\n//     })\n//     .join('');\n//   postList.innerHTML = markup;\n// }\n//                                            Прийом «Завантажити ще»\n// Для динамічної зміни номера групи при кожному наступному запиті :\n// 1)Оголосимо ще одну глобальну змінну, назвемо її page і встановимо початкове значення 1 — перша група елементів.\n// 2)Після кожного успішного запиту в обробнику методу then() ми будемо збільшувати значення page на одиницю. Потім ми використовуємо це значення при складанні параметрів запиту.\nconst fetchPostsBtn = document.querySelector('.btn-pagination');\nconst postList = document.querySelector('.posts');\n\n// Controls the group number\nlet page = 1;\n// Controls the number of items in the group\nlet perPage = 10;\n\nfetchPostsBtn.addEventListener('click', async () => {\n  try {\n    const posts = await fetchPosts3();\n    renderPosts(posts);\n    // Increase the group number\n    page += 1;\n\n    // Replace button text after first request\n    if (page > 1) {\n      fetchPostsBtn.textContent = 'Fetch more posts';\n    }\n  } catch (error) {\n    console.log(error);\n  }\n});\n\nasync function fetchPosts3() {\n  const params = new URLSearchParams({\n    _limit: perPage,\n    _page: page,\n  });\n\n  const response = await axios.get(\n    `https://jsonplaceholder.typicode.com/posts?${params}`\n  );\n  return response.data;\n}\n\nfunction renderPosts(posts) {\n  const markup = posts\n    .map(({ id, title, body, userId }) => {\n      return `<li>\n          <h2 class=\"post-title\">${title.slice(0, 30)}</h2>\n          <p><b>Post id</b>: ${id}</p>\n          <p><b>Author id</b>: ${userId}</p>\n          <p class=\"post-body\">${body}</p>\n        </li>`;\n    })\n    .join('');\n  postList.insertAdjacentHTML('beforeend', markup);\n}\n//                                           Перевірка кінця колекції\n// Відсутність постів для завантаження під час кліку на кнопку \"Fetch posts\" означає, що користувач досяг кінця колекції. Коли це трапляється, необхідно відобразити сповіщення.\n// Для цього ми використовуємо бібліотеку iziToast.\n// ЕХ  додали перевірку кінця колекції на фронтенді, оскільки JSONPlaceholder API не реалізує цей функціонал на бекенді. У нашому випадку достатньо розділити загальну кількість елементів у колекції (100) на кількість елементів в одній групі.\n// Контролює кількість елементів в групі\n// let limit = 30;\n// // Кількість груп в колекції\n// const totalPages = Math.ceil(100 / limit);\n// //\n// // Перед кожним наступним запитом ми порівнюємо поточний номер групи і загальну кількість груп і виводимо сповіщення, не виконуючи HTTP-запиту.\n// if (page > totalPages) {\n//   return iziToast.error({\n//     position: 'topRight',\n//     message: \"We're sorry, there are no more posts to load\",\n//   });\n// }\n// ЕХ\n// const fetchPostsBtn = document.querySelector('.btn');\n// const postList = document.querySelector('.posts');\n\n// Controls the group number\nlet pagee = 1;\n// Controls the number of items in the group\nlet limit = 40;\n// In our case total number of pages is calculated on frontend\nconst totalPages = Math.ceil(100 / limit);\n\nfetchPostsBtn.addEventListener('click', async () => {\n  // Check the end of the collection to display an alert\n  if (pagee > totalPages) {\n    return iziToast.error({\n      position: 'topRight',\n      message: \"We're sorry, there are no more posts to load\",\n    });\n  }\n\n  try {\n    const posts = await fetchPosts4();\n    renderPosts3(posts);\n    // Increase the group number\n    pagee += 1;\n\n    // Replace button text after first request\n    if (pagee > 1) {\n      fetchPostsBtn.textContent = 'Fetch more posts';\n    }\n  } catch (error) {\n    console.log(error);\n  }\n});\n\nasync function fetchPosts4() {\n  const params = new URLSearchParams({\n    _limit: limit,\n    _page: pagee,\n  });\n\n  const response = await axios.get(\n    `https://jsonplaceholder.typicode.com/posts?${params}`\n  );\n  return response.data;\n}\n\nfunction renderPosts3(posts) {\n  const markup = posts\n    .map(({ id, title, body, userId }) => {\n      return `<li>\n          <h2 class=\"post-title\">${title.slice(0, 30)}</h2>\n          <p><b>Post id</b>: ${id}</p>\n          <p><b>Author id</b>: ${userId}</p>\n          <p class=\"post-body\">${body}</p>\n        </li>`;\n    })\n    .join('');\n  postList.insertAdjacentHTML('beforeend', markup);\n}\n//\n//                                           partial of url\n// https://example.com/over/there?name=ferret\n// - PROTOCOL https://\n// - HOST example.com\n// - PATH TO RESOURCE /over/there\n// - PARAMETERS ?name=ferret\n//                                                     Lection\n// ❌ex у цьому коді відбудеться 3 послідовні запроси на сервер за різними ДИНАМІЧНИМИ параметрами , і витратиться час (див вкладку Network), можна оптимізувати це\nconst BASE_URL_JSONPLACEHOLDER = 'https://jsonplaceholder.typicode.com';\n\nasync function foo6() {\n  const todo1 = await axios(`${BASE_URL_JSONPLACEHOLDER}/users/1/todos`);\n  const todo2 = await axios(`${BASE_URL_JSONPLACEHOLDER}/users/2/todos`);\n  const todo3 = await axios(`${BASE_URL_JSONPLACEHOLDER}/users/3/todos`);\n\n  return [todo1, todo2, todo3];\n}\n\nfoo6()\n  .then(data => console.log(data))\n  .catch(error => console.log(error));\n// ✅REFACTORING\n//refactoring the previous code - move dinamic parametr by url in array and iterating his with the method .map(). Results [promises] to proccessed with the method Promise.all([promises])\nasync function foo7() {\n  const dinamicParams = [1, 2, 3];\n\n  const prpmisesArr = dinamicParams.map(async par => {\n    const res = await axios(`${BASE_URL_JSONPLACEHOLDER}/users/${par}/todos`);\n    console.log(res.data);\n\n    return res.data;\n  });\n\n  const todos = await Promise.all(prpmisesArr);\n  console.log(todos);\n\n  return todos;\n}\n\nfoo7()\n  .then(data => {\n    const [arr1, arr2, arr3] = data;\n    console.log(arr1);\n  })\n  .catch(error => console.log(error));\n\n//  .......................................the start of EX\nconst todoForm = document.querySelector('.todoForm');\nconst todoContainer = document.querySelector('.todoList');\ntodoForm.addEventListener('click', handleServise);\nfunction handleServise(event) {\n  if (event.target.nodeName !== 'BUTTON') {\n    return;\n  }\n  fetch('https://dummyjson.com/todos/random')\n    .then(res => {\n      res.json();\n    })\n    .then(data => {\n      console.log(data);\n\n      todoContainer.insertAdjacentHTML('beforeend', createTodoMarkup([data]));\n      // localStorage.setItem('taskObj', JSON.stringify(data));\n    })\n    .catch(error => {\n      return iziToast.error({\n        position: 'topRight',\n        message: `Sorry, we are have a problem...${error.message}`,\n        displayMode: 1,\n      });\n    });\n}\n\nfunction createTodoMarkup(array) {\n  return array\n    .map(\n      ({ userId, todo, completed }) => `\n  <li class='todoCard' data-id='${userId}'>\n  <input type='checkbox' class='todoCheckbox' ${completed ? 'checked' : ''}/>\n  <h2 class='todoTitle'>${todo}</h2>\n  <button class='todoBtnDel'>X</button>\n  </li>`\n    )\n    .join('');\n}\n\ntodoForm.addEventListener('submit', handlePostDataToService);\n// функція робить запит на сервер (створює) отже вона АСИНХРОННА\nfunction handlePostDataToService(event) {\n  event.preventDefault();\n  const userSTask = event.target.elements.todo.value;\n\n  if (!userSTask.trim()) {\n    return;\n  }\n  // запит на сервер - трай кетч\n  fetch('https://dummyjson.com/todos/add', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      todo: userSTask,\n      completed: false,\n      userId: 4,\n    }),\n  })\n    .then(res => {\n      res.json();\n    })\n    .then(data => {\n      console.log(data);\n\n      todoContainer.insertAdjacentHTML('beforeend', createTodoMarkup([data]));\n    })\n    .catch(err => {\n      return iziToast.error({\n        position: 'topRight',\n        message: `Sorry...${err.message}`,\n        displayMode: 1,\n      });\n    })\n    .finally(() => event.target.reset());\n}\n\n// оновляємо дані якщо відмітили чексбокс\ntodoContainer.addEventListener('click', handlePatch);\nasync function handlePatch(event) {\n  if (!event.target.classList.contains('todoCheckbox')) {\n    console.log('ops it is not a checkbox!');\n    return;\n  }\n  // щоб чекбкс не змінювався без зміни даних на сервері\n  event.preventDefault();\n  // найближчий батьківський елемент івент таргета , отримуємо айді для серверного запросу\n  const parent = event.target.closest('.todoCard');\n  console.log(parent);\n  const id = parent.dataset.id;\n  console.log(id);\n  // запит на сервер - трай кетч\n  console.log(event.target.checked);\n\n  fetch(`https://dummyjson.com/todos/${id}`, {\n    method: 'PATCH',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      completed: event.target.checked,\n      userId: id,\n    }),\n  })\n    .then(res => {\n      res.json();\n    })\n    .then(data => {\n      console.log(data);\n      event.target.checked = data.completed || !event.target.checked;\n    })\n    .catch(error => {\n      return iziToast.error({\n        position: 'topRight',\n        message: `Sorry...${error.message}`,\n        displayMode: 1,\n      });\n    });\n}\n\n// 1.делегування подій на списку справ 2.отримуємо id елемента лішки по якій клікнули 3.звертаємось до сервера і видаляємо дані за id\ntodoContainer.addEventListener('click', handleDeletTask);\nfunction handleDeletTask(event) {\n  if (!event.target.classList.contains('todoBtnDel')) {\n    return;\n  }\n\n  const parent = event.target.closest('.todoCard');\n  const id = parent.dataset.id;\n  parent.remove();\n  fetch(`https://dummyjson.com/todos/${id}`, {\n    method: 'DELETE',\n  }).then(res => {\n    // if (!res.ok) {\n    //   throw new Error(response.statusText);\n    // }\n    res.json();\n  }),\n    then().catch(error => {\n      return iziToast.error({\n        position: 'topRight',\n        message: `Sorry...${error.message}`,\n        displayMode: 1,\n      });\n    });\n}\n// ......................................................the end of EX\n// ..................................the start of EX the film's library\n// create the film's library with popular movie . use https://developer.themoviedb.org/reference/trending-movies\n// API_KEY put in params => headers.Authorozation: 'Bearer ${KEY}'\nconst API_Read_Access_Token =\n  'eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJhMWIxNTk0NzI5ZDlhODRlZjZkZTU2MmRiMjJiOTRkZSIsIm5iZiI6MTczNDUzMDE1Ny43ODIsInN1YiI6IjY3NjJkNDZkMTYxYWI3ZGVjNWZmZTgzMiIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.n11YprEyAIsNVgOqkidenCI4yQs_Y4WRKkJJKM74lkc';\n// put base url + dinamic url from object by service that getting the film's POSTER\n// 1)CREATE MARKUP WITH THE FILM'S CARD\n// 2)implement pagination:\n// 1 the button \"Load More\"\n// 2 INFINITY SCROLL ('https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API')\nconst filmsList = document.querySelector('.jsMovieList');\nconst loadMoreBTN = document.querySelector('.jsLoadMore');\nconst BASE_URL_MOVIE = 'https://api.themoviedb.org/3';\nconst END_POINT = '/trending/movie/week';\nconst MY_MOVIE_API_KEY = 'a1b1594729d9a84ef6de562db22b94de';\n\n// let pageMovie = 1;\n\n// async function fetchService(method, pageMovie) {\n//   const options = {\n//     method,\n//     headers: {\n//       accept: 'application/json',\n//       Authorization: `Bearer ${API_Read_Access_Token}`,\n//     },\n//   };\n//   const params = new URLSearchParams({\n//     page: `${pageMovie}`,\n//   });\n\n//   const response = await fetch(\n//     `https://api.themoviedb.org/3${END_POINT}?${params}`,\n//     options\n//   );\n\n//   return response.json();\n// }\n// fetchService('GET', pageMovie)\n//   .then(res => {\n//     console.log(res);\n\n//     filmsList.insertAdjacentHTML('beforeend', createMovieMarkup(res.results));\n//     if (res.page < res.total_pages) {\n//       loadMoreBTN.classList.replace('loadMoreHidden', 'loadMoreVisible');\n//     }\n//   })\n//   .catch(err => {\n//     return iziToast.error({\n//       position: 'topRight',\n//       message: `Sorry...${err.message}`,\n//       displayMode: 1,\n//     });\n//   });\n\n// function createMovieMarkup(array) {\n//   return array.map(\n//     ({\n//       poster_path,\n//       id,\n//       title,\n//       release_date,\n//       overview,\n//       vote_average,\n//     }) => `<li class='movieCard' data-id='${id}'>\n//     <div class='posterContainer'>\n// <a href=\"#\"><img class='moviePoster' src=\"https://image.tmdb.org/t/p/w300${poster_path}\" alt=\"${overview}\" ></a>\n// </div>\n// <div class=\"movieInfo\">\n//   <h2>${title}</h2>\n//   <p>${overview.slice(0, 350)}</p>\n// <p>The vote average: ${vote_average}</p>\n// <p>The release date: ${release_date}</p>\n// </div>\n// </li>`\n//   );\n// }\n// loadMoreBTN.addEventListener('click', handleLoadMoreMovie);\n// async function handleLoadMoreMovie(event) {\n//   pageMovie += 1;\n//   loadMoreBTN.disabled = true;\n//   fetchService('GET', pageMovie)\n//     .then(res => {\n//       filmsList.insertAdjacentHTML('beforeend', createMovieMarkup(res.results));\n//       if (res.page >= res.total_pages) {\n//         loadMoreBTN.classList.replace('loadMoreVisible', 'loadMoreHidden');\n//       }\n//       const cardMovie = document.querySelector('.movieCard');\n//       const cardHeight = cardMovie.getBoundingClientRect().height;\n//       window.scrollBy({\n//         left: 0,\n//         top: cardHeight * 2,\n//         behavior: 'smooth',\n//       });\n//     })\n//     .catch(err => {\n//       return iziToast.error({\n//         position: 'topRight',\n//         message: `Sorry...${err.message}`,\n//         displayMode: 1,\n//       });\n//     })\n//     .finally(() => (loadMoreBTN.disabled = false));\n// }\n\n//                               той самий код але замість кнопки INFINITY SCROLL\n// Intersection Observer API дозволяє коду реєструвати функцію зворотного виклику, яка виконується щоразу, коли певний елемент входить або виходить із перетину з іншим елементом (або вікном перегляду ), або коли перетин між двома елементами змінюється на вказану величину. Таким чином, сайтам більше не потрібно нічого робити в основному потоці, щоб спостерігати за таким перетином елементів, а браузер може вільно оптимізувати керування перетинаннями, як вважає за потрібне.\n\n// Одного не може зробити Intersection Observer API: запускати логіку на основі точної кількості пікселів, які перекриваються, або конкретно на тому, які з них є. Це вирішує лише поширений випадок використання: «Якщо вони перетинаються десь приблизно на N %, мені потрібно щось зробити».\n// Щоб спостерігати за перетином відносно вікна перегляду пристрою, вкажіть nullопцію root.\n// Створіть спостерігач перетину, викликавши його конструктор і передавши йому функцію зворотного виклику, яка буде запускатися щоразу, коли поріг перетинається в одному або іншому напрямку:\nconst options = {\n  root: null,\n  rootMargin: '300px',\n  // Порогове значення 1,0 означає, що коли 100% цілі видно в елементі, визначеному параметром root, викликається зворотний виклик.\n  threshold: 1.0,\n};\nconst observer = new IntersectionObserver(handleLoadMoreMovie, options);\nconst guard = document.querySelector('.jsGuard');\nlet pageMovie = 1;\n\nasync function fetchService(method, pageMovie) {\n  const options = {\n    method,\n    headers: {\n      accept: 'application/json',\n      Authorization: `Bearer ${API_Read_Access_Token}`,\n    },\n  };\n  const params = new URLSearchParams({\n    page: `${pageMovie}`,\n  });\n\n  const response = await fetch(\n    `https://api.themoviedb.org/3${END_POINT}?${params}`,\n    options\n  );\n\n  return response.json();\n}\nfetchService('GET', pageMovie)\n  .then(res => {\n    console.log(res);\n\n    filmsList.insertAdjacentHTML('beforeend', createMovieMarkup(res.results));\n    if (res.page < res.total_pages) {\n      observer.observe(guard);\n    }\n  })\n  .catch(err => {\n    return iziToast.error({\n      position: 'topRight',\n      message: `Sorry...${err.message}`,\n      displayMode: 1,\n    });\n  });\n\nfunction createMovieMarkup(array) {\n  return array\n    .map(\n      ({\n        poster_path,\n        id,\n        title,\n        release_date,\n        overview,\n        vote_average,\n      }) => `<li class='movieCard' data-id='${id}'>\n    <div class='posterContainer'>\n<a href=\"#\"><img class='moviePoster' src=\"https://image.tmdb.org/t/p/w300${poster_path}\" alt=\"${overview}\" ></a>\n</div>\n<div class=\"movieInfo\">\n  <h2>${title}</h2>\n  <p>${overview.slice(0, 350)}</p>\n<p>The vote average: ${vote_average}</p>\n<p>The release date: ${release_date}</p>\n</div>\n</li>`\n    )\n    .join('');\n}\n// функція автоматично відпрацьовує один раз як загружається сторінка, щоб вона відпрацьовувала тільки під час перетинання window - додаємо перевірку із документації\nasync function handleLoadMoreMovie(entries, observer) {\n  entries.forEach(entry => {\n    if (entry.intersectionRatio) {\n      pageMovie += 1;\n      fetchService('GET', pageMovie)\n        .then(res => {\n          filmsList.insertAdjacentHTML(\n            'beforeend',\n            createMovieMarkup(res.results)\n          );\n          // припинити слідкувати за гуард (або entry.target) якщо остання сторінка\n          if (res.page >= res.total_pages) {\n            observer.unobserve(guard);\n          }\n          const cardMovie = document.querySelector('.movieCard');\n          const cardHeight = cardMovie.getBoundingClientRect().height;\n          window.scrollBy({\n            left: 0,\n            top: cardHeight * 2,\n            behavior: 'smooth',\n          });\n        })\n        .catch(err => {\n          return iziToast.error({\n            position: 'topRight',\n            message: `Sorry...${err.message}`,\n            displayMode: 1,\n          });\n        });\n    }\n  });\n\n  // .finally(() => (loadMoreBTN.disabled = false));\n}\n","// 'use strict';\n\n// // // Повідомлення, надіслані клієнтом, називаються запитами, а повідомлення, надіслані сервером як відповідь, називаються відповідями.\n// // //     HTTP — це клієнт - серверний протокол: запити надсилаються однією сутністю, агентом користувача(або проксі - сервером від його імені).У більшості випадків агентом користувача є веб - браузер, але це може бути що завгодно, наприклад, робот, який сканує Інтернет, щоб заповнити та підтримувати індекс пошукової системи.\n// // // Кожен окремий запит надсилається на сервер, який обробляє його та надає відповідь, яка називається відповіддю.Між клієнтом і сервером є численні об’єкти, які разом називаються проксі - серверами, які виконують різні операції та діють, наприклад, як шлюзи або кеші.\n// // // Client: the user-agent\n// // // Агент користувача - це будь-який інструмент, який діє від імені користувача. Цю роль в основному виконує веб-браузер, але її також можуть виконувати програми, які використовуються інженерами та веб-розробниками для налагодження своїх програм.\n\n// // // Браузер завжди ініціює запит.Це ніколи не сервер\n\n// // // Щоб відобразити веб-сторінку, браузер надсилає оригінальний запит для отримання HTML-документа, який представляє сторінку. Потім він аналізує цей файл, роблячи додаткові запити, що відповідають сценаріям виконання, інформації про макет (CSS) для відображення та підресурсів, що містяться на сторінці (зазвичай зображення та відео). Потім веб-браузер поєднує ці ресурси, щоб представити повний документ, веб-сторінку. Сценарії, які виконує браузер, можуть отримати більше ресурсів на наступних етапах, і браузер відповідно оновлює веб-сторінку.\n\n// // //     Веб - сторінка — це гіпертекстовий документ.Це означає, що деякі частини відображуваного вмісту є посиланнями, які можна активувати(зазвичай клацанням миші) для отримання нової веб - сторінки, дозволяючи користувачеві керувати своїм агентом користувача та переходити в Інтернеті.Браузер перетворює ці вказівки в HTTP - запити, а потім інтерпретує відповіді HTTP, щоб надати користувачеві чітку відповідь.\n// // // Веб-сервер Web server\n// // // На протилежній стороні каналу зв'язку знаходиться сервер, який обслуговує документ за запитом клієнта. Сервер віртуально виглядає лише як одна машина; але насправді це може бути сукупність серверів, які розподіляють навантаження (балансування навантаження), або інше програмне забезпечення (таке як кеш-пам’ять, сервер бази даних або сервери електронної комерції), яке повністю або частково генерує документ на вимогу.\n// // // Проксі\n// // // Між веб-браузером і сервером багато комп’ютерів і машин передають HTTP-повідомлення. Завдяки багаторівневій структурі веб-стеку більшість із них працюють на транспортному, мережевому або фізичному рівнях, стаючи прозорими на рівні HTTP та потенційно маючи значний вплив на продуктивність. Ті, що працюють на прикладних рівнях, зазвичай називаються проксі . Вони можуть бути прозорими, пересилаючи отримані запити, не змінюючи їх жодним чином, або непрозорими, у цьому випадку вони певним чином змінять запит перед тим, як передати його на сервер. Проксі можуть виконувати численні функції:\n\n// // // кешування (кеш може бути публічним або приватним, як кеш браузера)\n// // // фільтрація (наприклад, антивірусне сканування або батьківський контроль)\n// // // балансування навантаження (щоб дозволити кільком серверам обслуговувати різні запити)\n// // // аутентифікація (для контролю доступу до різних ресурсів)\n// // // журналювання (що дозволяє зберігати історичну інформацію)\n\n// // //                                                                     HTTP\n// // // HyperText Transfer Protocol (протокол передачі гіпертексту) — поширений протокол для передачі вебресурсів різних типів: html, css, javascript, зображень, аудіо та відео тощо.\n// // HTTP ґрунтується на структурі клієнт-сервер і моделі запит-відповідь.\n\n// // Як це працює?\n// // 1) Клієнтський застосунок ініціює з'єднання, формує запит і відправляє його на сервер.\n// // 2) сервер обробляє цей запит, формує відповідь і передає її назад клієнтові.\n// // 3) Зв'язок між ними здійснюється за допомогою низки перемежованих HTTP-запитів і HTTP-відповідей.\n\n// //     Запит відбувається в кілька етапів:\n// // 1) DNS-запит — пошук найближчого DNS-сервера, щоб перетворити адресу (наприклад google.com) в її числове вираження, IP-адресу (74.125.87.99).\n// // 2) З'єднання — встановлення з'єднання з сервером за отриманою IP-адресою.\n// // 3) Передача даних — пересилання пакетів з клієнта на сервер.\n// // 4) Очікування відповіді — очікування, доки пакети даних дійдуть до сервера, він їх обробить, і відповідь повернеться назад до клієнта.\n// // 5) Отримання даних — пакети надійшли, можна отримувати з них дані.\n\n// // //                                                                     Протокол HTTPS\n// // HyperText Transfer Protocol Secure — це налаштування над протоколом HTTP, у якому всі повідомлення між клієнтом і сервером шифруються з метою підвищення безпеки.\n\n// // HTTPS протокол забезпечує захист від атак, що базуються на “прослуховуванні” з'єднання. Дані передаються з використанням криптографічних протоколів SSL або TLS.\n\n// // Під час обміну через звичайне HTTP - з'єднання всі дані передаються у вигляді тексту і можуть бути прочитані всіма, хто отримав доступ до з'єднання між клієнтом і сервером.\n\n// // Протокол HTTPS гарантує, що інформація про клієнта, наприклад номери кредитних карток, зашифрована і не може бути перехоплена в розшифрованому вигляді.Відвідувачі можуть переконатися, що сайт безпечний, подивившись на іконку зліва від адресного рядка, захищені з'єднання позначаються іконкою замка.\n\n// // //                                                                        HTTP-запити\n//  API (application programming interface, интерфейс программирования приложения) - набір чітко визначених правил зв'язку між різними програмними компонентами. Інтерфейс описує, що можна попросити програму зробити і що буде в результаті.\n\n// REST (representational state transfer) — стиль бекенд-архітектури. Він ґрунтується на наборі принципів, які описують, яким чином визначаються й адресуються мережеві ресурси.\n\n// REST API — бекенд побудований за принципом REST. Слугує прошарком між вебзастосунком і базою даних. Має стандартний інтерфейс для звернення до ресурсів. Працює як вебсайт, ми посилаємо HTTP-запит із клієнта на сервер, а у відповідь, замість HTML-сторінки, отримуємо дані в JSON-форматі.\n\n// Існують тисячі бекендів, і кожен з них унікальний.З іншого боку, REST API побудовані за стандартною архітектурою.Отже, можна зрозуміти принцип їх роботи, після чого все, що потрібно зробити — це ознайомитися з документацією того бекенду, який необхідно\n\n//                                                            Шлях до ресурсу\n\n// Запити на бекенд повинні містити шлях до ресурсу, над яким виконується операція. Доступні шляхи (ендпоінти, ресурси) описуються в документації бекенду.\n\n//     Endpoints(Ендпоінти) в контексті вебсервісів та API —  конкретні URL - адреси, через які можна отримати доступ до певних функцій або ресурсів сервера.Tочка входу для взаємодії між клієнтом і сервером, дозволяючи отримувати, надсилати, оновлювати чи видаляти дані.\n//                                                                JSONPlaceholder API\n// це публічний REST API для швидкого прототипування, який надає кілька різних колекцій уявних даних.\n// https://jsonplaceholder.typicode.com/users\n// Цей шлях складається з таких частин:\n// https://jsonplaceholder.typicode.com — це базовий URL, точка входу в API.\n// /users — ресурс, до якого звертаємося.\n\n// //                                                                Fetch API\n// Fetch API —  інтерфейс, який вбудований у браузер і доступний через об'єкт window. Він надає набір властивостей і методів, які дозволяють відправляти, отримувати та обробляти ресурси із сервера.\n\n// Метод fetch() - сучасний інтерфейс для формування запитів до сервера і побудований на промісах. Метод fetch ПОВЕРТАЭ ПРОМІС, тому до результату його виклику додаємо ланцюжок методів then() і catch() для обробки відповіді.\n\n//     fetch(url, options)\n// url — шлях до даних на бекенді, які необхідно отримати, створити або змінити. Обов'язковий аргумент.\n// options — об'єкт налаштувань запиту: метод, заголовки, тіло тощо. Необов'язковий аргумент.\n\n// ЕХ робимо запит до вебсервісу, щоб отримати колекцію користувачів (ресурс /users).\n// fetch('https://jsonplaceholder.typicode.com/users')\n//   .then(response => {\n//     // Response handling\n//   })\n//   .then(data => {\n//     // Data handling\n//   })\n//   .catch(error => {\n//     // Error handling\n//   });\n// //                                                                 Вкладка Network\n// В інструментах розробника на вкладці Network(Мережа) відображаються всі HTTP - запити, що виконуються на сторінці.\n// Як це зробити?\n// Вибери фільтр асинхронні HTTP/HTTPS-запити, зроблені за допомогою Fetch API або XMLHttpRequest, XHR або Fetch/XHR — так залишаться тільки асинхронні HTTP/HTTPS-запити, зроблені за допомогою Fetch API або XMLHttpRequest.\n// Після запуску скрипта з викликом методу fetch, через деякий час запит відобразиться у списку.\n// Вибери цей запит, щоб подивитися всю інформацію по ньому на підвкладках\n//     - Headers(Заголовки),\n//     -Preview(Попередній перегляд)\n//     - Response(Відповідь).\n//                                                                           Коди відповідей\n\n// На запит клієнта сервер відправляє відповідь, яка містить код стану, щоб інформувати клієнта про результат операції.\n\n// Код відповіді можна подивитися на вкладці Network у полі Status Code.\n// Коди діляться на групи (з якої цифри починається код помилки):\n// 1XX — мають інформаційне призначення.\n// 2XX — коди успішного проведення операції.\n// 3XX — описують усе, що пов'язано з перенаправленням (redirect).\n// 4XX — вказують на помилки з боку клієнта.\n// 5XX — вказують на помилки з боку сервера.\n\n// Достатньо знатинайпоширеніші коди з кожної групи. Решту  можна подивитися в довіднику HTTP-кодів (https://httpstatuses.com/).\n// 200 (OK) — стандартна відповідь для успішних HTTP-запитів.\n// 201 (Created) — стандартна відповідь для HTTP-запиту, який привів до успішного створення ресурсу.\n// 400 (Bad Request) — запит не може бути оброблений через неправильний синтаксис запиту або іншу помилку клієнта.\n// 401 (Unauthorized) — для доступу до ресурсу вимагається авторизація.\n// 403 (Forbidden) — у клієнта немає дозволу на доступ до цього ресурсу.\n// 404 (Not Found) — у цей час ресурс не знайдений. Можливо, він був видалений або ще не існує.\n// 500 (Internal Server Error) — загальна відповідь на непередбачений збій сервера, якщо відсутня конкретніша інформація.\n\n//                                                               Class Response\n// Метод fetch() поверта проміс значення якого —  об'єкт зі службовою інформацією про стан відповіді сервера. Цей об’єкт є ЕКЗЕМПЛЯРОМ КЛАСУ Response, який включає різні методи та властивості. Щоб перетворити тіло відповіді у дані використовують вбудовані методи (залежно від типу отримуваного контенту):\n//      - json() — парсить дані у JSON-форматі.\n//      - text() — парсить дані у простому текстовому форматі, наприклад .csv (табличні дані).\n//      - blob() — парсить дані, що описують файл, наприклад, зображення, аудіо або відео.\n// ех перший then() - перевірка статусу відповіді й ПЕРЕТВОРЕННЯ ДАННИХ У ПРАВИЛЬНИЙ (парсинг) у разі успішного результату або явне створення помилки, щоб обробити невдалий HTTP-запит у методі catch().\nfetch('https://jsonplaceholder.typicode.com/users')\n  .then(response => {\n    if (!response.ok) {\n      throw new Error(response.status);\n    }\n    return response.json();\n  })\n  .then(data => {\n    // Data handling\n    console.log(data);\n  })\n  .catch(error => {\n    // Error handling\n    console.log(error);\n  });\n\n//                                                      HTTP-методи\n//  HTTP-методів для роботи з REST-сервісом:\n// POST — створити новий ресурс.\n// GET — отримати набір ресурсів або один ресурс.\n// PUT — оновити існуючий або створити новий ресурс.\n// PATCH — оновити існуючий ресурс.\n// DELETE — видалити ресурс.\n\n//  вказати HTTP - метод необхідно в другий аргумент методу fetch(об'єкт налаштувань запиту). У його властивості method необхідно передати рядок, що описує HTTP-метод.\nconst options69 = {\n  method: 'GET',\n};\n\nfetch('https://jsonplaceholder.typicode.com/users', options69)\n  .then(response => {\n    if (!response.ok) {\n      throw new Error(response.status);\n    }\n    return response.json();\n  })\n  .then(data => {\n    // Data handling\n  })\n  .catch(error => {\n    // Error handling\n  });\n\n//   !!!!!!!!!!!GET-запит вказувати  в опціях fetch не потрібно, це метод запиту ЗА ЗАМОВЧУВАННЯМ.\n// Список можливих методів для кожного ресурсу описується в документації самого бекенда.\n\n//                                                               HTTP-заголовки (HEADERS in Network)\n// Заголовки містять службову інформацію, що стосується запиту або відповіді. Заголовок складається з імені та значення, наприклад:\n\n// - заголовок Accept визначає ТИП КОНТЕНТУ, який клієнт може прийняти та правильно обробити у відповіді від сервера ;\n// - заголовок Content-Type описує ТИП РЕСУРСУ в запиті або відповіді, щоб отримувач знав, як правильно ці дані інтерпретувати.\n// Accept: text/html\n// Content - Type: application / json\n\n// Значення заголовка — це MIME-тип (тип контенту), який використовується для вказівки типу контенту запиту чи відповіді і складається з типу і підтипу, розділених косою рискою (/).\n// - text/html - текстовий файл, який містить HTML\n// - text/css - текстовий файл містить CSS\n// - application/json - дані у форматі JSON\n\n// Всі заголовки ВІДПОВІДІ в секції Response Headers, а заголовки ЗАПИТУ — в секції Request Headers.\n\n// Для складання заголовків запиту використовують літерал об'єкта з властивостями, де кожен заголовок і його значення описується окремою властивістю. Усе це описується в об'єкті налаштувань методу fetch у властивості headers.\n// fetch('url', {\n//   headers: {\n//     'Content-Type': 'application/json',\n//     'X-Custom-Header': 'custom value',\n//   },\n// });\n// Наприклад, якщо ми хочемо явно вказати, що у відповіді від бекенда ми очікуємо тільки JSON, то для цього додаємо заголовок Accept зі значенням application/json.\nfetch('https://jsonplaceholder.typicode.com/users', {\n  headers: {\n    Accept: 'application/json',\n  },\n}).then(response => {\n  // ...\n});\n\n// Сучасні браузери додають багато заголовків за замовчуванням, тому немає потреби явно вказувати СТАНДАРТІ ЗАГОЛОВКИ:\n//   - User-Agent: Ідентифікує клієнтське програмне забезпечення, яке виконує запит.\n//   - Accept: Вказує, які типи медіа клієнт може обробляти.\n//   - Content-Type: Вказує тип контенту в тілі запиту або відповіді.\n//   - Authorization: Використовується для передачі облікових даних для аутентифікації.\n//   - Cache-Control: Директиви для керування кешуванням.\n//   - Host: Доменне ім'я ресурсу, до якого виконується запит.\n\n//                                           Кросдоменні запити Cross-Origin Resource Sharing (CORS)\n// CORS - політика браузерів, «спільне використання ресурсів між різними джерелами», де Origin — це і є домен, порт або протокол.\n//  ЗА ЗАМОВЧУВАННЯМ HTTP - запит МОЖНА РОБИТИ ТІЛЬКИ В РАМКАХ ПОТОЧНОГО САЙТУ.При спробі запиту на інший домен, порт або протокол(тобто при спробі виконати кросдоменний запит), браузер видає помилку.Це зроблено з міркувань безпеки, і права доступу налаштовуються на бекенді.Якщо бекенд не підтримує кросдоменні запити, фронтенд - розробник нічого не зможе з цим зробити у своєму коді.\n\n//  На кожному запиті браузер сам додає HTTP-заголовок Origin, де вказує адресу вебсторінки, яка хоче зробити HTTP-запит. Наприклад, якщо ми робимо fetch-запит із вебсторінки https://my-site.com/about на https://my-api.com/users, то заголовки будуть наступними:\n// GET /users\n// Host: my-api.com\n// Origin: https://my-site.com\n\n//                      HTTP-заголовок Access-Control-Allow-Origin\n// Сервер перевіряє заголовок Origin і, якщо він(САЙТ З ЯКОГО РОБЛЯТЬ ЗАПИТ) підтримує кросдоменні запити, додає у відповідь спеціальний HTTP - заголовок Access - Control - Allow - Origin.\n// Заголовок Access - Control - Allow - Origin ВИЗНАЧАЄ ДОЗВОЛЕНІ ДЖЕРЕЛА, які мають право отримувати відповідь на кросдоменні запити.Для приватного бекенду значенням цього заголовку буде https://my-site.com, а ДЛЯ ПУБЛІЧНОГО — СПЕЦСИМВОЛ *, що дозволяє доступ для всіх:\n// # Private API\n// Access-Control-Allow-Origin: <https://my-site.com>\n\n// # Public API\n// Access-Control-Allow-Origin: *\n\n// Отже, БРАУЗЕР - ЦЕ ПОСЕРЕДНИК між JavaScript-кодом і бекендом. Він додає кожному запиту заголовок Origin з правильним значенням і перевіряє наявність заголовка Access-Control-Allow-Origin у відповіді. Якщо заголовок є і його значення підходить, виконається оригінальний запит і JavaScript-код отримає його результат, в іншому випадку буде помилка CORS.\n\n//                                                                         AJAX\n// AJAX (Asynchronous JavaScript and XML) — метод отримання або відправлення даних з подальшим оновленням інтерфейсу за цими даними, БЕЗ ПОТРЕБИ ПЕРЕЗАВАНТАЖЕННЯ СТОРІНКИ. Завдяки цьому зменшується час відгуку і вебсторінка стає інтерактивнішою.\n\n// в назві технології присутній XML, у сучасному інтернеті його замінив JSON, а назву залишили як данину пам'яті. AJAX трактується як будь-яке спілкування з сервером без перезавантаження сторінки.\n//  процес можна розібрати на прикладі завантаження даних.\n// 1) На вебсторінці відбувається подія (сторінка завантажується, натискається кнопка “Показати більше”, відправляється форма тощо).\n// 2) На клієнті за допомогою JavaScript реакцією на цю подію буде виконуватися функція для роботи з сервером, де створюється і відправляється HTTP-запит.\n// 3) Сервер отримує й обробляє HTTP-запит, відправляючи назад у відповіді дані у форматі JSON.\n// 4) На клієнті за допомогою JavaScript відповідь від сервера обробляється, зчитуються дані і оновлюється інтерфейс.\n\n// ех Оновлення інтерфейсу\n// за допомогою точки доступу до даних серверу JSONPlaceholder API отримуємо масив користувачів за допомогою методу fetch і відтворюємо його в інтерфейсі (на сторінці).\n// 1) При кліку на кнопку Fetch users виконуємо HTTP-запит, використовуючи вже знайомий нам метод fetch.\n// у першому then -перевірка статусу відповіді й ПЕРЕТВОРЕННЯ ДАННИХ У ПРАВИЛЬНИЙ (парсинг). У другому then отримуємо доступ до даних відповіді від бекенда. Саме тут можна використати ці дані й оновити інтерфейс, створити HTML-розмітку і додати її в DOM у якийсь уже наявний елемент.\n// 2)створення HTML-розмітки можна використовувати будь-який зручний спосіб, наприклад createElement або insertAdjacentHTML. Розглянемо одну зі стандартних технік.\n// - Перебираємо масив об'єктів методом .map().\n// - На кожній ітерації повертаємо HTML-розмітку для одного елемента колекції.\n// - Результуючий масив рядків зшиваємо в один рядок методом .join(\"\").\n// - Додаємо рядок з HTML-розміткою в DOM методом .insertAdjacentHTML().\nconst fetchUsersBtn = document.querySelector('.btn-for-ajax');\nconst userList = document.querySelector('.user-list-ex');\n\nfetchUsersBtn.addEventListener('click', () => {\n  fetch('https://jsonplaceholder.typicode.com/users')\n    .then(response => {\n      if (!response.ok) {\n        throw new Error(response.status);\n      }\n      return response.json();\n    })\n    .then(users => {\n      console.log(users);\n\n      const markup = users\n        .map(user => {\n          return `<li>\n\t          <p><b>Name</b>: ${user.name}</p>\n\t          <p><b>Email</b>: ${user.email}</p>\n\t          <p><b>Company</b>: ${user.company.name}</p>\n\t        </li>`;\n        })\n        .join('');\n\n      userList.insertAdjacentHTML('beforeend', markup);\n    })\n    .catch(error => console.log(error));\n});\n// refactoring\n// fetchUsersBtn.addEventListener('click', () => {\n//   fetchUsers()\n//     .then(users => renderUsers(users))\n//     .catch(error => console.log(error));\n// });\n\n// function fetchUsers() {\n//   return fetch('https://jsonplaceholder.typicode.com/users').then(response => {\n//     if (!response.ok) {\n//       throw new Error(response.status);\n//     }\n//     return response.json();\n//   });\n// }\n\n// function renderUsers(users) {\n//   const markup = users\n//     .map(user => {\n//       return `<li>\n//           <p><b>Name</b>: ${user.name}</p>\n//           <p><b>Email</b>: ${user.email}</p>\n//           <p><b>Company</b>: ${user.company.name}</p>\n//         </li>`;\n//     })\n//     .join('');\n//   userList.insertAdjacentHTML('beforeend', markup);\n// }\n\n// TIPICAL mistake\n// // Зовні колбека методу then у синхронному коді немає доступу до даних асинхронної відповіді бекенда, БУДЕ UNDEFINED\n// Тому дуже важливо пам'ятати, що спроба записати результат асинхронної операції в зовнішню змінну й використовувати його в синхронному коді — неефективний підхід. Замість цього краще використовувати методи .then() та .catch() для обробки результатів асинхронних операцій одразу після їх отримання.\n\n//                                    Параметри рядка запиту\n// СИМВОЛ ? вказує на початок параметрів запиту.Кожен параметр — це пара ім'я=значення.\n// У рядку запиту параметри між собою розділяються СИМВОЛОМ &.\n// Параметри запиту дозволяють вказати бекенду додаткові критерії, наприклад:\n// _limit,  кількість елементів у відповіді;\n// _sort,  порядок сортування об'єктів у масиві.\n// обмежити вибірку тощо.\n\n// Список параметрів запиту, їх назви і можливі значення залежать від бекенду і описані в документації до нього.\n\n//     fetch(\"https://jsonplaceholder.typicode.com/users?_limit=7&_sort=name\")\n// GET-запит у прикладі вище поверне масив із семи користувачів (загалом їх 10), відсортованих за ім'ям (поле name) за алфавітним порядком. Підкреслення в іменах параметрів специфічні для цього бекенда,\n\n//\n//                                             Клас URLSearchParams\n// Під час складання рядків параметрів, створюється екземпляр класу URLSearchParams та ініціалізується об'єктом. Результатом буде спеціальний об'єкт (ітератор) з методами, який у рядковому перетворенні повертає результат виклику методу toString() — своє рядкове відображення.\n\n// const searchParams = new URLSearchParams({\n//   _limit: 5,\n//   _sort: \"name\",\n// });\n\n// console.log(searchParams.toString()); // \"_limit=5&_sort=name\"\n// const url = `https://jsonplaceholder.typicode.com/users?${searchParams}`;\n// console.log(url); // \"https://jsonplaceholder.typicode.com/users?_limit=5&_sort=name\"\n\n// У рядковому вигляді властивості об'єкта стануть параметрами та їх значеннями. Параметри будуть розділені символом &. У разі інтерполяції значення в шаблонних рядках відбувається його неявне перетворення в рядок, тому не потрібно викликати метод toString() під час складання URL. Не забувай вказувати початок рядка запиту символом ?.\n\n// ex\n// fetch() робить запит на сервер тому це асинхронна операція\n// проміс що повертає fetch ми бачимо в 1 then, якщо успішно витягли дані з сервера ВЛАСТИВІСТЬ - ок - в об*єкті проміс буде true\n// ОБОВ*ЯЗКОВО розпарсюємо дані методом .json();\n// ОБОВ*ЯЗКОВО створити екземпляр класу throw new Error() щоб вловити помилку в 1 then (помилка 404 не знайдено - для fetch не помилка бо результат повернувся і відпрацює 2 then не так як треба потім відпрацює в самом низу catch  )\nconst params = new URLSearchParams({\n  _limit: 5,\n  _page: 2,\n});\nconst listJsonPlaceholder = document.querySelector('.list-JSONPlaceholder');\nfetch(`https://jsonplaceholder.typicode.com/todos?${params}`)\n  .then(response => {\n    console.log(response);\n    if (!response.ok) {\n      // якщо статис виконання не успішний -\n      // викинь екземпляр помилки (він виведеться в блоці .catch)\n      throw new Error(`Oppppppps it's error - ${response.status}`);\n    }\n    return response.json();\n  })\n  .then(data => {\n    console.log(data);\n    listJsonPlaceholder.insertAdjacentHTML('beforeend', createMarkup2(data));\n  })\n  .catch(err => {\n    listJsonPlaceholder.insertAdjacentHTML(\n      'beforeend',\n      `<p>${err.message}</p>`\n    );\n    console.log(err);\n  });\n\nfunction createMarkup2(arr) {\n  return arr.map(\n    //    true/false       true   повернеться значення останнього true і стане атрибутом у розмітці\n    //  ${completed && 'checked'}\n    ({ id, title, completed }) =>\n      `<li data-id=\"${id}\" class=\"itemJsonPlaceholder\">\n  <input type=\"checkbox\" ${completed && 'checked'}>\n    <p>${title}</p>\n  </li>`\n  );\n}\n//  екземпляр класу URLSearchParams\nconst params3 = new URLSearchParams({\n  _limit: 5,\n  _page: 2,\n});\nconsole.log(params3);\n\n// автоматизуємо запит на сервер для різних посилань щоб не дублювати код кожного разу\nfunction foo2(url) {\n  return fetch(url).then(response => {\n    if (!response.ok) {\n      throw new Error(response.statusText);\n    }\n\n    return response.json();\n  });\n}\n\nconsole.log(foo2('https://jsonplaceholder.typicode.com/users'));\n\nfoo2('https://jsonplaceholder.typicode.com/users')\n  .then(data => console.log(data))\n  .catch(err => console.log('catch', err));\n\n//Авторизація запитів з ключами буває:\n// - у query string (в параметрі url у fetch)\n// - у ключі хедерс в обєкті параметрів\n// fetch('https://pixabay.com/api/', {\n//   headers: {\n//     Authorisation: `Bearer ${PIXABAY_KEY}`\n//   }\n// });\n\n// EX\n// працюємо з публічним API  сервер з фото і відео https://pixabay.com/api/docs/\n// ключ отримати при реєстрації , на одну пошту - один ключ дають\nconst pixabayList = document.querySelector('.pixabay-list');\n\nconst PIXABAY_KEY = '47506069-50a24acca197abc732faaa7f2';\n// запрашуємо фото по пошуковому слові з серверу, якщо треба більше 1 слова то:\n// - прямо в url прописати в ${encodeURIComponent('red rose')}\n// - краще створ екземпляр URLSearchParams:\nconst params5 = new URLSearchParams({\n  key: PIXABAY_KEY,\n  q: 'red rose',\n});\nfetch(`https://pixabay.com/api/?${params5}`)\n  .then(response => {\n    if (!response.ok) {\n      throw new Error(response.message);\n    }\n    return response.json();\n  })\n  .then(data => {\n    console.log(data);\n    return pixabayList.insertAdjacentHTML(\n      'beforeend',\n      createMarkupPixabay(data.hits)\n    );\n  })\n  .catch(err => console.log(err));\n\nfunction createMarkupPixabay(arr) {\n  return arr\n    .map(\n      ({ id, previewURL, tags }) =>\n        `<li data-id=\"${id}\">\n  <img class=\"pixabay-img\" src=\"${previewURL}\" alt=\"${tags}\" width=\"300\"/>\n  <h2 class=\"pixabay-tags\">${tags}</h2>\n  </li>`\n    )\n    .join('');\n}\n\n// EX створ функціонал показу погоди згідно міста - викор публічний API https://www.weatherapi.com/\n// use ENDPOINT Forecast щоб отримати прогноз погоди\n// після сабміту форми відмалюй картки з: зображення з погодою icon, text, date, avgtemp_c (середня темп в цельсіях)\nconst WHEATHER_KEY = '2fe29d20322d49ab8fc180940240812';\nconst BASE_URL = 'http://api.weatherapi.com/v1';\n\nconst weatherList = document.querySelector('.wheather-list');\nconst wheatherForm = document.querySelector('.wheather-form');\n\nwheatherForm.addEventListener('submit', handleSearchWheather);\nfunction handleSearchWheather(event) {\n  event.preventDefault();\n  const { cityWheather, quantityDays } = event.target.elements;\n  console.log(cityWheather.value, quantityDays.value);\n  fetchWheather(BASE_URL, cityWheather.value, quantityDays.value)\n    .then(data => {\n      console.log(data);\n      weatherList.innerHTML = createWheatherMarkup(data);\n    })\n    .catch(err =>\n      weatherList.insertAdjacentHTML(\n        'beforeend',\n        `<h2>Sorry, we have a problem ${err}</h2>`\n      )\n    )\n    .finally(() => event.target.reset());\n}\n\nfunction fetchWheather(url, city = '', days = 1) {\n  const paramsWheather = new URLSearchParams({\n    key: WHEATHER_KEY,\n    q: city,\n    days,\n    lang: 'en',\n  });\n  //                 breakpoint\n  return fetch(`${url}/forecast.json?${paramsWheather}`).then(response => {\n    if (!response.ok) {\n      throw new Error(response.statusText);\n    }\n    return response.json();\n  });\n}\n\nfunction createWheatherMarkup({ forecast: { forecastday } }) {\n  console.log(forecastday);\n  return forecastday\n    .map(\n      ({\n        date,\n        day: {\n          avgtemp_c,\n          condition: { icon, text },\n        },\n      }) => `\n    <img src=\"${icon}\" alt=\"${text}\" width=\"200\" >\n    <h3>${date}</h3>\n    <h2>${text}</h2>\n    <h3>The average temrature - ${avgtemp_c}C*</h3>`\n    )\n    .join('');\n}\n\n//                                           CRUD\n// Для взаємодії з ресурсами бекенду використовується чотири операції:\n// C - створення (create),\n// R - читання (read),\n// U - оновлення (update),\n// D - видалення(delete)'\n\n//   METHODS BY CRUD:\n// POST (Create) — створити новий ресурс.\n// GET (Read) — отримати набір ресурсів або один ресурс за ідентифікатором.\n// PUT і PATCH (Update) — оновити ресурс за ідентифікатором.\n// DELETE (Delete) — видалити ресурс за ідентифікатором.\n","'use strict';\n// Синхронний код виконується послідовно, кожна інструкція очікує, доки виконається попередня. Коли ти викликаєш функцію, яка виконує тривалу дію, це зупиняє програму на увесь час її виконання. Тобто в моделі синхронного програмування все відбувається по черзі.\n// В асинхронному коді одночасно можуть виконуватися декілька операцій. У такій моделі мережевий запит на сервер не зупинить програму, вона продовжить виконувати інші операції. Коли запит завершиться, програма повідомляє про це й отримує доступ до результату (наприклад, даних із сервера).\n// За одиницю часу, як і раніше, може виконуватися тільки одна операція, тому що JavaScript — однопотокова мова. Асинхронне програмування досягається шляхом відкладених викликів функцій, де ініціалізація асинхронної операції і обробка її результату — це різні дії.\n\n// ........................asynchronous(асинхронний) JavaScript\n//             - функція setTimeout()\n// приймає два параметри:\n// 1)callback-функцію, яка буде викликана після закінчення часу;\n// 2)час, після якого буде викликана функція.\n// Функція setTimeout() відпрацьовує синхронно й реєструє відкладений виклик переданої callback-функції. Ця функція буде викликана асинхронно, через вказаний проміжок часу.\n//  Функція setTimeout планує в асинхронній черзі відкладений виклик функції, який виконується після зазначеного інтервалу часу. Вона не викликає функцію безпосередньо, а лише планує її виконання через певний час.\n\n//                   Тайм-аут\n// Внутрішній таймер-планувальник браузера дозволяє відкладати виклик функції на певний період часу. Для цього є тайм-аути та інтервали, вони контролюють, коли і як часто викликається функція. Таймери реалізовані в браузері, а не вбудовані в мову, і доступні на глобальному об'єкті window.\n// Метод setTimeout() дозволяє запланувати одноразовий виклик функції через певний час.\n// Метод setTimeout() дозволяє запланувати одноразовий виклик функції через певний час.\n// Результатом виклику setTimout() буде цифровий ідентифікатор створеного таймера, який потім може бути використаним для його подальшого скасування.\n\n//                     Скасування тайм-ауту\n// метод clearTimeout(id) - скасовує відкладений виклик функції, зареєстрованої тайм-аутом.\n// Метод clearTimeout(id)приймає ідентифікатор таймера та “очищає його”, тобто видаляє реєстрацію відкладеного виклику функції з черги.\n// const greet = () => {\n//   console.log(\"Hello!\");\n// };\n\n// const timerId = setTimeout(greet, 3000);\n\n// clearTimeout(timerId);\n\n// ex\nconst setBtn = document.querySelector('.js-set');\nconst clearBtn = document.querySelector('.js-clear');\n\nlet timeoutId;\n\n// через 2с в консоль мало б вивестись повідомлення \"I love async JS!\"\nsetBtn.addEventListener('click', handleAsync);\nfunction handleAsync(event) {\n  timeoutId = setTimeout(() => {\n    console.log('I love async JS!');\n  }, 2000);\n}\n\n// але ми скасували заплановане виконання ф-ції\nclearBtn.addEventListener('click', handleClearAsync);\nfunction handleClearAsync(event) {\n  clearTimeout(timeoutId);\n  console.log(`Timeout with id ${timeoutId} has stopped!`);\n}\nconsole.log('modul 10');\n\n// Якщо потрібно очищати всі таймери, можна, наприклад, зберігати ідентифікатори всіх запущених таймерів у вигляді масиву, перебирати його та послідовно очищати.\n\n//                  Інтервал\n// Метод setInterval() — це простий спосіб повторення коду знову і знову з певним інтервалом.\n// const intervalId = setInterval(callback, delay, arg1, arg2, ...);\n// Результатом виклику setInterval() буде цифровий ідентифікатор створеного таймера, який потім може бути використаним для його подальшого скасування.\n\n// !!!!!На відміну від setTimeout(), інтервал запускає виконання функції не один раз, а регулярно повторює її через вказаний проміжок часу.\n// Таймер може спрацьовувати рідше, ніж зазначено в параметрі delay. Адже через занадто велике завантаження процесора деякі запуски функцій-інтервалів будуть пропущені. Браузери продовжують виконувати тайм-аути та інтервали, навіть якщо вкладка браузера неактивна, але водночас знижується частота спрацьовування таймерів.\n\n// Скільки разів буде викликана функція foo для setInterval(foo, 2000)?\n// -Кожні 2 секунди\n\n//                 Скасування інтервалу\n// метод clearInterval.\n// clearInterval(id)\n//  приймає ідентифікатор інтервалу та очищає його, тобто видаляє виклики, зареєстровані переданим інтервалом з асинхронної черги.\n// Якщо потрібно очистити всі інтервали, можна, наприклад, зберігати ідентифікатори всіх запущених інтервалів у вигляді масиву, перебирати його та послідовно очищати.\n\n//                                              Дата і час\n// Вбудований клас Date дозволяє відображати моменти у часі як об'єкти і маніпулювати ними за допомогою заздалегідь визначених методів. Використовуючи можливості класу Date, можна створювати годинник, лічильники, календарі та інші інтерактивні елементи інтерфейсу.\n// Екземпляр класу Date — це об'єкт, що відображає певний момент часу. Створення дати без аргументів повертає об'єкт, що зберігає дату і час на момент його ініціалізації, тобто поточні дату і час.\n// const date = new Date();\n// console.log(date);\n// У рядковому перетворенні об'єкт повертає результат виклику вбудованого методу toString(), тому у першому лозі ми отримаємо рядок, а не об'єкт.\n\n// до класу Date передають рядок, який описує тільки дату.\n// const date = new Date(\"2030-03-16\");\n// console.log(date); // \"Sat Mar 16 2030 00:00:00 GMT+0200\"\n\n// до Date передали рядок, де дата і час розділяються великою літерою T (time).\n// const date = new Date(\"2030-03-16T14:25:00\");\n// console.log(date); // \"Sat Mar 16 2030 14:25:00 GMT+0200\"\n// Можна передати тільки рік, рік і місяць, або повну дату, включно з числом і часом.\n// console.log(new Date(\"2030\")); // \"Tue Jan 01 2030 02:00:00 GMT+0200\"\n// console.log(new Date(\"2030-03\")); // \"Fri Mar 01 2030 02:00:00 GMT+0200\"\n// console.log(new Date(\"2030-03-16\")); // \"Sat Mar 16 2030 02:00:00 GMT+0200\"\n// console.log(new Date(\"2030-03-16T14:25:00\")); // \"Sat Mar 16 2030 14:25:00 GMT+0200\"\n\n// Інший спосіб створення нової дати — це передати сім чисел, які описують рік, місяць (починається з 0), день, години, хвилини, секунди й мілісекунди. Обов'язкові тільки перші три.\n// const date = new Date(2030, 2, 16, 14, 25, 0, 0);\n// console.log(date); // \"Sat Mar 16 2030 14:25:00 GMT+0200 \"\n//                                             Unix час\n// Unix час - для комп’ютерів відлік часу рахується в мілісекундах, що минули після опівночі 1 січня 1970 року в часовому поясі UTC (Coordinated Universal Time).\n\n// Під час ініціалізації дати одним числом, воно являє собою кількість мілісекунд, що вже минула з 01.01.1970.\nconsole.log(new Date(0));\n// \"Thu Jan 01 1970 03:00:00 GMT+0300 (Eastern European Standard Time)\"\n\nconsole.log(new Date(15000));\n// \"Thu Jan 01 1970 03:00:15 GMT+0300 (Eastern European Standard Time)\"\n\n// Вбудований метод getTime() повертає числове значення цієї дати (timestamp) — кількість мілісекунд, що минула з півночі 1 січня 1970 року.\n// const date = new Date();\n// console.log(date.getTime()); // 1624021654154\n\n// Це число унікальне й ніколи не повториться, тому що момент часу унікальний і завжди тільки збільшується.Зручність цього формату полягає в тому, що можна відображати точні моменти часу у вигляді одного числа і не турбуватися про дати, рядки й часові пояси. Адже можна отримати всю необхідну інформацію, коли необхідно.\n\n//                                         Метод Date.now()\n// У разі, коли все, що потрібно, це числове представлення моменту часу, немає сенсу створювати цілий об'єкт. Можна використовувати метод Date.now() — це швидкий і зручний спосіб отримати поточний час у вигляді мілісекунд\n\n// const time = Date.now(); // 1693237207904\n\n// Основна ідея застосування Date.now() полягає у вимірюванні часу, розрахунку інтервалів тощо.\n\n// Якщо ти хочеш виміряти, скільки часу займає виконання деякого коду, можна зробити так:\n// const startTime = Date.now();\n\n// // Твій код, виконуваний упродовж деякого часу\n// for(let i = 0; i <= 100; i += 1) {\n// \tconsole.log(i);\n// }\n\n// const endTime = Date.now();\n// const elapsedTime = endTime - startTime;\n\n// console.log(`Elapsed time: ${elapsedTime} ms`);\n\n// Зберегти час до події.\n// Зберегти час після події.\n// Порахувати різницю між кінцевим і початковим часом.\n\n//                                                            Геттери і сеттери екземпляра класу Date\n// Геттери використовуються для читання всієї дати або окремої складової. Значення, що повертається, залежить від поточного часового поясу, встановленого на комп'ютері.\nconst date = new Date('March 16, 2030 14:25:00');\nconsole.log('Date: ', date); // \"Sat Mar 16 2030 14:25:00 GMT+0200\"\n\n// Повертає день місяця від 1 до 31\nconsole.log('Day: ', date.getDate()); // 16\n\n// Повертає день тижня від 0 до 6, починається з неділі\nconsole.log('Day of the week: ', date.getDay()); // 6\n\n// Повертає місяць від 0 до 11\nconsole.log('Month: ', date.getMonth()); // 2\n\n// Повертає рік з 4 цифр\nconsole.log('Full year: ', date.getFullYear()); // 2030\n\n// Повертає години\nconsole.log('Hours: ', date.getHours()); // 14\n\n// Повертає хвилини\nconsole.log('Minutes: ', date.getMinutes()); // 25\n\n// Повертає секунди\nconsole.log('Seconds: ', date.getSeconds()); // 0\n\n// Повертає мілісекунди\nconsole.log('Milliseconds: ', date.getMilliseconds()); // 0\n\n// ex\nconst date2 = new Date();\nconsole.log(date2);\nconst clock = document.querySelector('.container-time');\nconst parForTime = document.querySelector('.time-date');\nparForTime.textContent = `${date2.getHours()}:${date2.getMinutes()}`;\n\n//                                                                           Promise\n// Promise (проміс, від англ. promise — обіцяти) — об'єкт, що представляє поточний стан асинхронної операції. Це обгортка для значення, невідомого на момент створення промісу. Проміс дозволяє обробляти результати асинхронних операцій таким чином, якби вони були синхронними: замість кінцевого результату асинхронної операції, повертається своєрідна обіцянка отримати результат у майбутньому.\n// Проміс — це об'єкт, що зберігає стан асинхронної операції, який використовується для відслідковування стану операції: чи була операція виконана успішно, з помилкою, або ще не завершена.\n//    Життєвий цикл проміса:\n// Очікування (pending) — початковий стан під час створення промісу.\n// Виконано (fulfilled) — операція виконана успішно з будь-яким результатом.\n// Відхилено (rejected) — операція відхилена з помилкою.\n\n// спосіб описати, що проміс перебуває в будь-якому стані, крім очікування (виконаний або відхилений) - settled (це не окремий стан)\n//                                                                          Створення проміса\n//  створюється як екземпляр класу Promise, який приймає функцію як аргумент (називається \"виконавцем\" (executor)) і відразу викликає її, ще до створення і повернення промісу.\n// const promise = new Promise((resolve, reject) => {\n//     // Asynchronous operation\n//   });\n//   resolve(value) — функція для виклику у разі успішної операції. Переданий їй аргумент буде значенням виконаного промісу.\n//   reject(error) — функція для виклику у разі помилки. Переданий їй аргумент буде значенням відхиленого промісу.\n\n// Колбек-функція повідомляє проміс, коли і як операція, з якою він пов'язаний, буде завершена. У ній можна виконувати будь-яку асинхронну операцію. Після її завершення потрібно викликати:\n//          - resolve() для позначення успішного виконання. Результатом буде fulfilled.\n// Або\n//          - reject() у разі помилки, який встановлює стан промісу як \"відхилений\" (rejected).\n// Значення, що повертається цією функцією-виконавцем, ІГНОРУЄТЬСЯ.\nconst isSuccess = true;\n\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    if (isSuccess) {\n      resolve('Success! Value passed to resolve function');\n    } else {\n      reject('Error! Error passed to reject function');\n    }\n  }, 2000);\n});\n\nconsole.log(promise); // Об'єкт промісу\n// У змінну promise буде записаний проміс (об'єкт) у стані pending, а через дві секунди, щойно буде викликаний resolve() або reject(), проміс перейде у стан fulfilled або rejected, і ми зможемо його обробити.\n//                                                      Метод проміса then()\n// приймає два аргументи — дві callback функції, які будуть викликані, коли проміс змінить свій стан.\n// Код, якому потрібно зробити щось асинхронно, створює проміс і повертає його.Зовнішній код, отримавши проміс, додає до нього обробники. Після завершення процесу асинхронний код переводить проміс у стан fulfilled або rejected, і автоматично викликаються методи промісів (обробники) у зовнішньому коді.\n\n// Результат промісу — це значення або помилка, яку функції отримають як аргументи.\n\n// promise.then(onResolve, onReject)\n\n//  - onResolve(value) — 1-й аргумент методу then(), колбек-функція, яка буде викликана у разі успішного виконання промісу та отримає його результат як аргумент.\n//  - onReject(error) — 2-й аргумент методу then(), колбек-функція, яка буде викликана у разі виконання промісу з помилкою та отримає її як аргумент.\n// У прикладі нижче callback-функція onResolve буде викликана через дві секунди, якщо проміс успішно виконається, а onReject буде викликана через дві секунди у тому разі, якщо проміс виконається з помилкою.\n\nconst isSuccess2 = true;\n\n// Create promise\nconst promise2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    if (isSuccess2) {\n      resolve('Success! Value passed to resolve function');\n    } else {\n      reject('Error! Error passed to reject function');\n    }\n  }, 2000);\n});\n\n// Registering promise callbacks\npromise2.then(\n  value => {\n    console.log(value); // \"Success! Value passed to resolve function\"\n  },\n  error => {\n    console.log(error); // \"Error! Error passed to reject function\"\n  }\n);\n\n// Якщо функції onResolve і onReject містять складну логіку, їх для зручності оголошують як зовнішні функції і передають у метод then() за ім'ям.\n//                                                                             Метод catch()\n// На практиці в методі then() обробляють тільки успішне виконання промісу.\n// Помилку його виконання обробляють у спеціальному методі catch() для «відловлювання» помилок.\n// promise\n// \t.then(value => {\n// \t\t// Promise fulfilled\n// \t})\n// \t.catch(error => {\n// \t  // Promise rejected\n// \t});\n\n// Колбек-функція в методі catch буде викликана в разі виконання промісу з помилкою, і отримає цю помилку як аргумент. Метод catch МАЄ СТОЯТИ ПІСЛЯ then.\n\n// Винесемо обробку помилки з методу then у метод catch.\nconst isSuccess3 = true;\n\n// Create promise\nconst promise3 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    if (isSuccess3) {\n      resolve('Success! Value passed to resolve function');\n    } else {\n      reject('Error! Error passed to reject function');\n    }\n  }, 2000);\n});\n\n// Registering promise callbacks\npromise3\n  .then(value => {\n    console.log(value); // \"Success! Value passed to resolve function\"\n  })\n  .catch(error => {\n    console.log(error); // \"Error! Error passed to reject function\"\n  });\n\n//                                                                         Метод finally()\n//  якщо необхідно виконати код після того, як проміс буде виконаний незалежно від результату (fulfilled або rejected). Дозволяє уникнути дублювання коду в обробниках then() і catch().\n// promise\n// \t.then(value => {\n// \t  // Promise fulfilled\n// \t})\n// \t.catch(error => {\n// \t  // Promise rejected\n// \t})\n// \t.finally(() => {\n// \t  // Promise fulfilled or rejected\n// \t});\n\n// Колбек-функція не отримає жодних аргументів, оскільки неможливо визначити, чи був проміс виконаний або відхилений. Тут буде виконуватися код, який необхідно запустити в будь-якому разі.\nconst isSuccess4 = true;\n\n// Create promise\nconst promise4 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    if (isSuccess4) {\n      resolve('Success! Value passed to resolve function');\n    } else {\n      reject('Error! Error passed to reject function');\n    }\n  }, 2000);\n});\n\n// Registering promise callbacks\npromise4\n  .then(value => console.log(value)) // \"Success! Value passed to resolve function\"\n  .catch(error => console.log(error)) // \"Error! Error passed to reject function\"\n  .finally(() => console.log('Promise settled')); // \"Promise settled\"\n\n//                                                                Ланцюжки промісів\n// Метод then() ПОВЕРТАЄ НОВИЙ ПРОМІС, який у свою чергу отримує значення від своєї callback-функції onResolve. Ця особливість дозволяє формувати послідовність асинхронних операцій, зв'язуючи проміси в ланцюжок.\n\n// Метод then() повертає проміс. Перед його виконанням може минути деякий час, отже, частина ланцюжка, що залишилася, буде чекати на результат. У разі виникнення помилки в будь-якому місці ланцюжка, виконання всіх наступних then() скасовується, а управління передається методу catch(). Тому він має знаходитись у кінці ланцюжка усіх then().\n\nconst promise5 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(5);\n  }, 1000);\n});\n\npromise5\n  .then(value => {\n    console.log(value); // 5\n    return value * 2;\n  })\n  .then(value => {\n    console.log(value); // 10\n    return value * 3;\n  })\n  .then(value => {\n    console.log(value); // 30\n  })\n  .catch(error => {\n    console.log(error);\n  })\n  .finally(() => {\n    console.log('finally');\n  });\n//                                                                                   Lection\n// асинхронні ф-ції зі стеку виклику переміщаються у сховище web API  і потім відпрацьовують по своїй черзі залежно від часу затримки\n// синхронні операції потрапляють тілтки у стек виклику і відпрацьовують по черзі як в коді\n// ex прилетить з циклу і попаде в web API:  3 (затримка 3000 ), 2(затримка 2000), 1( затримка 1000)\n// а відпрацює по часу затримки і виведе в консоль - 1, 2, 3\nfor (let i = 3; i > 0; i--) {\n  const delay = i * 1000;\n\n  setTimeout(() => {\n    // 3 2 1\n    console.log(i);\n    //  3000 2000 1000\n  }, delay);\n}\n\n// навіть якщо вказати затримку 0 то затримка буде все одно мінімальна 4 мілесекунди і ф-ція потрабить у web API\n\n// setTimeout(() => {}, 2000) один раз відпрацює із затримкою, поверне ID\n// clearTimeout(id) - зупинить відкладене виконання ф-ції\n// setInterval(() => {}, 2000) постійно відпрацьовуватиме через інтервал часу\n// clearInterval(id) зупинить відпрацювання ф-ції, щоб видалити всі - збережи id (рез виконання ф-ції) в []\nconst logger2 = ({ time, name }) => {\n  console.log(`logger2 ${time} - ${name}`);\n};\n//вказали дод параметр через деструктуризацію параметрів, якщо пар декілька краще запис їх через об*єкт\nconst logger2Id = setInterval(logger2, 1500, { time: '1.5s', name: 'Dj' });\n\nclearInterval(logger2Id);\n\n// ex\n// show and hide by adding/removing the class \"is-visible\"\n// hide with delay and meanwhile has event click\n// don't forget to clean the timer\nconst elementByManipulation = document.querySelector('.js-alert');\n\nshowElement();\nfunction showElement() {\n  elementByManipulation.classList.add('is-visible');\n}\n\nlet delayForHiddenID;\n\nelementByManipulation.addEventListener('click', handleClickToHide);\nfunction handleClickToHide(event) {\n  const delayForHiddenID = setTimeout(() => {\n    console.log('The element was hidden');\n    elementByManipulation.classList.remove('is-visible');\n  }, 3000);\n}\nclearTimeout(delayForHiddenID);\n\n//  instanceByClassDate.getTime() - return the time in ms from 01/01/1970 to time by present time -UNIXE time\n// Date.now() - -//- if you don't need to create whole(целый) object that will know UNIX time - you CAN USE THIS S T A T I C CLASS METHOD\n\n// EX  WE CALCULATE THE DIFFERENCE BETWEEN TWO DATES\n\nconst date1 = Date.now();\n\nsetTimeout(() => {\n  const date2 = Date.now();\n  console.log(\n    `DIFFERENCE BETWEEN TWO DATES its value of daley - ${date2 - date1} ms`\n  );\n}, 2000);\n\n// ex Timer\n// create the class Timer that has draw the area with the timer and implement the btn \"start\" and the \"stop\"\n// const startBtn = document.querySelector('button[data-action-start]');\n// const stopBtn = document.querySelector('button[data-action-stop]');\n// const areaForShowTheTimer = document.querySelector('.clockFace');\n\n// class Timer {\n//   constructor({ displayTime }) {\n//     // timer isn't active (don't pressed the btn \"Start\")\n//     this.isActive = false;\n//     this.intervalID = null;\n//     this.displayTime = displayTime;\n//     // call a method in CONSTRUCTOR wich will display the starting area  00:00:00 meanwhile we create the instance by class\n//     this.showStartingArea();\n//   }\n\n//   showStartingArea() {\n//     const time = this.getTimeComponent(0);\n//     this.displayTime(time);\n//   }\n//   startTimer() {\n//     // we check that not have restarting the timer\n//     if (this.isActive) {\n//       return;\n//     }\n//     this.isActive = true;\n//     // the time wich we have when we pressed btnStart\n//     const startTime = Date.now();\n//     // interval show the time через каждую секунду (every second) and calculate the differencce\n//     this.intervalID = setInterval(() => {\n//       const currentTime = Date.now();\n//       // time in ms\n//       const differencceBetweenTimes = currentTime - startTime;\n\n//       const time = this.getTimeComponent(differencceBetweenTimes);\n//       console.log(time);\n\n//       this.displayTime(time);\n//     }, 1000);\n//   }\n//   // розбіваємо мілісекунди на години, хвилини, секунди\n//   getTimeComponent(timeInMs) {\n//     //  викликали метод padStart для форматування 00:00:00\n//     const seconds = this.padStart(Math.floor((timeInMs % (1000 * 60)) / 1000));\n//     const minutes = this.padStart(\n//       Math.floor((timeInMs % (1000 * 60 * 60)) / (1000 * 60))\n//     );\n//     // 1000ms in 1s * 60s in 1min * 60min in 1h * 24h in 1day / convert ms in hours\n//     const hours = this.padStart(\n//       Math.floor((timeInMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60))\n//     );\n\n//     return { hours, minutes, seconds };\n//   }\n\n//   padStart(value) {\n//     return String(value).padStart(2, '0');\n//   }\n\n//   stopTimer() {\n//     clearInterval(this.intervalID);\n//     this.isActive = false;\n//   }\n// }\n\n// // create the instance\n// const instanceTimer = new Timer({ displayTime: displayTimeInArea });\n\n// startBtn.addEventListener(\n//   'click',\n//   instanceTimer.startTimer.bind(instanceTimer)\n// );\n\n// // створ зовн ф-цію відмальовування часу і передаємо її як метод під час створення екземпляру\n// function displayTimeInArea({ hours, minutes, seconds }) {\n//   areaForShowTheTimer.textContent = `${hours}:${minutes}:${seconds}`;\n// }\n\n// stopBtn.addEventListener('click', instanceTimer.stopTimer.bind(instanceTimer));\n\n//                                                                    EX impliment refactoring ex - without class\nconst startBtn = document.querySelector('button[data-action-start]');\nconst stopBtn = document.querySelector('button[data-action-stop]');\nconst areaForShowTheTimer = document.querySelector('.clockFace');\n\nlet isActive = false;\nlet intervalID;\n\nstartBtn.addEventListener('click', startTimer);\n\nfunction startTimer() {\n  if (isActive) {\n    return;\n  }\n  isActive = true;\n\n  const startTime = Date.now();\n\n  intervalID = setInterval(() => {\n    const currentTime = Date.now();\n    const differencceBetweenTimes = currentTime - startTime;\n\n    const time = getTimeComponent(differencceBetweenTimes);\n    console.log(time);\n\n    displayTimeInArea(time);\n  }, 1000);\n}\n\nfunction getTimeComponent(timeInMs) {\n  const seconds = padStart(Math.floor((timeInMs % (1000 * 60)) / 1000));\n  const minutes = padStart(\n    Math.floor((timeInMs % (1000 * 60 * 60)) / (1000 * 60))\n  );\n  const hours = padStart(\n    Math.floor((timeInMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60))\n  );\n\n  return { hours, minutes, seconds };\n}\n\nfunction displayTimeInArea({ hours, minutes, seconds }) {\n  areaForShowTheTimer.textContent = `${hours}:${minutes}:${seconds}`;\n}\n\nfunction padStart(value) {\n  return String(value).padStart(2, '0');\n}\n\nfunction showStartingArea() {\n  const time = getTimeComponent(0);\n  displayTimeInArea(time);\n}\n\nstopBtn.addEventListener('click', stopTimer);\nfunction stopTimer(event) {\n  clearInterval(intervalID);\n  isActive = false;\n}\n\n//                                                                        Промісифікація\n//                                                              LECTION\n// ПРОМІС під час створення екземпляру приймає 2 колбекф-ції: resolve (відпрацює якщо код виповниться успішно) і reject(відпрацює у разі помилки). RETURN НЕ ПИШУТЬ\nconst instancePromis = new Promise((resolve, reject) => {\n  const random = Math.random();\n\n  setTimeout(() => {\n    if (random > 0.5) {\n      resolve('My fulfilled');\n    } else {\n      reject('My rejected');\n    }\n  }, 2000);\n});\n// після того як проміс стане setled (fulfilled або rejected) далі результат промісу (у дужках resolve() або reject()) обрабляють наступними методами:\ninstancePromis\n  .then(success => console.log('Success'))\n  .catch(error => console.log('Error'))\n  .finally(() => console.log('Finally method is happend in any event'));\n\n// ланцюжки .then(). Метод then повертає проміс\nconst instancePromis2 = new Promise((resolve, reject) => {\n  resolve(5);\n});\n\ninstancePromis2\n  //        5\n  .then(data => {\n    return data * 2;\n  })\n  //        10\n  .then(value => {\n    return value - 2;\n  })\n  //        8\n  .then(data => {\n    return console.log(data);\n  })\n  .catch(err => 'err')\n  .finally(fin => 'fin');\n\n// Порядок виконання коду\n// черга асинхронних процесів:\n// мікро процеси -  promise, addEventListener, обсервери\n// макро процеси - setTimeout, setInterval\n//\n// event look - відповідає за правильну послідовністю виконання коду\n// - якщо синхронний код в СТЕКВИКЛИКУ виконався - 2. з МІКРО черги відправляє ВСІ задачі по черзі виконуватися в СТЕКВИКЛИКУ - 3. з МАКРО черги выдправляэ ОДНУ задачу - 4. якщо є в коді - відбув ререндер сторінки (випливаючі модалки тощо)\n// потім все по колу спочатку - весь синхронний код - всі мікро зачадачі - одна макро - ререндер\n\n// ex що буде виведено у консоль? 1(синхр код), 3(всі мікро проц), 4(всі мікро проц), 2(по одному макро), 5(макро бо більш нема коду)\nconsole.log('step 1');\n\nsetTimeout(() => {\n  return console.log('step 2');\n}, 0);\n\nnew Promise(resolve => {\n  resolve('step 3');\n})\n  .then(data => {\n    console.log(data);\n    return 'step 4';\n  })\n  .then(data => console.log(data));\n\nsetTimeout(() => console.log('step 5'), 0);\n\n//                                                         промісифікація\n// промфсифікова ф-ція - повертає проміс , далі його результат обробляють методами\nconst makeOrder = dish => {\n  return new Promise((resolve, reject) => {\n    const random = Math.random();\n\n    setTimeout(() => {\n      if (random > 0.5) {\n        resolve(`Ваше замовлення ${dish}`);\n      } else {\n        reject(`Закінчилися продукти`);\n      }\n    }, 1000);\n  });\n};\n\nmakeOrder('Пиріжок')\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n  .finally(() => `Have a nice day!`);\n\n//                                            промісифікація \"синхронних\" ф-цій (без setTimeout)\n// викор СТАТИЧНІ методи промісу:\n// - Promise.resolve() - обов*язково викор return\n// - Promise.reject() - обов*язково викор return\n// - замість того щоб створ проміс всередині функції можна викор ці методи, тільки для СИНХРОННОГО коду\nconst makeOrder2 = dish => {\n  const random = Math.random();\n  if (random > 0.5) {\n    return Promise.resolve(`Ваше замовлення ${dish}`);\n  } else {\n    return Promise.reject(`Закінчилися продукти`);\n  }\n};\n\nmakeOrder2('Пиріжок')\n  .then(success => success)\n  .catch(error => error);\n//                                                 Обробка множинних промісів\n// щоб не обробляти кожний проміс окремо\n//                                  СТАТИЧНИЙ  метод Promise.all([])\n// він чекає на виконання всіх промісів, а потім створює та ПОВЕРТАЄ НОВИЙ ПРОМІС, значенням якого є масив значень виконаних промісів.\n//  очікує виконання всіх переданих промісів, і якщо хоча б один із промісів відхилено (завершено з помилкою), то Promise.all також відхилиться та поверне відхилення.\n// Якщо всі проміси виконуються успішно, повернений проміс перейде у стан fulfilled, а його значенням буде масив результатів виконання кожного промісу.\n//\nconst startTime = Date.now();\n\nconst res1 = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const currentTime = Date.now();\n      const differenceTime = currentTime - startTime;\n\n      resolve({\n        title: 'first promis',\n        time: `The difference between the start time and the time when accinc function is completed -  is ${differenceTime}`,\n      });\n    }, 3000);\n  });\n};\n\nconst res2 = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const currentTime = Date.now();\n      const differenceTime = currentTime - startTime;\n\n      resolve({\n        title: 'second promis',\n        time: `The difference between the start time and the time when accinc function is completed -  is ${differenceTime}`,\n      });\n    }, 1000);\n  });\n};\n\nconst res3 = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const currentTime = Date.now();\n      const differenceTime = currentTime - startTime;\n\n      resolve({\n        title: 'therd promis',\n        time: `The difference between the start time and the time when accinc function is completed -  is ${differenceTime}`,\n      });\n    }, 3000);\n  });\n};\n\n// res1().then(data => console.log(data)).catch(error => console.log(error));\n// res2().then(data => console.log(data)).catch(error => console.log(error));\n// res3().then(data => console.log(data)).catch(error => console.log(error));\n\nPromise.all([res1(), res2(), res3()])\n  .then(data => console.log(data))\n  .catch(error => console.log(error));\n\n//                                                СТАТИЧНИЙ метод Promise.race([])\n// повертає НАЙШВИДШИЙ ПРОМІС  незалежно який (успішно чи помилкою)\n// найшвидший проміс перейде або в стан fulfilled  і буде виконано колбек методу then зі значенням цього промісу, а решту буде відкинуто. АБО найшвидший проміс перейде в стан rejected І виконається колбек методу catch зі значенням другого промісу, а інші будуть відкинуті.\nPromise.race([res1(), res2(), res3()])\n  .then(data => console.log(data))\n  .catch(error => console.log(error));\n\n//                                             СТАТИЧНИЙ метод Promise.allSettled([])\n// Відмінність від Promise.all полягає в тому, що метод Promise.allSettled() чекає виконання всіх промісів незалежно від того, чи були деякі або навіть всі проміси відхилені.\n// ПОВЕРТАЄ ПРОМІС ЗІ ЗНАЧЕННЯМ масивУ об'єктів з результатами виконання кожного промісу.\n//  - status — властивість, яка зберігає статус, з яким виконався проміс, це рядок \"fulfilled\" або \"rejected\".\n//  - value АБО reason — властивість, в якій зберігається значення, з яким виконався або був відхилений проміс.\n\n// ex THE GAME\n// write software for a slot's machine\n//  - the smile ('😇' or '😈')should appear in each box with a delay of 1 second meanwhile the  btn 'Start game' is pressed\n// - create the array with promises  each of them will be responsible(відповідати) for his box\n//using the method Promise.allSettled for work with array\n// - script should write the game status (victory or defeat) when all boxs will be filled\n// if smiles are the same(однакові) in each boxs it's mean that user has a victory\n// write the game status in the area for result - 'Winner' or 'Loser'\n// -after pressing the button \"Start game\" again the area must be cleared and the game must start over\nconst startGameBtn = document.querySelector('.start-btn-game');\nconst containerForBoxsGame = document.querySelector('.container-box-games');\nconst areaResultByGame = document.querySelector('.result-game');\n\nstartGameBtn.addEventListener('click', handleStartGame);\nfunction handleStartGame(event) {\n  // робимо кнопку неакктивною після натискання\n  startGameBtn.disabled = true;\n  // очищаєм бокси від попереднього наповнення\n  areaResultByGame.innerHTML = '';\n  // створ із псевдо масиву дітей контейнера - такої самої довжини масив промісів для кожного бокса\n  // перетвор псевдо мас в мас за доп спред оператора або Aray.from()\n\n  const promisesArray = [...containerForBoxsGame.children].map(() => {\n    return new Promise((resolve, reject) => {\n      const random = Math.random();\n\n      if (random > 0.5) {\n        resolve('😇');\n      } else {\n        reject('😈');\n      }\n    });\n  });\n  console.log(promisesArray);\n\n  Promise.allSettled(promisesArray).then(items => {\n    console.log(items);\n    const isWinner =\n      items.every(item => item.status === 'fulfilled') ||\n      items.every(item => item.status === 'rejected');\n    console.log(isWinner);\n\n    //перебираємо масив з об*єктами результатами промісів\n    items.forEach((obj, index) => {\n      console.log(obj);\n      // очищаємо boxs щоб при повторному нажатті кнопки відображалися по новій смайлики\n      containerForBoxsGame.children[index].textContent = '';\n      setTimeout(() => {\n        containerForBoxsGame.children[index].textContent =\n          obj.value || obj.reason;\n\n        if (index === items.length - 1) {\n          areaResultByGame.textContent = isWinner ? 'Winner' : 'Loser';\n          // робимо кнопку активною для натискання\n          startGameBtn.disabled = false;\n        }\n\n        // 1000 , 2000, 3000\n      }, 1000 * (index + 1));\n    });\n  });\n}\n// ex procedure for running (порядок відпрацювання)asynchronous processes\n// 2 (мікро) потым по черзы з WEB API макро - 1 4 3(останній потрапив у макро чергу)\nsetTimeout(() => {\n  console.log('step 1');\n}, 0);\n\nnew Promise((resolve, reject) => {\n  resolve('step 2');\n}).then(data => {\n  console.log(data);\n\n  setTimeout(() => console.log('step 3'));\n}, 0);\n\nsetTimeout(() => {\n  console.log('step 4');\n}, 0);\n\n// якщо затримку змінити > 0 , то буде такий порядок 2 3 1 4\n\n//                                                               МЕНТОР\n// Об'єкт Promise використовується для відкладених та асинхронних обчислень, і так як мова програмування Javascript однопоточна, тому одночасно кілька дій він виконувати не може - для цього і існують асинхронні операції.\n// Асинхронний код дозволяє користувачеві взаємодіяти з додатком, поки виконуються фонові операції. Саме це робить JS потужним для веброзробки.\n// Якщо працюєте з простими операціями з датами, вбудовані методи Date цілком підходять. Для більш складних маніпуляцій або форматування використовуйте бібліотеки Day.js чи date-fns. Вони компактні, зручні й допоможуть зробити ваш код читабельнішим. Moment.js - ще одна корисна бібліотека для роботи з датами, яка має багатий функціонал. Зараз у неї менше оновлень, але вона залишається популярною.\n// Завжди очищуйте setInterval за допомогою clearInterval, щоб уникнути нескінченних виконань.\n// Вам потрібно розібратися з тим, як працюють асинхронні функції, і в який момент вони починають своє виконання. Які стани бувають у промісу і що вони означають, а також для чого потрібні методи then() і catch() при роботі з промісами.\n\n//                                                              PRACTICE\n// EX 1\n//якщо імейл та пароль збігаються з тим що в об*єкті - зберігай дані з форми при сабміті в лок сховище і зміни кнопку login на logout і роби поля ввекдення недоступними до зміни\n// при перезавантаж сторінки - якщо користувач залогінений ми маємо бачити кнопку logout та недоступні до зміни поля з даними користувача\n// клік по logout повертає все до початкового вигляду і видаляє дані користувача з localStorage\n// якщо введені дані не збігаються з даними користувача в об*єкту - алерт (повідомлення про помилку)\nconst USER_DATA = { email: 'gymGYM@gmail.com', password: 'iLikeGym' };\nconst formExample1 = document.querySelector('.login-form');\nconst btnFormLog = document.querySelector('#log-btn');\nconst inpEmail = document.querySelector('[name=email1]');\nconst inpPassword = document.querySelector('[name=password1]');\nformExample1.addEventListener('submit', handleLogin);\nfunction handleLogin(event) {\n  event.preventDefault();\n  const emailVal = event.target.elements.email1.value;\n  const passVal = event.target.elements.password1.value;\n  const { email, password } = USER_DATA;\n\n  if (\n    String(emailVal) === String(email) &&\n    String(passVal) === String(password)\n  ) {\n    console.log('are you redy for the good time?');\n    localStorage.setItem(\n      'userData',\n      JSON.stringify({ email: `${emailVal}`, password: `${passVal}` })\n    );\n    console.log(localStorage.getItem('userData'));\n\n    btnFormLog.textContent = 'logout';\n\n    inpEmail.disabled = true;\n    inpPassword.disabled = true;\n  }\n}\n\n//                                               PRACTICE\n// ex 1\n","'use strict';\n//                         localStorage and sessionStorage\n// ex Implement saving value in textarea by user meanwhile the page was reload. The textarea is clearing after submit the form.\nconst form9 = document.querySelector('.feedback-form9');\nconst textarea = form9.querySelector('textarea');\n// 1) отримуємо динамічно дані які ввів користувач в текстареа та зберігаємо їх в localStorage\ntextarea.addEventListener('input', handleSaveMessage);\nfunction handleSaveMessage(event) {\n  console.log(event.target.value);\n  localStorage.setItem('message', `${event.target.value}`);\n}\n\n// 2) повертаємо збережений месседж з localStorage, якщо там щось було - оновлюємо DOM\nfunction MessageGoBackAfterReloadThePage() {\n  const messageByLocalStorage = localStorage.getItem('message');\n  // якщо не пустий рядок то виводим збережений месседж (наприклад юзер не заповнив текстареа то буде null - нам не треба його виводити в текстареа)\n  if (messageByLocalStorage) {\n    textarea.value = messageByLocalStorage;\n  }\n}\n\nMessageGoBackAfterReloadThePage();\n\n// під час відправки форми - видаляємо месседж з текстареа та з localStorage\nform9.addEventListener('submit', handleMessage);\nfunction handleMessage(event) {\n  event.preventDefault();\n  // textarea.value = \"\";\n  event.currentTarget.reset();\n  localStorage.removeItem('message');\n}\n// ex\n// Implement: 1)shop item on page by array of objects 2) the basket (other html page) where we can add items 3)\nconst jewelry = [\n  {\n    id: 1,\n    name: 'Double Row Hinged Bangle',\n    price: 8800,\n    brand: 'Tyffany&Co',\n    description: 'in Rose Gold',\n    year: 2024,\n    pic: '../images/double-row-hinged-bangle.jpg',\n  },\n  {\n    id: 2,\n    name: 'Milgrain Band Ring',\n    price: 7980,\n    brand: 'Tyffany&Co',\n    description: 'in Platinum with Diamonds, 3.2mm Wide',\n    year: 2024,\n    pic: '../images/milgrain-band-ring.jpg',\n  },\n  {\n    id: 3,\n    name: 'Earrings',\n    price: 4200,\n    brand: 'Tyffany&Co',\n    description: 'Earrings in 18k rose gold with round brilliant diamonds.',\n    year: 2024,\n    pic: '../images/earrings.jpg',\n  },\n];\nconst LS_KEY = 'basket';\nconst container9 = document.querySelector('.js-list');\n// 1)відмальовуємо товари\nfunction createMarkup9(arr) {\n  return arr\n    .map(\n      ({ id, name, price, brand, description, year, pic }) => `\n        <li class=\"item-card js-product\" data-id=\"${id}\">\n        <div class=\"shop-div-pic\"><img src=\"${pic}\" width=\"450\" height=\"450\" alt=\"${name}\"/></div>\n        <div class=\"composition-text\">\n        <h4>${name}</h4>\n        <p>By ${brand}</p>\n        <p>${description}</p>\n        <p>Price:${price}$</p>\n        <p>Year of product ${year}</p>\n        <button class=\"btn-add-basket js-btn\">Add to the basket</button>\n        </div>\n        </li>\n        `\n    )\n    .join('');\n}\ncontainer9.insertAdjacentHTML('beforeend', createMarkup9(jewelry));\n// 2)делегуємо події на всьому списку карток\n// target єлемент по якому клікнули\n// currentTarget батьківський контейнер на якому висить слухач події\ncontainer9.addEventListener('click', handleAddToTheBasket);\nfunction handleAddToTheBasket(event) {\n  // 3) наповнюємо ключ \"basket\" в localStorage масивом обраних карток\n  // перевіряєм якщо є клас js-btn(кнопка) тоді додаємо до корзини картку\n  if (!event.target.classList.contains('js-btn')) {\n    return;\n  } else {\n    // отримуємо батьківський елемент кнопки по якій клікнули - лішку\n    const parentItem = event.target.closest('.js-product');\n    // витягаємо з нього значення data-id\n    const itemId = +parentItem.dataset.id;\n    console.log(itemId);\n    // отримуємо весь об*єкт за знайденим id\n    const currentProduct = jewelry.find(({ id }) => id === itemId);\n    console.log(currentProduct);\n    // отримуєм дані з localStorage - так як корзина може бути порожня - буде null(бо нічого не додано) || [] (поверне порожній масив щоб не повертати null)\n    const productsArr = JSON.parse(localStorage.getItem(LS_KEY)) || [];\n    console.log(productsArr);\n    // далі звертаємось до масиву і шукаємо індекс картки товару, якщо його немає (порожній масив) -findIndex  поверне -1\n    const indexByProductInArray = productsArr.findIndex(\n      ({ id }) => id === itemId\n    );\n    // якщо масив товарів пустий - додаєм цей товар\n    if (indexByProductInArray === -1) {\n      currentProduct.quantity = 1;\n      productsArr.push(currentProduct);\n      // якщо товар є - звертаємось до об*жєкту по його індексу і збільшуємо його quantity в масиві (кошику)\n    } else {\n      productsArr[indexByProductInArray].quantity += 1;\n    }\n    // add array of Products in localStorage\n    localStorage.setItem(LS_KEY, JSON.stringify(productsArr));\n  }\n}\n// 3) Працюємо зі сторінкою корзини. переходимо у файл /js/basket-9modul.js Переміщаємо дані з localStorage на сторінку html корзини\n\n// JSON – стандартний формат обміну даними між сервером та клієнтом. Дуже схожий на звичайні об'єкти JS, але ключі завжди в лапках. Для перетворення об'єкта чи масива в JSON-рядок використовується метод JSON.stringify(obj). Для зворотнього перетворення - JSON.parse(jsonString). JSON є основою для роботи з API та обміну даними в сучасних додатках.\n// Для зберігання даних прямо у браузері використовують localStorage та sessionStorage. Першій зберігає дані навіть після закриття вкладки чи браузера, а другий - тільки поки відкрита вкладка. Використання вебсховища є корисним для створення зручного UX.\n// Модульність дозволяє розбивати код на окремі, незалежні блоки, що полегшує його читабельність та масштабування. Це ключ до чистого та підтримуваного коду. Завдяки використанню import та export ми можемо розділяти проєкт на невеликі файли.\n// Збірщики – це інструменти, які об’єднують різні файли вашого проєкту в один (або кілька) для більш ефективного завантаження у браузер. Уявіть, що у вас є багато файлів JavaScript, CSS, зображень тощо. Збірщик оптимізує їх, видаляє зайве та мінімізує для швидкої роботи вашого додатка в продакшені.\n// Одними з найпопулярніших збірщиків є Webpack, Vite, Parcel.\n","'use strict';\n//                                         the information from mentor\n// Делегування подій – потужна техніка для оптимізації роботи з подіями. Замість того, щоб призначати події кожному елементу окремо, ми можемо призначити обробник події спільному предку, а подія \"спливатиме\" через DOM. Це зручно, коли у нас є багато однотипних елементів або елементи додаються динамічно.\n// Основні підходи до делегування подій включають:\n// Використання event.target для перевірки цільового елемента, через nodeName.\n// document.querySelector('ul').addEventListener('click', function(event) {\n//   // Перевіряємо, чи подія відбулася на елементі <li>\n//   if (event.target.nodeName === 'LI') {\n//     console.log('Натиснуто на елемент списку:', event.target.textContent);\n//   }\n// });\n// Використання класів або атрибутів для точного визначення елемента.\n// document.querySelector('.parent').addEventListener('click', function(event) {\n//   // Перевіряємо, чи елемент має клас 'button'\n//   if (event.target.classList.contains('button')) {\n//     console.log('Натиснуто на кнопку:', event.target.textContent);\n//   }\n// });\n// Використання методу closest() для роботи з ієрархією DOM.\n// document.querySelector('.container').addEventListener('click', function(event) {\n// // Шукаємо найближчого предка елемента, що відповідає певному селектору\n//   const button = event.target.closest('.button');\n//   if (button) {\n//     console.log('Натиснуто на кнопку:', button.textContent);\n//   }\n// });\n// Бібліотеки в JS допомагають спростити складні або рутинні операції. Ви можете знайти багато цікавих і корисних бібліотек для вирішення своєї задачі, використовуючі такі популярні ресурси, як cdn чи npm, або просто погугливши (тут ви обов’язково знайдете потрібне рішення).\n// Документація до бібліотеки зазвичай поділяється на кілька основних розділів. Важливо вміти з нею працювати, щоб швидко знайти потрібну інформацію: Огляд, Інсталяція, Використання, API Reference, Параметри, Приклади.\n// Деструктуризація — це зручний спосіб \"розпаковки\" значень з масивів або властивостей з об’єктів у змінні. Вона спрощує код, особливо коли потрібно працювати з великими масивами чи об'єктами.\n// :pushpin: Важливі моменти:\n// Розберіться, як працюють обробники подій і чому делегування подій може бути корисним у певних ситуаціях.\n// Починайте читати документацію бібліотек, це не так просто як може здатись, але до цього необхідно звикати\n\n// ..........................................................event propagation\n// Поширення подій (event propagation) — це термін, що описує життєвий цикл події, який має три етапи:\n//  Занурення (capture phase) - подія починається на window і тоне (проходить через усі елементи-предки) до найглибшого цільового елемента, на якому відбулася подія і етап на цьому елементі закінчується.\n//  Таргетинг (target phase) - Цей етап містить тільки повідомлення елемента про те, що на ньому відбулася дія.\n// //  Спливання (bubble phase) - кінцева фаза, подія спливає від найглибшого, цільового елемента, через усі елементи-предки до window.\n// <div id=\"parent\">\n//   Parent\n//   <div id=\"child\">\n//     Child\n//     <div id=\"descendant\">Descendant</div>\n//   </div>\n// </div>\n// Спливання гарантує, що клік по #descendant викличе обробник кліка в такому порядку:\n// спочатку на самому #descendant -> потім на елементі #child -> далі на елементі #parent -> і так далі, вгору по ланцюжку предків до window.\n// //   ................................................Цільовий елемент\n// Цільовий елемент — це елемент, на якому відбулася подія, він доступний як event.target. Це завжди найглибший елемент, з якого починається спливання.\n\n// event.target — це посилання на вихідний елемент, на якому відбулася подія, у процесі спливання вона — незмінна.\n// event.currentTarget — це посилання на поточний елемент, до якого прив’язаний поточний обробник події, і до якого в результаті спливання дійшла прослуховувана подія.\n\n// важливо розуміти різницю між елементом, де подія фактично відбулася (event.target), та елементом, до якого подія спливла, і обробник її перехопив (event.currentTarget).\n\n//                                             Припинення спливання\n// Зазвичай подія буде спливати вгору до елемента window, викликаючи всі наявні обробники на своєму шляху.\n// // Будь-який проміжний обробник може зупинити спливання цієї події за допомогою методів об’єкта події (event):\n// event.stopPropagation()\n//    -Зупиняє \"спливання\" події в DOM-дереві. Це означає, що жоден батьківський елемент не зможе відловити цю подію.\n//    - Не заважає іншим обробникам подій виконуватися на тому ж самому елементі.\n// event.stopImmediatePropagation()\n//     -Зупиняє \"спливання\" події так само, як event.stopPropagation().\n//     - зупиняє виконання всіх інших обробників подій, які слухають цю ж подію на даному елементі, навіть якщо вони були зареєстровані перед цим.\n\n//     // !!!!!!!!!!!!!Не припиняйте спливання без необхідності.\n//  Припинення спливання створює свої підводні камені, які потім доводиться обходити. Наприклад, вебаналітика використовує спливання, щоб відстежувати дії користувача на сторінці, тому якщо зупинити спливання подій, то це унеможливить збір цієї інформації.\n\n// //                                                    Делегування подій\n// Делегування реалізується у три прості кроки.\n// 1. Визначити спільного предка групи елементів для відстеження подій.\n// 2. Зареєструвати на елементі-предку обробник події, яку ми хочемо відловлювати з групи елементів.\n// 3. В обробнику використовувати event.target для вибору цільового елемента, на якому безпосередньо відбулась подія.\n//                               Перевірка типу цільового елемента події - властивість nodeName.\n// Перевіряти цільовий елемент події під час делегування треба,об виключити обробку подій для непотрібних типів елементів\n// ex В обробнику події кліка використовуємо event.target, щоб отримати елемент, на якому безпосередньо відбулася подія, і пов'язаний з ним колір. Інформацію про колір будемо зберігати в атрибуті data-color.\n// Обов'язково перевіряємо цільовий елемент події click.\n// Це точно має бути кнопка, в іншому разі ми випадково можемо обробити клік, коли користувач клікне між кнопками, що може викликати помилку.\nconst colorPalette = document.querySelector('.color-palette');\nconst outputColor = document.querySelector('.output-text');\n\ncolorPalette.addEventListener('click', selectColor);\n\n// This is where delegation «magic» happens\nfunction selectColor(event) {\n  console.log(event.target.nodeName);\n\n  if (event.target.nodeName !== 'BUTTON') {\n    return;\n  }\n\n  const selectedColor = event.target.dataset.color;\n  console.log(selectedColor);\n  outputColor.textContent = `The selected color is ${selectedColor}`;\n}\n\n// Some helper functions to render palette items\ncreatePaletteItems();\n\nfunction createPaletteItems() {\n  const items = [];\n  for (let i = 0; i < 50; i++) {\n    const color = getRandomHexColor();\n    const item = document.createElement('button');\n    item.type = 'button';\n    item.dataset.color = color;\n    item.style.backgroundColor = color;\n    item.classList.add('item');\n    items.push(item);\n  }\n  colorPalette.append(...items);\n}\n\nfunction getRandomHexColor() {\n  const letters = '0123456789ABCDEF';\n  let color = '#';\n\n  for (let i = 0; i < 6; i++) {\n    color += letters[Math.floor(Math.random() * 16)];\n  }\n\n  return color;\n}\n\n//                                             Бібліотека\n// Бібліотеки — це набір попередньо написаних функцій, методів і класів, який надає розробнику готові інструменти для вирішення певних завдань.\n// // Приклади популярних бібліотек у JavaScript:\n// Chart.js: Бібліотека для створення інтерактивних графіків і діаграм.\n// Lodash: Бібліотека для роботи з масивами, об'єктами, рядками тощо, що надає безліч зручних функцій.\n\n// Важливо обирати бібліотеки, які найкраще підходять для вашого проєкту, і стежити за їхніми оновленнями, щоб використовувати останні покращення та виправлення помилок.\n//                                                 CDN\n// CDN (Content Delivery Network) — це географічно розподілена мережева інфраструктура. Вона забезпечує швидку доставку контенту (такого як стилі, скрипти, зображення та інші ресурси) користувачам вебсервісів і сайтів. Сервери, що входять до складу CDN, географічно розташовуються в різних частинах світу таким чином, щоб зробити час відповіді для користувачів сайту/сервісу мінімальним.\n\n//                                                 Деструктуризація\n// Деструктуризація (Destructuring) — це особливий синтаксис, що дозволяє витягти значення зі структур даних, такі як об'єкти або масиви, і присвоїти їх змінним. Це зручний спосіб дістати потрібні дані зі складних структур і використовувати їх у коді.\n// Після ключового слова const або let ставимо фігурні дужки, як і у випадку з оголошенням об'єкта.\n\n// Усередині дужок, через кому, вказуємо імена змінних, яким будуть задані відповідні значення властивостей деструктуризованого об’єкта.\n// const book = {\n//     title: \"The Last Kingdom\",\n//     author: \"Bernard Cornwell\",\n//     genres: [\"historical prose\", \"adventure\"],\n//     isPublic: true,\n//     rating: 8.38,\n//   };\n\n//   // Деструктуризуємо\n//   const { title, author, isPublic, rating } = book;\n\n// Використовуємо\n//   const accessType = isPublic ? \"pulbic\" : \"private\";\n//   const message = `Book ${title} by author ${author} with rating ${rating} is in ${accessType} access!`;\n// Деструктуризація завжди знаходиться в лівій частині операції присвоювання.\n// Змінним усередині фігурних дужок присвоюються значення однойменних властивостей об'єкта з відповідними іменами.\n// Послідовність оголошення змінних у фігурних дужках не важлива.\n\n//                                               Деструктуризація неіснуючих властивостей\n// Коли в об'єкті немає властивості з таким ім'ям, змінній буде присвоєно undefined.\n\n// З метою уникнення присвоєння undefined під час деструктуризації неіснуючих властивостей, можна задати змінним значення за замовчуванням, використовуючи знак =. Це значення буде присвоєно тільки у випадку, коли в об'єкті відсутня властивість із таким ім'ям.\n\n// const book = {\n//   title: \"The Last Kingdom\",\n//   author: \"Bernard Cornwell\",\n// };\n\n// // Додамо зображення обкладинки, якщо вона відсутня в об'єкті книги\n// const {\n//   title,\n//   author,\n//   coverImage = \"https://via.placeholder.com/640/480\"\n// } = book;\n\n// console.log(title); // \"The Last Kingdom\"\n// console.log(author); // \"Bernard Cornwell\"\n// console.log(coverImage); // \"https://via.placeholder.com/640/480\"\n\n//                                         Перейменування змінної\n\n// Під час деструктуризації можна перейменувати змінну, в яку розпаковується значення властивості, використовуючи :.\n\n// const book = {\n//   title: \"The Last Kingdom\",\n//   author: \"Bernard Cornwell\",\n//   genres: [\"historical prose\", \"adventure\"],\n//   isPublic: true,\n//   rating: 8.38,\n// };\n\n// // Деструктуризуємо\n// const { title, author: bookAuthor, isPublic, rating: bookRating } = book;\n// console.log(title); // \"The Last Kingdom\"\n// console.log(bookAuthor); // \"Bernard Cornwell\"\n// console.log(isPublic); // true\n// console.log(bookRating); // 8.38\n//                                              Значення за замовчуванням\n// При перейменуванні змінної, в яку ми розпаковуємо значення властивості об'єкта, також можна присвоїти значення за замовчуванням.\n\n// Для цього після нового імені ставимо дорівнює = і вказуємо її значення за замовчуванням.\n\n// const book = {\n//   title: \"The Last Kingdom\",\n//   coverImage:\n//     \"https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg\",\n// };\n\n// const {\n//   title,\n//   coverImage: bookCoverImage = \"https://via.placeholder.com/640/480\",\n// } = book;\n\n// console.log(title); // \"The Last Kingdom\"\n// console.log(bookCoverImage); // \"https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg\"\n\n// // Якщо така властивість існує в об'єкті, у змінну буде присвоєно її значення.В іншому випадку змінній буде присвоєно значення за замовчуванням.\n\n// //                                                  Деструктуризація в циклах\n// // Під час ітерації по масиву об'єктів циклом for...of відбуваються багаторазові звернення до властивостей об'єкта.\n//   for (const book of books) {\n//     console.log(book.title);\n//     console.log(book.author);\n//     console.log(book.rating);\n//   }\n// //   Для того щоб скоротити кількість повторень, можна деструктуризувати властивості об'єкта в локальні змінні в тілі циклу.\n// for (const book of books) {\n//     const { title, author, rating } = book;\n\n//     console.log(title);\n//     console.log(author);\n//     console.log(rating);\n//   }\n// // Якщо об'єкт містить небагато властивостей, деструктуризацію можна виконати безпосередньо в місці оголошення змінної book.\n// for (const { title, author, rating } of books) {\n//     console.log(title);\n//     console.log(author);\n//     console.log(rating);\n//   }\n//                                          Деструктуризація параметрів\n// Під час передачі об'єктів у функції, можна деструктуризувати об'єкти\n//        Без деструктуризації об'єкта:\n// function printUserInfo(user) {\n//     console.log(`Name: ${user.name}, Age: ${user.age}, Hobby: ${user.hobby}`);\n//   }\n\n//   printUserInfo({\n//       name: \"Alice\",\n//       age: 25,\n//       hobby: \"dancing\"\n//   }); // Name: Alice, Age: 25, Hobby: dancing\n\n// //         З деструктуризацією об'єкта в тілі функції:\n// function printUserInfo(user) {\n// const { name, age, hobby } = user\n//   console.log(`Name: ${name}, Age: ${age}, Hobby: ${hobby}`);\n// }\n\n// printUserInfo({\n// \tname: \"Alice\",\n// \tage: 25,\n// \thobby: \"dancing\"\n// }); // Name: Alice, Age: 25, Hobby: dancing\n\n// //          з деструктуризацією об'єкта в місці оголошення параметрів:\n// function printUserInfo({ name, age, hobby }) {\n//   console.log(`Name: ${name}, Age: ${age}, Hobby: ${hobby}`);\n// }\n\n// printUserInfo({\n// \tname: \"Alice\",\n// \tage: 25,\n// \thobby: \"dancing\"\n// }); // Name: Alice, Age: 25, Hobby: dancing\n//                                                Патерн «Об'єкт параметрів»\n// Якщо функція приймає більше 2-3 параметрів, дуже просто заплутатися, в якій послідовності і що передавати.\n// Патерн «Об'єкт параметрів» допомагає вирішити цю проблему.\n\n// Він заміняє набір параметрів всього одним — об'єктом з іменованими властивостями.\n\n// function doStuffWithBook(book) {\n//   // Робимо щось з властивостями об'єкта\n//   console.log(book.title);\n//   console.log(book.pages);\n//   // І так далі\n// }\n\n// // Таким чином, під час її виклику передаємо один об'єкт з необхідними властивостями.\n// // ✅ Все зрозуміло\n// doStuffWithBook({\n//   title: \"The Last Kingdom\",\n//   pages: 736,\n//   downloads: 10283,\n//   rating: 8.38,\n//   isPublic: true,\n// });\n\n// // Ще одна перевага в тому, що можна деструктуризувати об'єкт у параметрі book. Це можна зробити в тілі функції.\n// function doStuffWithBook(book) {\n//   const { title, pages, downloads, rating, isPublic } = book;\n//   console.log(title);\n//   console.log(pages);\n// }\n\n// // Або в сигнатурі (підписі) функції — різниці немає.\n// function doStuffWithBook({ title, pages, downloads, rating, isPublic }) {\n//   console.log(title);\n//   console.log(pages);\n// }\n\n//                                     //  Глибока деструктуризація\n// // Найчастіше дані будуть представлені об'єктами з більш ніж одним рівнем вкладеності.\n\n// // 1)Для деструктуризації властивостей вкладених об'єктів використовуються ті самі принципи. Для початку напишемо код деструктуризації властивостей об'єкта користувача.\n// const user = {\n//   name4: \"Jacques Gluke\",\n//   tag4: \"jgluke\",\n//   stats: {\n//     followers2: 5603,\n//     views: 4827,\n//     likes: 1308,\n//   },\n// };\n\n// const { name4, tag4, stats } = user;\n\n// console.log(name3); // Jacques Gluke\n// console.log(tag3); // jgluke\n// console.log(stats); // { followers: 5603, views: 4827, likes: 1308 }\n// // 2) Tепер додамо глибоку деструктуризацію властивостей об'єкта stats.\n// // Для цього в деструктуризації після імені властивості ставимо двокрапку : та починаємо деструктуризацію об'єкта для цієї властивості.\n// const {\n//     name,\n//     tag,\n//     stats: { followers2, views, likes },\n//   } = user;\n\n//   console.log(name); // Jacques Gluke\n//   console.log(tag); // jgluke\n//   console.log(followers); // 5603\n//   console.log(views); // 4827\n//   console.log(likes); // 1308\n\n// //   Під час глибокої деструктуризації також можна змінювати імена змінних і присвоювати значення за замовчуванням, використовуючи вже знайомий тобі синтаксис.\n\n//   const {\n//     name3,\n//     tag3,\n//     stats: { followers = 0, views: userViews = 0, likes: userLikes = 0 },\n//   } = user;\n// //                                           Деструктуризація масивів\n// // Синтаксис\n// // Деструктуризоване присвоювання можна використовувати  для масивів, але з деякими особливостями.\n// // Змінним, зазначеним у квадратних дужках [], будуть послідовно присвоюватися значення елементів масиву.\n// const color = [200, 255, 100];\n// const [ red, green, blue ] = color;\n\n// console.log(`rgb(${red}, ${green}, ${blue})`); // “rgb(200, 255, 100)\"\n// //                                               Значення за замовчуванням\n// // Якщо змінних оголошено більше, ніж елементів масиву, їм буде присвоєно undefined. Щоб запобігти цьому, можна вказувати значення за замовчуванням.\n// // Синтаксис: після імені змінної ставимо = і значення за замовчуванням.\n\n// const color2 = [200, 100, 255];\n// const [ red2, green2, blue2, alfa = 0.3 ] = color2;\n\n// console.log(rgba(${red2}, ${green2}, ${blue2}, ${alfa})); // “rgba(200, 255, 100, 0.3)\"\n\n//                                                       Часткова деструктуризація\n// Іноді з масиву необхідно деструктуризувати тільки перші N елементів, а інші зберегти в одну змінну у вигляді масиву.\n\n// Деструктуризуючи масив, можна розпакувати перші необхідні елементи і присвоїти іншу частину елементів масиву змінній, використовуючи операцію ...rest.\n// const color = [200, 255, 100];\n\n// const [ red, ...otherColors ] = color;\n\n// console.log(red); // 200\n// console.log(otherColors); // [255, 100]\n\n// При цьому оригінальний масив не змінюється, у змінній otherColor буде новий масив із копіями зібраних значень.\n\n// З об'єктами, до речі, це теж працює. Можна деструктуризувати певні властивості в окремі змінні, а решту зібрати в новий об'єкт.\n// const user = {\n// \tname: \"Jacob\",\n// \tage: 32,\n// \temail: \"j.cob@mail.com\",\n// \tisOnline: true\n// };\n\n// const { name, isOnline, ...otherProps } = user;\n// console.log(name); // \"Jacob\"\n// console.log(isOnline); // true\n// console.log(otherProps); // {age: 32, email: \"j.cob@mail.com\"}\n\n// При цьому оригінальний об'єкт не змінюється, у змінній otherProps буде новий об'єкт із копіями зібраних властивостей.\n//                                       Пропуск значень\n// На відміну від іменованих властивостей об'єкта, елементи масиву — це набір індексованих значень. Якщо необхідно деструктуризувати тільки, наприклад, третій елемент, перші два необхідно пропустити.\n\n// Припустимо, з масиву color необхідно взяти тільки останнє значення. Для цього в деструктуризації необхідно відокремити комами елементи, що пропускаються.\n// const rgb = [200, 100, 255];\n\n// const [, , blue] = rgb;\n\n// console.log(`Blue: ${blue}`); // \"Blue: 255\"\n//                                             Деструктуризація параметрів\n// Під час передачі масиву у функцію, можна деструктуризувати його елементи.\n\n// Без деструктуризації:\n// function printFruits(fruits) {\n//   console.log(fruits[0], fruits[1], fruits[2]);\n// }\n// printFruits([\"apple\", \"banana\", \"orange\"]); // \"apple banana orange\"\n\n// Із деструктуризацією в місці оголошення параметрів:\n// function printFruits([firstFruit, secondFruit, thirdFruit]) {\n//   console.log(firstFruit, secondFruit, thirdFruit);\n// }\n// printFruits([\"apple\", \"banana\", \"orange\"]); // \"apple banana orange\"\n\n//                                            Practice\n// Event deligation - addEventListener on father element and and automatically get an event handler (обробник подій, функція) on his children\n// ex\nconst container = document.querySelector('.parent-box');\n// for example like we don't know about the event deligation we must addEventListener for everyone children in the parent element - так не роблять це не оптимально\n// розгорнули ...rest оперетором із псевдомасиву дітей у масив дітей\n// console.log([...container.children]);\n\n// [...container.children]\n// .forEach(box => {box.addEventListener(\"click\", handleClick)});\n// function handleClick(event) {\n//      console.log(\"You addEventListener for everyone children in the parent element but you can use Event deligation that don't do it\");\n//     const color = event.target.dataset.color;\n//     console.log(`The color of this box is ${color}`);\n\n// }\n// comlete this task with Event deligation\ncontainer.addEventListener('click', handleClick);\nfunction handleClick(event) {\n  // робим перевірку якщо клікнули не на дів то припинити роботу ф-ції\n  if (!event.target.classList.contains('box')) {\n    return;\n  }\n\n  console.log(event.target.nodeName);\n  // currentTarget - елемент на якому викликали addEventListener\n  console.log(event.currentTarget);\n  // target - елемент на якому відбулась подія click\n  console.log(event.target);\n\n  // берем колір із data атрибута\n  const color = event.target.dataset.color;\n  console.log(`The color of this box is ${color}`);\n}\n\n//                                                               PRACTICE\n//..................... METHOD SEARCHE THE NAME OF CLASS IN HTML BY PARCIALY (ЧАСТИНОЮ) NAME\nconst kittyElementBtn = document.querySelector(\"[class *= 'kitty-go']\");\nconsole.log(kittyElementBtn);\nkittyElementBtn.style.setProperty('color', 'red');\n// події які не спливають (нема фази capturing phase):\n// -focus\n// -blur\n// -load\n\n// EX Show in output zone the value of input meanwhile (під час) button \"Show me\" is pressing\nconst inputShow = document.querySelector('.input-show');\nconst btnShow = document.querySelector('.btn-show');\nconst btnClear = document.querySelector('.btn-clear');\nconst spanOutput = document.querySelector('.output-show');\n\nbtnShow.addEventListener('click', handleShow);\nfunction handleShow(event) {\n  spanOutput.textContent = inputShow.value;\n  console.log(`${inputShow.value}`);\n}\n\nbtnClear.addEventListener('click', handleClear);\nfunction handleClear(event) {\n  inputShow.value = '';\n  spanOutput.textContent = '';\n}\n\n// ex The value of input need change on dote (крапки) and change the textContent of button on \"Show\" meanwhile the button \"Hide\"  is pressing\n//             за замовчуванням якщо в інпуті стоїть тип password - символи приховуються\n// console.dir(елемент) показує об*єкти тегів що є на елементі\nconst inputAlert = document.querySelector('#alertInput');\nconst btnAlert = document.querySelector('#alertButton');\nconsole.dir(inputAlert);\nbtnAlert.addEventListener('click', handleChange);\n\nfunction handleChange(event) {\n  if (inputAlert.type === 'text') {\n    btnAlert.textContent = 'Show';\n    inputAlert.type = 'password';\n  } else if (inputAlert.type === 'password') {\n    btnAlert.textContent = 'Hide';\n    inputAlert.type = 'text';\n  }\n}\n\n// EX The button \"Decrease\"(зменшити) must to decrease the size by div on 10px. The button \"Increase\"(збільшити) must to increase the size by div on 10px.\nconst boxBySize = document.querySelector('#box');\nconst btnDecrease = document.querySelector('#decrease');\nconst btnIncrease = document.querySelector('#increase');\n// offsetWidth - значення поточної ширини обраного елемента в console.dir()\n// offsetHeight\nconsole.dir(boxBySize);\nbtnDecrease.addEventListener('click', handleDecrease);\nfunction handleDecrease(event) {\n  boxBySize.style.width = `${boxBySize.offsetWidth + 10}px`;\n  boxBySize.style.height = `${boxBySize.offsetHeight + 10}px`;\n}\nbtnIncrease.addEventListener('click', handleIncrease);\nfunction handleIncrease(event) {\n  boxBySize.style.width = `${boxBySize.offsetWidth - 10}px`;\n  boxBySize.style.height = `${boxBySize.offsetHeight - 10}px`;\n}\n// ex Double values in items meanwhile the button \"Double\" is pressing.\nconst listOfItems = document.querySelector('.list');\nconst btnDouble = document.querySelector('#double');\nconst itemAll = Array.from(document.querySelectorAll('.list-item'));\n\nbtnDouble.addEventListener('click', handleDouble);\nfunction handleDouble(event) {\n  itemAll.forEach(el => (el.textContent *= 2));\n}\n// ex Remuve seleckted items in form meanwhile (at the same time when в той час як) button \"Filter\" is pressed\n// коли є форма ми вішаємо слухача події на форму\nconst form = document.querySelector('.checkboxForm');\nform.addEventListener('submit', handleFormSubmit);\nconst divCheckbox = document.querySelectorAll('.checkboxWrapper');\nconsole.log(...divCheckbox);\n// const testCheckbox = document.querySelector(\"#test\")\n// console.dir(testCheckbox.checked === false);\n\nfunction handleFormSubmit(event) {\n  event.preventDefault();\n  //                                оберуться елементи у яких властивість checked === true\n  const checkboxTrue = [...divCheckbox].filter(\n    item => item.lastElementChild.checked\n  );\n  checkboxTrue.forEach(el => el.remove());\n}\n\n// EX Implement(реалізуй) search (filter) for first or last name in this list\nconst listContacts = document.querySelector('.contactsList');\nconst allContacts = [...listContacts.children];\nconst inputFilter = document.querySelector('.contactsFilter');\n\ninputFilter.addEventListener('input', handleFilter);\nfunction handleFilter(event) {\n  const inputVal = inputFilter.value;\n  const searchedItem = allContacts.filter(contact =>\n    contact.textContent.toUpperCase().includes(inputVal.toUpperCase().trim())\n  );\n  listContacts.innerHTML = '';\n  //                 розгорнули масив\n  listContacts.append(...searchedItem);\n}\n// wherePast.innerHTML = \" \" приймає і вставляє рядок\n// wherePast.append(вузол) приймає і вставляє вузол(елемент)\n\n// ex We have array of objects with popular movies and the search form by film's name.\n// 1. Users must saw the film's list as soon as the page has the firs load (title, year, reit, country).\n// Use the Template literals (неофіційно Template strings) (шаблонні рядки) and the method incertAdjacentHTML (\"beforeeend\", `Template literals`) for rendering markup.\n// 2. Implement the serching of film by name. Films stay in list which has full or partial coincidence (котрі мають повне або часткове співпадіння) by name, meanwhile the button \"Search\" is pressed.\nconst movieList = [\n  {\n    title: 'Movie 1',\n    genres: ['Action', 'Crime', 'Drama'],\n    rating: 9,\n    country: 'Australia',\n    year: 2019,\n  },\n  {\n    title: 'Movie 2',\n    genres: ['Action', 'Comedy'],\n    rating: 8,\n    country: 'USA',\n    year: 2017,\n  },\n  {\n    title: 'Movie 3',\n    genres: ['Drama', 'Horror'],\n    rating: 8.5,\n    country: 'Belgium',\n    year: 2020,\n  },\n  {\n    title: 'Movie 4',\n    genres: ['Crime', 'Drama'],\n    rating: 8.9,\n    country: 'France',\n    year: 2021,\n  },\n];\n\nconst moviesForm = document.querySelector('#searchForm');\nconst moviesList = document.querySelector('#moviesList');\nconst markupFilms = movieList\n  .map(\n    obj =>\n      `<li>><h2>The title:${obj.title}</h2> <p>The rating: ${obj.rating}</p> <p>The country: ${obj.country}</p> <p>The year:${obj.year}</p></li>`\n  )\n  .join();\nmoviesList.insertAdjacentHTML('beforeend', markupFilms);\n\nmoviesForm.addEventListener('submit', handleSearchFilm);\nfunction handleSearchFilm(event) {\n  event.preventDefault();\n  const itemFilms = [...moviesList.children];\n  const inputValue = event.currentTarget.searchInputByTitle.value.toLowerCase();\n\n  const filmCoincidenced = itemFilms.filter(item =>\n    item.textContent.toLocaleLowerCase().includes(inputValue)\n  );\n\n  moviesList.innerHTML = '';\n  moviesList.append(...filmCoincidenced);\n}\n\n// 2 варіант вирішення задачі - робимо пошук співпадінь (.filter) на вихідному масиві фільмів а не на масиві фільмів створеної розмітки\n","'use strict';\n// ........................................JavaScript у браузері\n// Коли JavaScript виконується у браузері, у нього є додатковий функціонал для роботи з вкладкою. Цей функціонал складається з таких модулів: ECMAScript, DOM, BOM.\n// - ECMAScript (скорочено ES) — це стандарт, який описує мову програмування JavaScript. Цей стандарт визначає синтаксис і семантику мови, а також набір вбудованих об'єктів і функцій для роботи з даними, текстом, датами та іншими аспектами програмування. ECMAScript надає основну структуру мови, на якій базується JavaScript. Різні версії JavaScript реалізуються через різні версії стандарту ECMAScript. Наприклад, ES5, ES6 (або ES2015), ES2016, ES2017 тощо — це різні версії ECMAScript,\n//  - Об'єктна модель документа (Document Object Model) — незалежний інтерфейс для роботи з HTML-документом. Ця модель містить набір властивостей і методів, що дозволяють шукати, створювати й видаляти елементи, реагувати на дії користувача і багато іншого, тобто поєднує сторінку з мовою програмування.\n//                    DOM — це відображення HTML-документа. Виглядає як деревоподібна структура, у якій кожен вузол — це JavaScript-об'єкт із властивостями та методами, що становить частину HTML-документа. Кожен елемент у документі, весь документ в цілому, заголовок, посилання, абзац — це частини DOM цього документа, тому всі вони можуть бути змінені з JavaScript-коду.\n// - Об'єктна модель браузера (Browser Object Model) — незалежний від мови інтерфейс для роботи з браузером. Містить набір властивостей і методів, що дозволяють отримати доступ до ряду функцій браузера. Саме завдяки BOM можна отримувати розміри вікна браузера, читати URL, працювати з історією навігації, місцем розташування тощо.\n// ..........................Як складається DOM-дерево?\n// Щоб відобразити HTML-документ, браузер спочатку перетворює його у формат, який він розуміє — DOM. Інтерпретатор браузера має спеціальний фрагмент коду — HTML-парсер, який використовується для перетворення HTML у DOM.\n// Браузер будує DOM поступово, щойно надходять перші фрагменти коду, він починає парсити HTML, додаючи вузли в деревоподібну структуру.Після того як DOM-дерево побудовано, у ньому можна знайти елемент за допомогою JavaScript. Оскільки кожен елемент має інтерфейс із безліччю властивостей і методів, з ним можна виконувати необхідні дії.\n\n// ......................................Пошук елементів\n// Група методів elem.querySelector* — це сучасний стандарт для пошуку елементів. Вони дозволяють знайти елемент або групу елементів за CSS-селектором.\n// Доступ до DOM починається з об'єкта document, з нього можна дістатися до будь-яких елементів. Об’єкт document — це частина глобального об'єкта window, який доступний у скрипті, коли він виконується в браузері. Так само як alert, console.log і багато інших.\n// ......................................Навігація по DOM\n// Елементи DOM-дерева мають ієрархічне відношення один до одного. Для опису відносин використовуються терміни предок (ancestor), нащадок (descendant), батько (parent), дитина (child) і сусід (sibling).\n\n// Найвищий елемент називається кореневим (root node).\n// Кожен елемент, крім кореневого, має тільки один батьківський.\n// В елемента може бути скільки завгодно дітей.\n// Сусіди — це елементи зі спільним батьківським елементом.\n// Дочірні елементи (діти) — елементи, що безпосередньо вкладені в поточний елемент (елементи першого рівня вкладеності).\n// Нащадки — усі елементи, які знаходяться в поточному елементі, разом з їхніми дітьми, дітьми їхніх дітей тощо. Тобто все на зразок дерева.\n\n//                                            element.querySelector(selector)\n// - Використовується, якщо необхідно знайти тільки один, найчастіше унікальний елемент.\n// - Повертає посилання на перший знайдений елемент усередині element, що відповідає рядку CSS-селектора selector.\n// - Якщо нічого не знайдено, то поверне null\nconst selector = document.querySelector('.header');\nconst image = document.querySelector('img');\nconsole.log(selector, image);\n\n//                                            element.querySelectorAll(selector)\n// - Використовується, якщо необхідно знайти колекцію елементів, тобто отримати масив посилань на елементи з однаковим селектором. Наприклад, усі елементи списку з класом list-item.\n// - Повертає псевдомасив усіх елементів всередині element, які відповідають CSS-селектору selector\n// - Якщо нічого не знайдено, поверне порожній масив\nconst allSelectors = document.querySelectorAll('img');\nconst allDivisions = document.querySelectorAll('.picture-div');\nconsole.log(allSelectors, allDivisions);\n// ...................................................Властивості та атрибути\n// Під час побудови DOM-дерева деякі стандартні HTML-атрибути стають властивостями елементів, тобто властивостями DOM-об’єктів.\n\n// Наприкладб якщо в HTML є <a></a>,то у JavaScript коді можна прочитати значення його атрибута href, отримавши посилання на елемент, тобто об'єкт, використовуючи querySelector, і звернутися до його властивості href. Значення атрибутів можна змінювати, перевизначивши їм нове значення прямо з JavaScript коду, і під час виконання скрипта значення в HTML, тобто в DOM-дереві, зміниться.\n// const link = document.querySelector(\".link\");\n// console.log(link.href); // \"https://goit.global\"\n// link.href = \"https://neo.goit.global\";\n// console.log(link.href); // \"https://neo.goit.global\"\n// .............................................................Властивість textContent\n// повертає весь текстовий контент усередині елементів (власних і вкладених елементів).\n// Для отримання текстового контенту елемента, як завжди, отримуємо посилання на елемент і звертаємося до властивості через крапку.\nconst header = document.querySelector('h1');\nconsole.log(header.textContent);\n// можем змінювати значення що поверне textContent і воно змінниться в HTML and DOM\n// header.textContent = \"Relax\";\n// console.log(header);\n\n// PSEUDO array -> метод Array.from(), який створить масив із псевдомасиву,\nconst spanHeader = Array.from(document.querySelectorAll('span'));\n// Array.isArray(те що перевірятиметься ) - використовують щоб перевірити що це масив, він поверне тру\nconsole.log(Array.isArray(spanHeader));\nconst arraySpanHeader = [];\nfor (const item of spanHeader) {\n  arraySpanHeader.push(item.textContent);\n}\nconsole.log(arraySpanHeader);\n\n// ..................................................властивысть el.children\n// поверне псевдомасив із всіма дітьми елемента\n// el.children[0] - поверне 1 дитину\n// ....властивість el.firstChild and el.lastChild поверне 1 /останній дочірній елемент\n// властивість el.childNode - поверне dв псевдомасиві  всі дочірні ел включаючі текстові ноди(пробіли #text)\n// el.previousElementSibling - поверне попередній елемент (той що вище у коді)\n//  el.nextElementSibling - поверне наступний ел (той що нижче у коді)\n//                                Властивість classList\n\n// Для того щоб із JavaScript коду прочитати, додати, видалити або перевірити наявність CSS-класу в елемента, у властивості classList зберігається об'єкт із методами для роботи з CSS-класами елемента.\n//         Властивість classList — це спеціальний тип об’єкта, який подібний до масиву. Зверни увагу, що він схожий, але не є нативним JavaScript-масивом, який ми вивчали раніше. Він зберігає в собі весь перелік класів DOM-елемента, властивість length і властивість value.\n\n// властивість value містить точне значення атрибута class\n// властивість length — кількість класів в елемента\nconst link = document.querySelector('img');\nconsole.log(link.classList);\n//                                                Метод classList.contains(className)\n// Метод очікує аргументом рядок з іменем класу та повертає true або false, залежно від наявності класу className в елемента.\n// Зверни увагу, що className передаємо як рядок без крапки (без селектора класу).\nconst hasActiveClass = link.classList.contains('title'); // false\n//                                                 Метод classList.add(className)\n// Метод очікує аргументом рядок з іменем класу та додає клас className до списку класів елемента.\n// Можна додавати більше одного класу, вказавши кілька аргументів через кому.\n//                                                 Метод classList.remove(className)\n// Метод очікує аргументом рядок з іменем класу та видаляє клас className зі списку класів елемента.\n//                                                 Метод classList.toggle(className)\n// Метод працює як перемикач:\n// якщо клас className відсутній, то додає його в кінець списку класів\n// і навпаки, якщо клас className присутній — видаляє його\n//                                                 Метод classList.replace(oldClassName, newClassName)\n// Метод очікує 2 аргументи рядка (перший — стара назва класу, другий — нова назва класу) та замінює існуючий клас oldClassName на вказаний newClassName.\n// !Якщо спробувати поміняти клас, якого не існує на елементі, то це не викличе помилку. Просто нічого не поміняється.\n\n// ................................................Властивість style\n// Властивість style використовується для читання та зміни вбудованих стилів з DOM-елементів. Вона повертає об'єкт, який містить список лише всіхВБУДОВАНИХ ВЛАСТИВОСТЕЙ (в HTML) елемента, а не увесь CSS.\n\n// Під час запису властивості вони записуються в camelCase нотації, замість дефісів, які зазвичай використовуються в CSS, тобто background-color перетворюється на backgroundColor.\n// На практиці стилізація елементів зазвичай виконується шляхом додавання CSS-класів.\n\n// !!!!Властивість style використовується для додавання будь-яких динамічних стилів, наприклад, якщо посилання на фонове зображення невідомо заздалегідь і приходить з бекенда.\n\n// ....................................................Доступ до атрибутів\n// - Метод element.hasAttribute(nameAttribute) - приймає один аргумент — рядок nameAttribute, який містить ім’я атрибута для перевірки та повертає результат перевірки його наявності на елементі element — true чи false.\nconsole.log(image.hasAttribute('src')); // true\n// - Метод element.getAttribute(nameAttribute) - меод отримує один аргумент — рядок nameAttribute з іменем атрибута, і повертає значення цього атрибута для вказаного HTML-елемента element. Якщо атрибут не знайдено, метод повертає null.\nconsole.log(image.getAttribute('alt'));\n// - Метод element.setAttribute(nameAttribute, value) - приймає два аргументи: рядок nameAttribute з іменем атрибута, який потрібно встановити або змінити, та value зі значенням, яке цьому атрибуту треба присвоїти. Метод встановлює або змінює значення зазначеного атрибута для вказаного HTML-елемента element.\nimage.setAttribute('alt', 'Amazing nature');\nconsole.log(image.getAttribute('alt')); // Amazing nature\n// - Метод element.removeAttribute(nameAttribute) - приймає один аргумент — рядок nameAttribute з іменем атрибута, який потрібно видалити зі вказаного HTML-елемента element — та видаляє його. Якщо зазначеного атрибута немає на елементі, метод не викликає жодних помилок та не робить нічого.\nimage.removeAttribute('alt');\nconsole.log(image.hasAttribute('alt')); // false\n// Отримати доступ або змінити значення деяких атрибутів елемента можна безпосередньо, звернувшись до них як до властивостей DOM-об'єкта. Це буде менш затратно за кількістю коду.\n\n// А ось видалити або перевірити наявність буде зручніше, використовуючи відповідний метод.\n\n// створюємо атрибут для елемента\n//  el = document.querySelector(`.className[href=\"значення атрибута\"]`);\n// ......................................................Власні атрибути\n// Власні data-атрибути -  дозволяють додати до тегу довільний атрибут і отримати його значення в JavaScript.  коли нам потрібно зберегти певну інформацію на тезі, наприклад, вказати тип дії кнопки, щоб потім у певний момент часу мати можливість отримати до неї доступ.\n/* <button type=\"button\" data-action=\"save\">Save text</button>\n<button type=\"button\" data-action=\"close\">Close editor</button> */\n//                                                         Отримання значень\n// Для отримання значення data-атрибута - властивість dataset, після якої через крапку пишеться ім'я атрибута без data-. Тобто data- відкидається, а інша частина імені записується як ім'я властивості об'єкта.\n// const saveBtn = document.querySelector('button[data-action=\"save\"]');\n// console.log(saveBtn.dataset.action); // \"save\"\n//                                                           Зміна значень\n// Змінити значення існуючого data-атрибута або додати новий можна так само, як і будь-якої іншої властивості об'єкта в JavaScript. Щоб це зробити, треба отримати доступ до DOM-елемента, а потім змінити/задати значення властивості в об'єкті dataset.\n// // Змінюємо значення data-action для кнопки saveBtn\n// saveBtn.dataset.action = \"update\";\n\n// // Додаємо новий data-атрибут data-role\n// saveBtn.dataset.role = \"admin\";\n//...................................................Створення та видалення елементів\n// DOM API (Document Object Model Application Programming Interface) має широкий функціонал. За його допомогою можна:\n// вибирати або змінювати вже існуючі елементи\n// видаляти елементи\n// створювати нові елементи й додавати їх у документ\n\n// Розглянемо, як створити новий елемент:\n// document.createElement(tagName)\n\n// створює елемент з ім'ям tagName і повертає посилання на його об’єкт як результат свого виконання.\n// tagName — це рядок, що вказує тип елемента, який створюється.\n// Елемент створюється в пам'яті, у DOM його ще немає.\n\n// const heading = document.createElement(\"h1\");\n// Після створення елемента heading отримуємо ПОСИЛАННЯ на його об’єкт у пам'яті. З цього моменту можна звертатися до властивостей цього об’єкта і змінювати їх ще до того, як вставимо цей елемент у DOM.\n\n// const heading = document.createElement(\"h1\");\n// heading.classList.add(\"title\");\n// heading.textContent = \"This is a heading\";\n// console.log(heading); // <h1 class=\"title\">This is a heading</h1>\n\n//                                                 Додавання елементів\n\n// Щоб створений елемент відображався на сторінці, його необхідно додати до вже існуючого елемента в DOM-дереві.\n\n// elem.append(el1, el2, ...) — додає один або декілька елементів після всіх дітей елемента elem.\n// elem.prepend(el1, el2, ...) — додає один або декілька елементів перед усіма дітьми елемента elem.\n\n// У всіх цих методах el — це елементи або рядки, у будь-якому поєднанні та кількості. Рядки додаються, як текстові вузли.\n// Зверни увагу! Якщо елемент для додавання вже знаходиться в DOM, то він видаляється зі свого старого місця й додається у нове. Отже, є правило: один і той самий елемент не може бути одночасно у двох місцях.\n//                                                         Видалення елементів\n//  метод element.remove().\n\n// <p class=\"text\">Random text content</p>\n\n// Він викликається на елементі element, який необхідно видалити.\n\n// const text = document.querySelector(\".text\")\n// text.remove();\n//        ......................................................Властивість innerHTML\n// Існує ще один спосіб створити DOM-елементи і помістити їх у DOM-дерево.Для цього треба використати рядки з тегами і дозволити браузеру зробити всю важку роботу.\n// Властивість innerHTML зберігає вміст елемента, включно з тегами, у вигляді рядка. Значення, що повертається, — це завжди валідний HTML-код.\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!Використовуй властивість element.innerHTML для додавання тільки у разі,\n// — коли елемент element порожній щоб не було додаткових витрат на повторне створення вже існуючої розмітки або\n// — якщо потрібно повністю замінити вміст element\n\n// Зміна\n// Властивість innerHTML доступна і для читання, і для запису. Якщо записати в неї рядок з HTML-тегами, то браузер під час парсингу рядка перетворить його у валідні елементи і додасть у DOM-дерево.\n\n// !!!!ростий і швидкий спосіб видалення всього вмісту - якщо у властивість innerHTML записати порожній рядок, то вміст елемента буде очищено.\n// // ..........Однотипна (шаблонна) розмітка створюється із масиву даних.\n// Прийом полягає в перебиранні цього масиву та створенні одного рядка з HTML-тегами, який потім записуємо в innerHTML елемента. Якщо ти будеш це робити за допомогою методу map(), не забудь, що він повертає масив. Отже, перед тим як додавати розмітку в DOM, цей масив треба привести до рядка за допомогою методу join()\n// HTML\n// <section>\n//   <h2>Popular technologies</h2>\n//   <ul class=\"list\"></ul>\n// </section>\n// Java Script\n// const technologies = [\"HTML\", \"CSS\", \"JavaScript\", \"React\", \"Node\"];\n// const list = document.querySelector(\".list\");\n\n// const markup = technologies\n//   .map((technology) => `<li class=\"list-item\">${technology}</li>`)\n//   .join(\"\");\n\n// // Check the console, you'll see a single string with HTML tags\n// console.log(markup);\n\n// // Adding all the markup in one operation\n// list.innerHTML = markup;\n\n// Нове значення для element.innerHTML повністю видалить і повторно створить усіх нащадків елемента element. Якщо елемент спочатку не був порожній, то виникнуть додаткові витрати на повторне створення вже існуючої розмітки, а це погано.\n// HTML і не порожній елемент артикль\n// <article class=\"article\">\n//   <h2>Article title</h2>\n// </article>\n// JavaScript\n// const article = document.querySelector(\".article\");\n// const htmlString = `<p class=\"article-text\">Nullam quis ante. Vestibulum dapibus nunc ac augue. In consectetuer turpis ut velit.</p>\n//    <a class=\"link\" href=\"#\">Read more...</a>`;\n\n// // Replace += with = operator. See the difference?\n// // Article title is lost because we overwrite element content.\n// article.innerHTML += htmlString;\n\n// Властивість innerHTML у JavaScript встановлює або отримує HTML-вміст елемента.\n\n//................................................Метод insertAdjacentHTML()\n// Метод insertAdjacentHTML() — це сучасний метод для додавання рядка з HTML-тегами перед, після або всередину елемента. Він вирішує проблему innerHTML з повторною серіалізацією вмісту елемента під час додавання розмітки до вже існуючої.\n\n// element.insertAdjacentHTML(position, string)\n\n// Аргумент position — це рядок, який визначає позицію щодо елемента element. Він приймає одне з чотирьох значень.\n\n// \"beforebegin\" — перед element\n// \"afterbegin\" — всередині element, перед усіма дітьми\n// \"beforeend\" — всередині element, після усіх дітей\n// \"afterend\" — після element\n\n// Значення \"beforebegin\" і \"afterend\" працюють тільки тоді, коли element вже знаходиться в DOM-дереві. Обмеження зумовлене тим, що неможливо дізнатися, куди вставляти розмітку, доти, доки елемент не буде перебувати в DOM-дереві.\n// HTML\n// <ul class=\"list\">\n//   <li class=\"list-item\">HTML</li>\n//   <li class=\"list-item\">CSS</li>\n//   <li class=\"list-item\">JavaScript</li>\n// </ul>\n// Java Script додаємо ще лішки після створених лішок і додаємо заголовок перед списком\n// const list = document.querySelector(\".list\");\n\n// const newTechnologies = [\"React\", \"TypeScript\", \"Node.js\"];\n// const markup = newTechnologies\n//   .map((technology) => `<li class=\"list-item new\">${technology}</li>`)\n//   .join(\"\");\n\n// list.insertAdjacentHTML(\"beforeend\", markup);\n// list.insertAdjacentHTML(\"beforebegin\", \"<h2>Popular technologies</h2>\");\n\n// ЕХ створюємо та додаємо новий пункт меню\n//              створ лышку ы додали клас\nconst navItemElement = document.createElement('li');\nnavItemElement.classList.add('nav-item');\n// створ посилання ы додали атрибут та класс і додали текст в тег а\nconst navItemLink = document.createElement('a');\nnavItemLink.href = 'https://github.com/Vi-Kovalska';\nnavItemLink.classList.add('nav-item-link');\nnavItemLink.textContent = 'Click me';\n// вкладаємо тег а в тег li\nnavItemElement.append(navItemLink);\n// отримуємо тег ul щоб додати туди тег li>a\nconst menu = document.querySelector('ul');\n// додаєм створений тег li в список ul\nmenu.append(navItemElement);\n\n// EX на основі масиву об*єктів  у <div class=\"color-picker\"></div> створюєм тег button для кожного обєкта з назвою що міститься у label\nconst options = [\n  { label: 'darkred', color: '#8b0000' },\n  { label: 'greenyellow', color: '#adff2f' },\n  { label: 'brown', color: '#a52a2a' },\n  { label: 'orchid', color: '#da70d6' },\n];\n// // отримуємо дів ел\n// const divContainer = document.querySelector(\".color-picker\")\n// //           перебираєм масив і витягаємо значенння із об*єкту\n// const elements = options.map(option => {\n//      //         створюєм кнопку\n// const buttonEl = document.createElement(\"button\");\n// buttonEl.classList.add(\"btn-color\")\n// //                додаєм текст для кнопки із властивості об*єкту\n// buttonEl.textContent = option.label;\n// //             додаєм колір кнопки із властивості об*Єкту\n// buttonEl.style.backgroundColor = option.color;\n// return buttonEl;\n// });\n// console.log(elements);\n// // додаємо елементи методом .append() розгорнувши спред оператором значення із масиву\n// divContainer.append(...elements);\n\n// EX переписуєм попередній код у функцію щоб автоматизувати\n// const divContainer = document.querySelector(\".color-picker\")\nconst divContainer = document.querySelector('.color-picker');\nconst createButtons = array => {\n  return array.map(option => {\n    const buttonEl = document.createElement('button');\n    buttonEl.classList.add('btn-color');\n\n    buttonEl.textContent = option.label;\n\n    buttonEl.style.backgroundColor = option.color;\n    return buttonEl;\n  });\n};\ndivContainer.append(...createButtons(options));\n\n// EX є шапка таблиці в HTML,  в JavaScript дописуємо дані в таблицю взявши їх з масиву об*єктів\nconst allKeys = Array.from(document.querySelectorAll('th'));\nconst textForAllKeys = allKeys.map(key => key.textContent);\nconsole.log(textForAllKeys.join(' '));\n\nconst accounts = [\n  {\n    id: 509766,\n    amount: 3900,\n    date: '24.03.2014',\n    who: 'Arnold',\n    transactionType: 'deposit',\n    accountName: 'hfhdjfhj',\n    accountNumber: 9548976,\n  },\n  {\n    id: 509766,\n    amount: 3900,\n    date: '24.03.2014',\n    who: 'Arnold',\n    transactionType: 'invoice',\n    accountName: 'hfhdjfhj',\n    accountNumber: 9548976,\n  },\n  {\n    id: 509766,\n    amount: 3900,\n    date: '24.03.2014',\n    who: 'Arnold',\n    transactionType: 'payment',\n    accountName: 'hfhdjfhj',\n    accountNumber: 9548976,\n  },\n];\nconst transactionTable = document.querySelector('.transaction-table');\nconst createMarkup = arr => {\n  return arr\n    .map(\n      obj =>\n        `<tr class=\"tr\">\n     <td class=\"td\">${obj.id}</td>\n     <td class=\"td\">${obj.amount}</td>\n     <td class=\"td\">${obj.date}</td>\n     <td class=\"td\">${obj.who}</td>\n     <td class=\"td\">${obj.transactionType}</td>\n     <td class=\"td\">${obj.accountName}</td>\n     <td class=\"td\">${obj.accountNumber}</td>\n    </tr>`\n    )\n    .join('');\n};\ntransactionTable.insertAdjacentHTML('beforeend', createMarkup(accounts));\n\n// звернемось до всіх tr td і додамо їм бордер\nconst tr = Array.from(document.querySelectorAll('tr'));\ntr.map(el => (el.style.border = '1px solid #fff'));\nconst td = Array.from(document.querySelectorAll('td'));\ntd.map(el => (el.style.border = '1px solid #fff'));\n\n// ................................................Події (events)\n// Події використовуються для реакції на дії користувача й виконання коду, пов'язаного з певною подією.\n// Для того щоб елемент реагував на дії користувача, до нього необхідно додати слухача події та визначити йому обробника.\n//                                          Метод addEventListener()\n// - додає слухача події на елемент.\n// element.addEventListener(event, handler, options)\n// event — рядок, що містить ім'я події, наприклад, \"click\"\n// handler — колбек-функція, яка буде викликана під час настання події\n// options — необов'язковий об'єкт параметрів із розширеними налаштуваннями\n//                                         removeEventListener()\n// видаляє слухача події з елемента. Aргументи аналогічні методу addEventListener()\n// !!!!!!!!!!!!!!!важливо використовувати ту саму функцію-обробник, яка була призначена в addEventListener. З цієї причини рекомендовано для обробників подій використовувати іменовані функції, які можна легко передавати як аргументи.\n\n//                                                    Об'єкт події\n// Кожна подія — це об'єкт, який містить інформацію про деталі події та автоматично передається першим аргументом в обробник події. Усі події відбуваються з базового класу Event.\n// Параметр event — це і є об'єкт події, який автоматично передається першим аргументом під час виклику колбек-функції. Ми можемо називати його як завгодно, але, як правило, його оголошують як e, evt або event.\n//        Деякі властивості об'єкта події:\n// = event.type — тип події.\n// = event.currentTarget — елемент, на якому виконується обробник події.\n\n//                                           Події клавіатури\n// Існує дві основні події клавіатури:\n// keydown — подія, що відбувається при натисканні клавіші\n// keyup — подія, що відбувається, коли клавішу відпустили\n\n// На відміну від інших подій, події клавіатури обробляються на документі, а не на конкретному елементі. Об'єкти подій клавіатури походять від базового класу KeyboardEvent.\n\n// document.addEventListener(\"keydown\", event => {\n//   console.log(\"Keydown: \", event);\n// });\n\n//\n// Події keydown і keyup спрацьовують при натисканні будь-якої клавіші, включно зі службовими (Ctrl, ShiftAltEscape тощо).\n\n// На практиці переважно обробляють тільки подію keydown, оскільки вона відбувається швидше за keyup і користувач раніше бачить результат натискання.\n\n//                            Властивості key і code\n// - Властивість об’єкта події key повертає символ, згенерований натисканням клавіші на клавіатурі. Ця властивість враховує:\n// стан клавіш-модифікаторів, наприклад Shift\n// поточну мову\n\n// Властивість об’єкта події code повертає код фізичної клавіші на клавіатурі й не залежить від мови та стану клавіш-модифікаторів.\n\n// document.addEventListener(\"keydown\", event => {\n//   console.log(\"key: \", event.key);\n//   console.log(\"code: \", event.code);\n// });\n// ex\nconst clearLogBtn = document.querySelector('.js-clear');\nconst logList = document.querySelector('.log-list');\nlet keypressCounter = 1;\n\nconsole.log(clearLogBtn);\n\ndocument.addEventListener('keydown', logMessage);\ndocument.addEventListener('keyup', logMessage);\nclearLogBtn.addEventListener('click', reset);\n\nfunction logMessage({ type, key, code }) {\n  const markup = `<div class=\"log-item\">\n    <span class=\"chip\">${keypressCounter}</span>\n    <ul>\n      <li><b>Event</b>: ${type}</li>\n      <li><b>Key</b>: ${key}</li>\n      <li><b>Code</b>: ${code}</li>\n    </ul>\n  </div>`;\n\n  logList.insertAdjacentHTML('afterbegin', markup);\n\n  if (type === 'keyup') {\n    incrementKeypressCounter();\n  }\n}\n\nfunction reset() {\n  keypressCounter = 1;\n  logList.innerHTML = '';\n}\n\nfunction incrementKeypressCounter() {\n  keypressCounter += 1;\n}\n\n//                                                     Події елементів форм\n//                                             Подія submit відправка <form></form>\n// Подія submit відбувається безпосередньо на формі (тег form), тому обробник подій слід встановлювати саме на ній.\n// Відправлення форми відбувається:\n//              -при кліку на кнопку з атрибутом type=\"submit\"\n// Або\n//              - при натисканні клавіші Enter під час перебування в будь-якому її текстовому полі форми\n// Подію submit можна застосувати для валідації (перевірки) форми перед відправленням, оскільки на об'єкті події існує багато корисних властивостей, пов'язаних з елементами форми.                                      //\n// const form = document.querySelector(\"form\");\n\n// form.addEventListener(\"submit\", event => {\n// \tevent.preventDefault();\n// });\n\n//                                             метод preventDefault()\n// Для скасування дії браузера за замовчуванням в об'єкта події\n\n// ЕХ  створює простий журнал подій для подій \"keydown\" і \"keyup”. Клікни мишею по вікну з прикладом, щоб навести на нього фокус. Відстеження подій клавіатури вже знаходиться на елементі document. Надрукуй щось на клавіатурі, щоб побачити результат їх обробки.\nconst registerForm = document.querySelector('.form');\n\nregisterForm.addEventListener('submit', handleSubmit2);\n\nfunction handleSubmit2(event) {\n  event.preventDefault();\n  const form = event.target;\n  //   Властивість elements DOM-елемента форми містить об'єкт з посиланнями на всі її елементи, які мають атрибут name. Саме тому в прикладі ми отримуємо значення полів, звертаючись до event.target.elements.login.value і event.target.elements.password.value.\n  const login = form.elements.login.value;\n  const password = form.elements.password.value;\n\n  if (login === '' || password === '') {\n    return console.log('Please fill in all the fields!');\n  }\n\n  console.log(`Login: ${login}, Password: ${password}`);\n  form.reset();\n}\n\n//                                   Подія change\n// Подія change відбувається після зміни елемента форми.\n\n// - Для текстових полів або textarea подія відбудеться не на кожному введенні символу, а після втрати фокусу. Це не завжди зручно. Уяви, що користувач набирає щось у текстовому полі — подія відсутня. Щойно фокус пропав, відбудеться подія change.\n\n// - Для select, чекбоксів і радіокнопок, подія change спрацьовує відразу під час вибору значення.\n\n// Dластивості при роботі з елементом <select>:\n// value - значення в атрибуті value в елементі опції в HTML\n// selectedIndex - індекс опції у списку (від 0)\n// options - текстова назва опціїї\n// ЕХ\nconst select = document.querySelector('.pizza-select');\nconst textOutput = document.querySelector('.text-output');\nconst valueOutput = document.querySelector('.value-output');\n\nselect.addEventListener('change', setOutput);\n\nfunction setOutput(event) {\n  const selectedOptionValue = event.currentTarget.value;\n  console.log(selectedOptionValue);\n  const selectedOptionIndex = event.currentTarget.selectedIndex;\n  console.log(selectedOptionIndex);\n  const selectedOptionText =\n    event.currentTarget.options[selectedOptionIndex].text;\n  console.log(selectedOptionText);\n\n  textOutput.textContent = selectedOptionText;\n  valueOutput.textContent = selectedOptionValue;\n}\n\n//                                                Подія input\n// відбувається тільки на текстових полях і textarea.\n\n// Вона створюється щоразу при зміні значення елемента, не чекаючи втрати фокусу. На практиці input — це найголовніша подія для роботи з текстовими полями форми.\n// ex\nconst textInput = document.querySelector('.text-input');\nconst output = document.querySelector('.output');\n\ntextInput.addEventListener('input', event => {\n  output.textContent = event.currentTarget.value;\n});\n\n// Порівняємо події input і change на текстових полях і textarea\n// Подія input:\n// -відбувається при кожній зміні значення (при введенні або видаленні)\n// -не залежить від втрати фокусу\n// Подія change: відбувається після втрати фокусу за умови, що відбулася зміна значення в елементі\n\n//                                      Подія focus і blur\n// Елемент отримує фокус під час кліку миші або переходу клавішею Tab.\n\n// Момент отримання і втрати фокусу дуже важливий. Отримуючи фокус, ми можемо завантажити дані для автозаповнення, почати відстежувати зміни тощо.\n// Під час втрати фокусу — перевірити введені дані.\n\n// подія focus відбувається під час фокусування на елементі\n// подія blur відбувається при втраті фокусу, наприклад, користувач клікає в іншому місці екрана\n// Фокус може бути тільки на одному елементі сторінки за одиницю часу.\n// document.activeElement - gоточний елемент, на якому знаходиться фокус,\n\n// Більшість елементів не можуть отримати фокус. Наприклад, якщо клікнути по <div>, то фокусування на ньому не відбудеться, тому що це не інтерактивний елемент.\n// ex\nconst textInputt = document.querySelector('.text-input-2');\nconst setFocusBtn = document.querySelector('[data-action=\"set\"]');\nconst removeFocusBtn = document.querySelector('[data-action=\"remove\"]');\n\nsetFocusBtn.addEventListener('click', () => {\n  textInputt.focus();\n});\n\nremoveFocusBtn.addEventListener('click', () => {\n  textInputt.blur();\n});\n\ntextInputt.addEventListener('focus', () => {\n  textInputt.value = 'This input has focus';\n});\n\ntextInputt.addEventListener('blur', () => {\n  textInputt.value = '';\n});\n\n// Пошук DOM-елементів\n// element.querySelector(selector) - повертає перший елемент, який відповідає вказаному CSS селектору всередині елемента element.\n// element.querySelectorAll(selector) - повертає всі елементи, які відповідають вказаному CSS селектору всередині елемента element.\n\n// Властивості DOM-елемента\n// element.textContent - містить текстовий вміст елемента element, ігноруючи всі теги HTML всередині.\n// element.innerHTML - містить HTML-вміст елемента element.\n// element.style - об'єкт, що містить вбудовані стилі елемента element, які можна змінювати динамічно з JavaScript.\n\n// CSS класи на DOM-елементах\n// element.classList.contains(className) - перевіряє, чи міститься вказаний клас className на елементі element.\n// element.classList.add(className) - додає клас className до списку класів елемента element.\n// element.classList.remove(className) - видаляє клас className зі списку класів елемента element.\n// element.classList.toggle(className) - додає клас className, якщо його немає, або видаляє, якщо він вже присутній, на елементі element.\n// element.classList.replace(oldClassName, newClassName) - замінює клас oldClassName на newClassName в списку класів елемента element.\n\n// Створення та видалення DOM-елементів\n// document.createElement(tagName) - створює новий HTML-елемент з вказаним ім'ям тегу tagName.\n// element.append(el) - додає вміст (або елемент) до кінця списку дочірніх елементів element.\n// element.prepend(el) - додає вміст (або елемент) до початку списку дочірніх елементів element.\n// element.remove() - видаляє DOM-елемент з DOM дерева.\n// insertAdjacentHTML(position, string) - додає вказаний рядок HTML після, перед, всередині або перед вказаним елементом.\n\n// Події\n// element.addEventListener(event, handler) - додає обробник події handler для події event на елемент element.\n// element.removeEventListener(event, handler) - видаляє обробник події handler для події event на елементі element.\n// keydown - подія, яка виникає, коли клавіша на клавіатурі натиснута.\n// submit - подія, яка виникає при відправці форми.\n// change - подія, яка виникає при зміні значення елемента форми.\n// input - подія, яка виникає при введенні даних в текстове поле.\n// focus - подія, яка виникає, коли елемент отримує фокус.\n// blur - подія, яка виникає, коли елемент втрачає фокус.\n\n// ex work with form - it's must have\nconst formComment = document.querySelector('.js-form');\nformComment.addEventListener('submit', handleSubmit);\n\nfunction handleSubmit(event) {\n  // вимкнули дефолтне перезавантаж сторінки при натисканні на кнопку сабміт\n  event.preventDefault();\n  // заходим у властивості подіїї event > target > elements > ключ > value (бачим там всі елементи форми і ключі взяті з атрибута HTML name=\"\" звернувшись до яких ми маєм ще один спосіб отримати дані що ввів користувач у поля)\n  console.log(event);\n  const elements = event.target.elements;\n  const emailValue = elements.email.value;\n  const passwordValue = elements.password.value;\n  const textareaValue = elements.comment.value;\n\n  if (emailValue === '' || passwordValue === '' || textareaValue === '') {\n    return alert('All fields must be filled in!');\n  } else {\n    const info = {\n      login: emailValue,\n      password: passwordValue,\n      comment: textareaValue,\n    };\n    console.log(info);\n    // можемо вивести об*єкт в алерт\n    alert(JSON.stringify(info));\n  }\n  // очищаємо форму від даних користувача після збереженнчя\n  event.target.reset();\n}\n\n// EX обробка комбінацій клавіш - при натисканні ctrl+C текст не буде копіюватися з document (html page)\ndocument.addEventListener('keydown', handleKeyPress);\nfunction handleKeyPress(event) {\n  if (event.ctrlKey && event.code === 'KeyC') {\n    console.log('copyrityng on page' + '!');\n    // вимкнули дефолтне значення клавіш ctrl+C і копіювання не відбудеться\n    event.preventDefault();\n  }\n}\n\n//                                  Події миші\n// - mouseenter (навели мишку на об*єкт події) and mouseleave (вивели мишку з об*єкта події)\n// - mousover and mouseout - те саме але ці властивості чутливі до вкладених елементів (зайшли на елемент - mousover, якщо натрапили на вкладений елемент спочатку відбудеться вихід з батьківського ел -mouseout а потім вхід у дочірній елемент   mousover)\n// - mousemove (chatty event - балакуча подія) - подія відбув під час кожного руху мишки, показує точні координати знаходження мишки\n\n// коли mouseenter - наводимо на div (об*єкт події) - додаємо класс \".box-active\" що робить back-ground іншого кольору ; коли виводимо мишку mouseleave з об*єкта події видаляємо клас .box-active\" і back-ground стає як був до створення цього класу\nconst box = document.querySelector('.box-1');\nconst box2 = document.querySelector('.box-2');\n\nbox.addEventListener('mouseenter', addClass);\nbox.addEventListener('mouseleave', remuvClass);\n\nbox2.addEventListener('mouseenter', addClass);\nbox2.addEventListener('mouseleave', remuvClass);\n\nfunction addClass(event) {\n  console.log('Attention mouseenter');\n  box.classList.add('box-active');\n  box2.classList.add('box2-active');\n}\n\nfunction remuvClass(event) {\n  console.log('Ops...mouseleave');\n  box.classList.remove('box-active');\n  box2.classList.remove('box2-active');\n}\n// Ex the form for searching cars\n// створюєм із масива фото-колекцію карток в список\nconst cars = [\n  {\n    brand: 'INFINITI',\n    type: 'Luxury SUV QX80',\n    year: '2025',\n    price: ' ',\n    src: '../images/infiniti-qx80.jpg',\n  },\n  {\n    brand: 'Volkswagen',\n    type: 'Electric SUV  ID.4',\n    year: 2024,\n    price: '$39,735',\n    src: '../images/volkswagen-id-4.jpg',\n  },\n  {\n    brand: 'Toyota',\n    type: 'Truck Tundra i-FORCE MAX',\n    year: '2025',\n    price: '$72,510',\n    src: '../images/toyota-tundra-i-force-max.jpg',\n  },\n  {\n    brand: 'Volvo',\n    type: 'Electric SUV XC40 Recharge',\n    year: '2017',\n    price: '$37,345',\n    src: '../images/volvo.jpg',\n  },\n  {\n    brand: 'Audi',\n    type: 'RS e-tron GT',\n    year: '2025',\n    price: '$99,900',\n    src: '../images/audi.jpg',\n  },\n  {\n    brand: 'Tesla',\n    type: 'Cybertruck',\n    year: '2023',\n    price: '$79,990',\n    src: '../images/tesla.jpg',\n  },\n  {\n    brand: 'Lexus',\n    type: 'SUV GX 550',\n    year: '2024',\n    price: '$100,629',\n    src: '../images/lexus.jpg',\n  },\n  {\n    brand: 'Honda',\n    type: 'SUV CR-V e:FCEV',\n    year: '2025',\n    price: '$50,000',\n    src: '../images/honda.jpg',\n  },\n  {\n    brand: 'BMW',\n    type: 'XM 50e',\n    year: '2024',\n    price: '$155,509',\n    src: '../images/bmw.jpg',\n  },\n];\nfunction createMarkup2(arr) {\n  return arr\n    .map(\n      car =>\n        `<li class=\"car-card\">\n  <img src=\"${car.src}\" alt=\"${car.type}\" class=\"img-car\" width=\"500\" height=\"400\"/>\n  <h2 class=\"car-titel\">${car.brand} - ${car.year}</h2>\n  <h3 class=\"car-type\">${car.type}</h3>\n  <p class=\"car-price\">${car.price}</p>\n  </li>`\n    )\n    .join('');\n}\n\nconst ulCars = document.querySelector('.cars-list');\nconst liCar = document.querySelector('.car-card');\n\nulCars.insertAdjacentHTML('beforeend', createMarkup2(cars));\n\nconst formCars = document.querySelector('.car-search');\nformCars.addEventListener('submit', handleSearch);\n\nfunction handleSearch(event) {\n  event.preventDefault();\n\n  const query = event.target.elements.query.value;\n  const options = event.target.elements.options.value;\n  console.log(query, options);\n\n  //  the bag - properties query.value (input's value) and options.value (value in <select value=\"car\" or value=\"brand\"></select>) are undefined . Why?I returned to this exercise after finishing the last module. and I found the answer - I forgot to write the value .value after event.target.elements.(name)\n\n  const result = cars.filter(car => {\n    // чи включає значення ключа (підставляєм з select) те що написано в інпуті користувачем +для правильного порівняння нормалізували до нижнього регістру\n    return car[options].toLowerCase().includes(query.toLowerCase());\n    //  об*єкт.ключ(обере в select).значення\n  });\n  console.log(result);\n\n  // поміщаємо отриманий об*єкт/-ти в список стираючи перед тим відображені всі інші автомобілі методом innerHTML\n  ulCars.innerHTML = createMarkup2(result);\n}\n// ЕХ\nfunction getRandomHexColor() {\n  return `#${Math.floor(Math.random() * 16777215)\n    .toString(16)\n    .padStart(6, 0)}`;\n}\nfunction createBoxes(amount) {\n  if (amount >= 1 && amount <= 100) {\n    let size = 30;\n    for (let i = 1; i <= amount; i++) {\n      const coloredDiv = document.createElement('div');\n      coloredDiv.style.width = `${size}px`;\n      coloredDiv.style.height = `${size}px`;\n      coloredDiv.style.backgroundColor = getRandomHexColor();\n      boxes.appendChild(coloredDiv);\n      size += 10;\n    }\n  }\n}\nconst input = document.querySelector('#amountInput');\nconst btnCreate = document.querySelector('#btnCreate');\nconst btnDestroy = document.querySelector('#btnDestroy');\nconst boxes = document.querySelector('#boxes');\n\nfunction create(event) {\n  event.preventDefault();\n  boxes.innerHTML = '';\n\n  const amount = input.value;\n  createBoxes(amount);\n}\nbtnCreate.addEventListener('click', create);\n\nconst destroyBoxes = () => {\n  boxes.innerHTML = '';\n  input.value = '';\n};\nbtnDestroy.addEventListener('click', destroyBoxes);\n// ex\nconst btnMoveKitty = document.querySelector('.btn-move-the-box');\nconst btnGoBackKitty = document.querySelector('.kitty-go-back');\nconst divKitty = document.querySelector('.box');\n\nbtnMoveKitty.addEventListener('click', handleMove);\nlet step = 0;\nfunction handleMove(event) {\n  step += 50;\n  divKitty.style.marginTop = `${step}px`;\n  divKitty.style.marginLeft = `${step}px`;\n  console.log(step);\n\n  return step;\n}\nbtnGoBackKitty.addEventListener('click', handleGoBack);\nfunction handleGoBack(event) {\n  step -= 50;\n  divKitty.style.marginTop = `${step}px`;\n  divKitty.style.marginLeft = `${step}px`;\n}\n//                                            Information from mentor\n// DOM (Document Object Model) – це спосіб, за допомогою якого JavaScript може взаємодіяти з HTML-елементами на сторінці. Це основа для створення динамічних інтерфейсів користувача.\n// Кожен елемент на веб-сторінці представлений у вигляді об'єкта, з яким можна працювати через JS. Для того, щоб отримати доступ до елемента, використовуються методи, як-от:\n// document.getElementById('id') – шукає елемент за його id.\n// document.querySelector('.class') – повертає перший елемент, що відповідає CSS-селектору.\n// document.querySelectorAll('tag') – повертає всі елементи, що відповідають певному тегу або селектору.\n// В більшості випадків вам будуть корисні наступні селектори для пошуку елементів в ДОМ (насправді це звичайні селектори, якими ви користуєтесь в css):\n// .myClass - селектор класу\n// #myId - id селектор\n// div.myClass - комбінований селектор (в цьому прикладі <div>з класом myClass )\n// div > p - дочірній селектор (<p>, що є безпосередніми дочірніми елементами <div>)\n// div p - селектор нащадків (<p> всередині <div>)\n// [attribute] - селектор атрибута (елемент з наявністю атрибута)\n// [attribute=\"value\"] – елемент з конкретним значенням атрибута.\n// Події – це дії, що відбуваються на сторінці (наприклад, клік мишею, натискання клавіші тощо). Щоб \"слухати\" події, ми використовуємо метод addEventListener. Це дозволяє виконувати певний код, коли подія відбувається.\n// Основні події, які варто знати:\n// click – спрацьовує при натисканні на елемент.\n// input – реагує на введення даних у текстове поле.\n// submit – спрацьовує при відправці форми.\n// keydown та keyup – реагують на натискання і відпускання клавіші.\n// Що варто знати про обробники подій:\n// Можна додавати кілька обробників до одного елемента.\n// Є можливість \"зупинити\" виконання стандартної поведінки браузера за допомогою event.preventDefault(), наприклад, для блокування перезавантаження сторінки при відправці форми.\n","'use strict';\n//                                                    MODUL 6 - ООП, КЛАСИ\n// Замість імені об'єкта, ми використовуємо зарезервоване ключове слово this.\n//\n\n// Під час виклику функції у this записується посилання на об'єкт, у контексті якого вона була викликана. Таким чином, у тілі функції ми можемо отримати доступ до властивостей і методів цього об'єкта.\nconst pizzaPalace = {\n  pizzas: ['Supercheese', 'Smoked', 'Four meats'],\n  checkPizza(pizzaName) {\n    return this.pizzas.includes(pizzaName);\n  },\n  order(pizzaName) {\n    const isPizzaAvailable = this.checkPizza(pizzaName);\n\n    if (!isPizzaAvailable) {\n      return `Sorry, there is no pizza named «${pizzaName}»`;\n    } else {\n      return `Order accepted, preparing «${pizzaName}» pizza`;\n    }\n  },\n};\nconst value = pizzaPalace.order.bind(pizzaPalace, 'Smoked');\nconsole.log(value());\n\n//   Значення this визначається не на момент оголошення функції (за винятком стрілкових функцій), а на момент її виклику. Іншими словами, this визначається тим, як саме функцію викликали, а не де вона була оголошена.\n//  - У глобальному контексті, якщо функція виконується не в суворому режимі, this посилається на об'єкт window. Об'єкт window надає доступ до браузерних властивостей і функцій та є глобальним контекстом виконання для скриптів у браузері.\n//  - У суворому режимі значення this у глобальному контексті завжди буде undefined.\n\n('use strict');\nfunction showThis() {\n  console.log('this in showThis: ', this);\n}\nconst user1 = {\n  username: 'Poly',\n};\nuser1.showContext = showThis;\n// Викликаємо в контексті об'єкта\nuser1.showContext(); // this in showThis: {username: \"Poly\", showContext: ƒ}\n// Викликаємо в глобальному контексті\nshowThis(); // \"this in showThis: undefined\"\n\n// .......................................................Метод call()\n// Метод call викликає функцію foo так, щоб значення this вказувало на потрібний об'єкт і використовувало значення його властивостей.\n// Сигнатура методу (ім'я методу і його параметри):\n// foo.call(thisArg, arg1, arg2, ...)\n// - thisArg — об'єкт, який ми хочемо встановити як контекст (значення this) для функції\n// - arg1, arg2, ... — необов'язкові аргументи, які будуть передані функції\nfunction greet(name) {\n  console.log(`Hello, ${name}! I am ${this.person}`);\n}\n\nconst person = 'John';\nconst context = {\n  person: 'Alice',\n};\n//   `Hello, Bob! I am Alice`\ngreet.call(context, 'Bob');\n// .......................................................Метод apply()\n// Метод apply є аналогом методу call. Відмінність у тому, що в методі apply() синтаксис передачі аргументів вимагає масиву, навіть якщо аргументи функції — це окремі значення.\n// foo.apply(thisArg, [arg1, arg2, ...])\nfunction greet2(str) {\n  console.log(`${str}, ${this.username}, your room is ${this.room}!`);\n}\n\nconst mango = {\n  username: 'Mango',\n  room: 27,\n};\n\nconst poly = {\n  username: 'Poly',\n  room: 191,\n};\n\ngreet.apply(mango, ['Welcome']); // \"Welcome, Mango, your room is 27!\"\ngreet.apply(poly, ['Aloha']); // \"Aloha, Poly, your room is 191!\"\n\n//   .........................................Метод bind()\n// Методи call і apply викликають функцію «на місці», тобто одразу.\n\n// Метод bind створює і повертає нову функцію, яка має заздалегідь встановлений контекст, і ця нова функція може бути викликана пізніше з будь-якими аргументами.\n\n// const boundFoo = foo.bind(thisArg, arg1, arg2, ...)\n('use strict');\n\nconst customer = {\n  username: 'Jacob',\n  sayHello() {\n    console.log(`Hello, ${this.username}!`);\n  },\n};\n\n// customer.sayHello(); // \"Hello, Jacob!\"\n\n// const greet1 = customer.sayHello;\n\n// greet1(); // TypeError: Cannot read properties of undefined (reading 'username')\n// При виклику greet() контекст втрачено, функція викликається в глобальному контексті, тому значення this буде undefined. При спробі звернутися до властивості this.username під час виклику функції greet(), виникає помилка, оскільки undefined — це навіть не об'єкт. Це можна виправити, прив'язавши контекст за допомогою методу bind\n\nconst greet1 = customer.sayHello.bind(customer);\n\ngreet1(); // \"Hello, Jacob!\"\n// Коли ми використовуємо bind(), ми створюємо нову функцію greet. Ця нова функція завжди матиме правильний контекст і може використовувати властивість username об'єкта customer.\n\n// .............коли метод об*єкта викликається як колбек функція у глобальному контексті, є undefined.  ми отримаємо помилку, оскільки undefined — це не об'єкт. Щоб уникнути цієї втрати контексту, можна використати метод bind(). Замість передачі оригінального методу об*єкта, ми передаємо його копію, до якої прив'язаний контекст об'єкта .\nconst library = {\n  books: 1923,\n  logBookCount() {\n    console.log(this.books);\n  },\n};\n\nconst showBooks = library.logBookCount.bind({ books: 724 });\n\nshowBooks();\n\n// // ............................................Стрілочні функції\n// Контекст усередині стрілочної функції визначається місцем її оголошення, а не виклику.\n\n// Це означає, що this усередині стрілки посилається на контекст батьківської області видимості, в якій вона була оголошена, і ніколи не змінюється.\n// 1.Контекст **this** усередині стрілочної функції визначається місцем її оголошення, а не виклику.\n// 2.Стрілочні функції ігнорують наявність суворого режиму. Тому в глобальному контексті у стрілці завжди this посилається на об'єкт window.\n// 3.Неможливо змінити значення this усередині стрілочних функцій після її оголошення. Методи call, apply і bind не впливають на значення this у стрілках.\n\n// .....................................................Прототип об'єкта\n// ......................................Метод Object.create(obj) створює новий об'єкт і встановлює йому прототипом obj. Такий новий об'єкт матиме прототип obj і буде успадковувати його властивості.\n// [[Prototype]] - властивість, яка зберігає посилання на прототип.\n// прототип — це резервне сховище властивостей і методів об'єкта, яке автоматично використовується під час їх пошуку.\nconst animal = {\n  legs: 4,\n};\n\nconst dog = Object.create(animal);\ndog.name = 'Mango';\n\nconsole.log(dog); // { name: \"Mango\", [[Prototype]]: animal }\n//   Об'єкт, на який вказує посилання у властивості [[Prototype]], називається прототипом. У нашому прикладі об'єкт animal — це прототип для об'єкта dog.\n// ..........................................метод isPrototypeOf() - якщо в коді потрібно перевірити, чи є об'єкт прототипом іншого об'єкта,\n// objA.isPrototypeOf(objB)\n// Метод перевіряє, чи є об'єкт objA прототипом для об’єкта objB\n// Якщо так, повертає true, в іншому разі повертає false\nconsole.log(animal.isPrototypeOf(dog)); // true\nconsole.log(dog.isPrototypeOf(animal)); // false\n// .........................................Власні і невласні властивості\n//           - Власнa властивість об'єкта - та що належить об'єкту\n//           - Невласна властивість об'єкта - та що належить  його прототипу\n// .........................................метод obj.hasOwnProperty(key) -  перевіряє наявність власної властивості з ім'ям key і повертає true, якщо є, і false в іншому випадку.\n// Оператор in, який використовується в циклі for...in, не розрізняє власні властивості об'єкта і його прототипу. Ця особливість заважає, оскільки зазвичай потрібно перебрати тільки власні властивості.\n// Для вибору саме власних властивостей під час перебору циклом for...in необхідно на кожній ітерації додати перевірку на власну властивість методом obj.hasOwnProperty(key)\nconst animal2 = { legs: 4 };\nconst dog2 = Object.create(animal2);\ndog2.name = 'Mango';\n\nfor (const key in dog2) {\n  if (dog2.hasOwnProperty(key)) {\n    console.log(key); // \"name\"\n  }\n}\n\n//            Методи Object.keys(obj) і Object.values(obj) повертають масив тільки власних ключів або значень тільки власних властивостей об'єкта obj, без необхідності додаткових перевірок. Через це на практиці використовують саме їх із циклом for...of, замість for...in і hasOwnProperty.\n\nconsole.log(Object.keys(dog)); // [\"name\"]\nconsole.log(Object.values(dog)); // [\"Mango\"]\n\nfor (const key of Object.keys(dog)) {\n  console.log(key); // \"name\"\n}\n\n// ......................................Ланцюжки прототипів\n// Об'єкт, який виступає прототипом для іншого об'єкта, також може мати свій прототип. Отже, існують ланцюжки прототипів.\nconst objC = { c: 'objC prop' };\n\nconst objB = Object.create(objC);\nobjB.b = 'objB prop';\n\nconst objA = Object.create(objB);\nobjA.a = 'objA prop';\n\nconsole.log(objA); // { a: \"objA prop\", [[Prototype]]: objB }\nconsole.log(objB); // { b: \"objB prop\", [[Prototype]]: objC }\nconsole.log(objC); // { c: \"objC prop\", [[Prototype]]: Object }\n//                 Оскільки об*єкти objA, objB і objC пов'язані в ланцюжок прототипів, об'єкт objA може отримати доступ до властивостей objB і objC, а об'єкт objB — до властивостей objC.\n\n// Пошук властивостей відбувається до першого збігу. Інтерпретатор шукає властивість за ім'ям в об'єкті: Якщо інтерпретатор не знаходить власну властивість, то звертається до властивості [[Prototype]], тобто переходить за посиланням до об'єкта-прототипу, а потім — до прототипу прототипу за ланцюжком.Якщо інтерпретатор доходить до кінця ланцюжка і не знаходить властивості з таким ім'ям, то повертається undefined.\nconst apartment21 = {\n  rooms: 4,\n  floor: 2,\n  taxFree: false,\n};\n\nconst condo = Object.create(apartment21);\ncondo.rooms = 3;\n\n// ..................................що знаходиться у властивості [[Prototype]] кінцевого об'єкта ланцюжка?\n// Наприкінці ланцюжка прототипів завжди знаходиться посилання на базовий клас, від якого походить тип даних у ланцюжку. У нашому випадку objB — це об'єкт, тому в кінці ланцюжка буде посилання на клас Object.\n\n// ....................................................ООП\n// Процедурне програмування — це те, як ми з тобою писали код до сих пір. Воно є простим і зрозумілим і може бути використане для написання простих програм. Проте зі збільшенням складності програми процедурний підхід може стати неефективним, оскільки втрачається зв'язок між даними й методами їх обробки.\n//  ООП — это способ написания кода, позволяющий создавать объекты с помощью одного объекта. В этом также заключается суть шаблона.\n// Об'єктно-орієнтоване програмування (ООП) — це парадигма програмування, в якій програми структуровані як сукупність об'єктів. Ці об’єкти представляють реальні або абстрактні сутності: користувач, магазин, автомобіль тощо. Кожен з об’єктів містить дані (властивості) і методи для взаємодії з ними.\n// При такому підході відсутні або майже відсутні глобальні змінні. Методи не залежать від параметрів, а використовують властивості об'єкта, які задаються при його створенні і можуть бути змінені іншими методами.Програмування в стилі ООП допомагає структурувати код, полегшує його розробку та підтримку і дозволяє створювати більш складні програми, організовані навколо об'єктів та їх взаємодії.\n\n// Клас — це спосіб опису сутності, що визначає структуру та поведінку об'єктів. Вони виступають в якості шаблонів для створення нових об'єктів. Клас містить властивості та методи об*єкту\n//  Контракт -правила для взаємодії з цією сутністю\n// Екземпляр(instance) — це окремий представник класу, який має дані (властивості) і методи (функції), які працюють з цими даними. Екземпляр — це те, що створено за кресленням, тобто на підставі опису з класу.\n// Клас — це якийсь АБСТРАКТНИЙ автомобіль на кресленні\n// Екземпляр (об'єкт) — це КОНКРЕТНИЙ автомобіль, що стоїть у нас під вікнами\n// Інтерфейс класу — це набір властивостей і методів класу, доступних для використання у роботі з екземпляром. По суті, інтерфейс описує клас, чітко визначаючи всі можливі дії над ним.\n\n// Описуючи інтерфейс класу, дуже важливо витримати баланс між гнучкістю й простотою.\n// -      Клас із ПРОСТИМ інтерфейсом легко використовувати, але будуть існувати завдання, які за допомогою нього буде складно вирішити.\n// -      ГНУЧКИЙ інтерфейс - буде містити досить складні методи з великою кількістю параметрів. Такий інтерфейс дозволить виконувати дуже багато дій, але його використання буде пов'язане з труднощами й ризиком помилитися, переплутавши щось.\n\n// Class - use that створити багато однотипних об'єктів з однаковим набором властивостей, але різними значеннями й методами для взаємодії з ними.\n// оператора new - use that створити  екземпляр pісля того як клас було оголошено, поставивши його перед викликом класу. Результатом виклику new User() буде екземпляр класу User. Він буде містити дані і мати поведінку, що описані у класі.\n\n// створили класс (шаблон для створ об*єктів)\nclass Pet {}\n// використовуєм калас для створення подібних об*Єктів\nconst doggy = new Pet();\nconst cat = new Pet();\nconst parrot = new Pet();\n\n// Для ініціалізації екземпляра класу використовується метод constructor.\n// Якщо його не визначити в явному вигляді, то буде створений конструктор за замовчуванням — порожня функція, яка не змінює екземпляр класу.\nclass User {\n  // Синтаксис оголошення методу класу\n  constructor() {\n    // ...\n  }\n}\n\n// Виклик класу з оператором new призводить до створення нового об'єкта й АВТОМАТИЧНОГО ВИКЛИКУ методу constructor.\n//Аргументи, які передаються при виклику new User(), стають значеннями параметрів для методу constructor.\nclass Car {\n  constructor(name, price, type) {\n    this.name = name;\n    this.price = price;\n    this.type = type;\n  }\n}\n\nconst infiniti = new Car('Infiniti', 700000, 'Luxury SUV');\n\nconsole.log(infiniti);\n\n//  this усередині конструктора посилається на новостворений об'єкт. Це дозволяє надавати кожному об'єкту властивості з однаковими іменами, але різними значеннями.\n\n// Властивості name, price, type (параметри конструктора) називаються ПУБЛІЧНИМИ ВЛАСТИВОСТЯМИ, оскільки вони є власними властивостями об'єкта-екземпляра.\n\n// ............................................Метод constructor використовується для ініціалізації власних властивостей екземпляра класу.\n\n// Об'єкт параметрів\n// Клас може приймати велику кількість вхідних даних для властивостей майбутнього об'єкта.\n// До них також можна застосувати патерн «Об'єкт параметрів», передаючи один об'єкт з логічно іменованими властивостями, замість непов'язаного набору аргументів.\nclass Client {\n  constructor(param) {\n    this.name = param.name;\n    this.phone = param.phone;\n    this.age = param.age;\n    this.status = param.status;\n    this.balance = param.balance;\n  }\n}\n\nconst c01 = new Client({\n  name: 'Pyter Clarso',\n  phone: '+380956734511',\n  age: 32,\n  status: 'VIP',\n  balance: 900890098,\n});\n\nconsole.log(c01);\n// Методи класу — це функції, які будуть доступні екземпляру в його прототипі. Вони оголошуються в довільному порядку після конструктора. На відміну від синтаксису методів об'єкта (вони розділяються комою), методи класу не розділені жодними спеціальними символами.\n\nclass Sound {\n  constructor(p) {\n    this.name = p.name;\n    this.author = p.author;\n    this.rating = p.rating;\n  }\n\n  getRating() {\n    return `The rating of ${this.name} - ${this.rating}`;\n  }\n  changeRating(newRating) {\n    return (this.rating = newRating);\n  }\n}\n\nconst s01 = new Sound({\n  name: 'She is good',\n  author: 'Robertyson',\n  rating: 9.5,\n});\nconsole.log(s01, s01.getRating());\n\n// ................Прототип екземпляру\n// Якщо поглянути на структуру екземпляра класу  в інструментах розробника, може виникнути питання: \"Де методи, які ми викликаємо?\"\nconsole.log(Sound);\n\n// Об'єктно-орієнтоване програмування в JavaScript побудоване на прототипному наслідуванні. Методи класу не стають власними властивостями екземпляра. І це правильно, оскільки, на відміну від значень властивостей, вони не є унікальними. Це одна й та сама функція, яка викликається в контексті різних об'єктів. Немає сенсу копіювати методи для кожного екземпляра, враховуючи, що може існувати багато тисяч екземплярів.\n\n// Методи класу додаються до спеціального об'єкта, який зберігається у властивості prototype самого класу.\nconsole.log(Sound.prototype);\n// При створенні екземпляра через new, об'єкт, збережений у властивості prototype класу, автоматично стає його прототипом. Це означає, що властивість [[Prototype]] екземпляра отримує посилання на властивість prototype класу.\n\n// ..................................................#Приватні властивості\n// Інкапсуляція — це парадигма ООП, яка передбачає приховування деталей внутрішньої реалізації класу від зовнішнього коду. Інкапсуляція реалізується приватними властивостями та методами, доступ до яких можна отримати тільки всередині класу.\n\n//  Додаючи до імені властивості на початку символ #, ми робимо її приватною. Оголошення приватної властивості до ініціалізації в конструкторі є обов'язковим. Припустимо, що пошта користувача повинна бути недоступною для прямої зміни ззовні, тобто приватною.\nclass User4 {\n  // Необов'язкове оголошення публічних властивостей\n  name;\n  // Обов'язкове оголошення приватних властивостей\n  #email;\n\n  constructor(params) {\n    this.name = params.name;\n    this.#email = params.email;\n  }\n}\n\nconst mangoj = new User4({\n  name: 'Mango',\n  email: 'mango@mail.com',\n});\nconsole.log(mangoj.name); // \"Mango\"\n//   console.log(mangoj.#email); // Виникне помилка, це приватна властивість\n\n// Для того щоб отримати або змінити значення приватної властивості використовуються ПУБЛІЧНІ методи in prototype of class.\n// changeEmail(newEmail) {\n//     this.#email = newEmail;\n//   }\n\nclass Car6 {\n  #brand;\n  constructor(params) {\n    this.#brand = params.brand;\n    this.model = params.model;\n    this.price = params.price;\n  }\n\n  getPrice() {\n    return this.price;\n  }\n\n  changePrice(newPrice) {\n    this.price = newPrice;\n  }\n  getBrand() {\n    return this.#brand;\n  }\n  changeBrand(newBrand) {\n    return (this.#brand = newBrand);\n  }\n}\n// ...................................................#ПРИВАТНІ методи\n// Додаючи до назви методу на початку символ #, ми робимо його приватним.\n// Іноді потрібно проводити певні дії, які мають бути приховані від \"зовнішнього світу\". fOR EXAMPLE, кожен раз, коли електронна пошта змінюється, потрібно валідувати її формат.\nclass User3 {\n  #email;\n\n  constructor(params) {\n    this.name = params.name;\n    this.#email = params.email;\n  }\n\n  // Публічний метод для отримання електронної пошти\n  getEmail() {\n    return this.#email;\n  }\n\n  // Публічний метод для зміни електронної пошти\n  changeEmail(newEmail) {\n    if (this.#validateEmail(newEmail)) {\n      this.#email = newEmail;\n    } else {\n      console.log('Invalid email format');\n    }\n  }\n\n  // Приватний метод для валідації електронної пошти\n  #validateEmail(email) {\n    return email.includes('@');\n  }\n}\n\nconst mango3 = new User3({\n  name: 'Mango',\n  email: 'mango@mail.com',\n});\n\n// Спробуємо змінити електронну пошту\nmango3.changeEmail('newmail.com'); // \"Invalid email format\"\nmango3.changeEmail('new@mail.com');\nconsole.log(mango3.getEmail()); // \"new@mail.com\"\n\n// Прямий виклик приватного методу ззовні призведе до помилки\n//   console.log(mango3.#validateEmail('test'));// Помилка\n\n// приватний метод #validateEmail забезпечує додаткову логіку для валідації електронної пошти.Цей метод не доступний ззовні класу, тому користувачі (або інші розробники) не можуть його викликати напряму. Вони можуть лише використовувати публічний метод changeEmail, який у свою чергу використовує приватний метод для валідації.\n// Приватні властивості та приватні методи використовуються, щоб приховати деталі реалізації класу. Це дозволяє ізолювати (інкапсулювати) внутрішню реалізацію класу від зовнішнього коду й забезпечити контроль доступу до деяких властивостей і методів, щоб гарантувати безпеку та стабільність програми.\n\n// .................................................Геттер get і сеттер set\n// Геттер — це функція, яка дозволяє отримати значення властивості класу. визначається за допомогою ключового слова get, за яким слідує ім'я сеттера і блок коду.\n// Сеттер - це функція, яка дозволяє змінити значення властивості\n// - Геттер і сеттер повинні називатися однаково і їх називати так само, як і властивість, з якою вони працюють (гарний тон). Геттер може існувати без сеттера, так само як і сеттер без геттера.\n// -  використовувати для простих операцій читання та зміни значення властивостей, особливо приватних, як їх публічний інтерфейс. Для роботи з властивістю, яка зберігає масив або об'єкт, вони не підійдуть.\n\n// Геттер срабатывает, когда obj.propName читается, сеттер – когда значение присваивается.\nclass Car2 {\n  #brand;\n  #model;\n  #price;\n  constructor(params) {\n    this.#brand = params.brand;\n    this.#model = params.model;\n    this.#price = params.price;\n  }\n  get brand() {\n    return this.#brand;\n  }\n  set brand(newBrand) {\n    this.#brand = newBrand;\n  }\n  get model() {\n    return this.model;\n  }\n  set model(newModel) {\n    this.model = newModel;\n  }\n  get price() {\n    return this.price;\n  }\n  set price(newPrice) {\n    this.price = newPrice;\n  }\n}\n// ...................................Статичні властивості та методи (static)\n// статичні властивості - що доступні тільки класові, але не його екземплярам — це . Вони корисні для зберігання інформації, що стосується класу.\n// Статичні властивості оголошуються в тілі класу. Перед ім'ям властивості додається ключове слово static. Статичні властивості можна використовувати як у методах класу, так і поза класом.\n// У екземпляра немає доступу до статичних властивостей класу. щоб звернутися до стат властив - назваКласу.назваСтатВластив\n\n// Статичні методи — це методи, доступні тільки класу. Вони можуть бути публічні та приватні.\n// !!!!!!!!!!!!Особливість статичних методів\n// Під час їх виклику ключове слово this посилається на сам клас. Це означає, що статичний метод може отримати доступ до статичних властивостей класу, але не до властивостей екземпляра. Це логічно, адже статичні методи викликає сам клас, а не його екземпляри.\n\nclass Car7 {\n  #price;\n  static maxPrice = 50000;\n  constructor(params) {\n    this.#price = params.price;\n  }\n\n  get price() {\n    return this.#price;\n  }\n\n  set price(newPrice) {\n    return newPrice <= Car7.maxPrice ? (this.#price = newPrice) : this.#price;\n  }\n}\n\nconst audi = new Car7({ price: 35000 });\nconsole.log(audi.price); // 35000\n\naudi.price = 49000;\nconsole.log(audi.price); // 49000\n\naudi.price = 51000;\nconsole.log(audi.price); // 49000\n\n// ex\nclass Car8 {\n  static #maxPrice = 50000;\n\n  constructor(params) {\n    this.price = params.price;\n  }\n  static checkPrice(price) {\n    return price > Car8.#maxPrice\n      ? 'Error! Price exceeds the maximum'\n      : 'Success! Price is within acceptable limits';\n  }\n}\n\nconst audiT = new Car8({ price: 36000 });\nconst bmw = new Car8({ price: 64000 });\n\nconsole.log(Car8.checkPrice(audiT.price)); // \"Success! Price is within acceptable limits\"\nconsole.log(Car8.checkPrice(bmw.price)); // \"Error! Price exceeds the maximum\"\n\n// ...................................................Наслідування класів\n// Ключове слово extends дозволяє реалізувати наслідування класів, коли один клас (дочірній, похідний) наслідує властивості й методи іншого класу (батьківського).\n//\n// Це означає, що ми можемо оголосити базовий клас, який зберігає загальні характеристики й методи для групи похідних класів, які наслідують властивості й методи батьківського, але також додають свої унікальні.\n// class Parent {}\n// class Child extends Parent {\n//    ...\n// }\n// У конструкторі дочірнього класу необхідно викликати спеціальну функцію super(args) — це псевдонім конструктора батьківського класу.В іншому випадку при спробі звернутися до this у конструкторі дочірнього класу виникне помилка.\n// Разница в следующем:\n// - Когда выполняется обычный конструктор, он создаёт пустой объект и присваивает его this .\n// - Когда запускается конструктор унаследованного класса, он этого не делает. Вместо этого он ждёт, что это сделает конструктор родительского класса. В наследующем классе  функция-конструктор помечена специальным внутренним свойством [[ConstructorKind]]:\"derived\".\n// - Поэтому, если мы создаём собственный конструктор, мы должны вызвать super, в противном случае объект для this не будет создан, и мы получим ошибку.\nclass Animal {\n  constructor(name, speed) {\n    this.speed = speed;\n    this.name = name;\n  }\n}\n\nclass Rabbit extends Animal {\n  constructor(name, speed, earLength) {\n    super(name, speed);\n    this.speed = `the speed is ${speed}`;\n    this.earLength = `earLength is ${earLength}`;\n  }\n}\n\nlet whiteRabbit = new Rabbit('Белый кролик', '90 km/h', 10);\nlet blackRabbit = new Rabbit('Черный кролик', '95 km/h', 11);\nconsole.log(whiteRabbit.name, blackRabbit.name); // Белый кролик\nconsole.log(whiteRabbit.earLength, blackRabbit.earLength); // 10\nconsole.log(whiteRabbit.speed, blackRabbit.speed);\n// ex\nclass User8 {\n  email;\n\n  constructor(email) {\n    this.email = email;\n  }\n\n  get email() {\n    return this.email;\n  }\n\n  set email(newEmail) {\n    this.email = newEmail;\n  }\n}\n\nclass Admin extends User8 {\n  static role = {\n    BASIC: 'basic',\n    SUPERUSER: 'superuser',\n  };\n  static level = {\n    junior: 'junior',\n    midle: 'midle',\n    senior: 'senior',\n  };\n  constructor(params) {\n    super(params.email);\n    this.access = params.access;\n    this.level = params.level;\n  }\n}\n\nconst mango8 = new Admin({\n  email: 'mango@mail.com',\n  access: Admin.role.SUPERUSER,\n  level: Admin.level.junior,\n});\n\nconsole.log(mango8.email); // \"mango@mail.com\"\nconsole.log(mango8.access, mango8.level); // \"superuser\"\n\n//   Методи дочірнього класу доступні тільки їх екземплярам\nclass User10 {\n  email;\n  constructor(email) {\n    this.email = email;\n  }\n  get email() {\n    return this.email;\n  }\n  set email(newEmail) {\n    this.email = newEmail;\n  }\n}\n\nclass Admin2 extends User10 {\n  static role = {\n    BASIC: 'basic',\n    SUPERUSER: 'superuser',\n  };\n  constructor(params) {\n    super(params.email);\n    this.access = params.access;\n    this.blacklistedEmails = [];\n  }\n  blacklist(email) {\n    return this.blacklistedEmails.push(email);\n  }\n  isBlacklisted(email) {\n    return this.blacklistedEmails.includes(email);\n  }\n}\n\nconst mango9 = new Admin2({\n  email: 'mango@mail.com',\n  access: Admin2.role.SUPERUSER,\n});\n\nconsole.log(mango9.email); // \"mango@mail.com\"\nconsole.log(mango9.access); // \"superuser\"\n\nmango9.blacklist('poly@mail.com');\nconsole.log(mango9.blacklistedEmails, '- додали імеіл в чс'); // [\"poly@mail.com\"]\nconsole.log(\n  mango9.isBlacklisted('mango@mail.com'),\n  '- перевірили що цієї пошти нема в масиві чс'\n); // false\nconsole.log(\n  mango9.isBlacklisted('poly@mail.com'),\n  '- перевірили ця пошта в чс'\n); // true\n\n//....................................................Menthor..........................................................\n// -Для оголошення приватних властивостей класу використовуємо спеціальний символ #. Оголошення приватних властивостей до ініціалізації в конструкторі - обов‘язково. Наприклад, #someValue і потім тільки оголосити конструктор:\n// -До речі, можна зустріти (нагуглити) таке написання : _someValue; Це не синтаксис мови: є добре відома угода між програмістами, що такі властивості та методи не повинні бути доступні ззовні. Більшість програмістів дотримуються цієї угоди. Ще це називають захищеною властивістю. Важливо відзначити -- ці властивості успадковуються.\n// -Статичні властивості і методи доступні тільки на самому класі, тож звертання до них через this або всередині екземпляра поверне undefind. Звертатись до статичних властивостей і методів можна тільки через ім’я самого класу. Оголошуються вони також до конструктора за допомогою ключового слова static.\n// -Ключове слово extends використовують для оголошення класів або у виразах класу для створення дочірніх класів. Дочірні класи отримують властивості батьківських класів, а також дають можливість додати нові властивості та змінити запозичені.\n// -Ключове слово super викликає функції з батька об’єкта, включаючи його конструктор. Його слід використовувати до ключового слова this в конструкторі (інакше буде помилка); якщо батьківський конструктор приймає аргументи, можна передати їх, як аргументи в super(arguments);\n// class Animal {\n//   constructor(name) {\n//     this.name = name;\n//   }\n// }\n// class Dog extends Animal {\n//   constructor(name, breed) {\n//     super(name); // виклик конструктора батьківського класу\n//     this.breed = breed;\n//   }\n// }\n// якщо дочірній клас має метод з таким же ім'ям, як у батьківському класі, можна   викликати метод батьківського класу, використовуючи `super.X()`.\n// class Animal {\n//   speak() {\n//     console.log('Animal speaks');\n//   }\n// }\n\n// class Dog extends Animal {\n//   speak() {\n//     super.speak(); // виклик методу батьківського класу\n//     console.log('Dog barks');\n//   }\n// }\n\n// ............................................Practice\n// this у функції ссилається на об*єкт в контексті якого вона була викликана\n//  - без суворого режиму - Window\n// - у суворому режимі - undefined\n// this в методі об*єкта - силається на об*єкт в контексті якого вона викликана\n// this у стрілочній ф-йії ссилається на контекст батьківського елементу де вона була створена. Якщо створ у глоб обл - то завжди this буде Window. в об*єктах стрілочну ф-цію не дуже використовують\nconst yyyy = {\n  name: 'lalala',\n  funct: () => {\n    return `this of arrow function is ${this}`;\n  },\n};\nconsole.log(yyyy.funct());\n// якщо вкласти стрілочну ф-цію у метод об*єкту (батьківський ел стрілочної функції стає сам об*єкт) то this буде батьківський об*єкт\nconst objX = {\n  name: 'lalala',\n  funct() {\n    console.log('g');\n    const x = () => {\n      console.log(`this of arrow function in method of object is ${this}`);\n    };\n    x();\n  },\n};\nobjX.funct();\n// ex1\nconst chopShop = {\n  stones: [\n    { name: 'diamond', price: 10000, quantity: 3 },\n    { name: 'rubbi', price: 7000, quantity: 5 },\n    { name: 'sapphire', price: 9000, quantity: 4 },\n  ],\n  calculateTotalPrice(nameStone) {\n    //     let total = 0;\n    //   for (const item of this.stones){\n    //     console.log(item);\n    // name === item.name ? total = item.price * item.quantity : \"This stone is undefined in our shop\";\n    //         }\n    //         return total;\n    //              масив об*єктів\n    const stone = this.stones.find(item => item.name === nameStone);\n    console.log(stone);\n    // undefined\n    if (!stone) {\n      return `${nameStone} stone is undefined in our shop`;\n    }\n    return `Total is ${stone.price * stone.quantity}`;\n  },\n};\nconsole.log(chopShop.calculateTotalPrice('rubbi'));\n\n// ..............................................контекст виконання ф-ції\n// - метод call() - метод ф-ції що передає у функцію під час її виклику контекст переданого об*єкта в параметрах (значення this)\n// - метод aply() - під час виклику те саме тільки параметри приймає у масиві\nconst propNam = 'color';\nfunction changeColor(color) {\n  return (this.color = color);\n}\nconst objL = {\n  [propNam]: 'blue',\n};\nconst objK = {\n  color: 'red',\n};\nchangeColor.call(objL, 'yellow');\nconsole.log(objL);\n\n// - метод bind() - зберігає у змінну копію ф-ціїї з прив*язаним контекстом обраного об*єкта\nconst varChangeColor = changeColor.bind(objK);\nvarChangeColor('green');\nconsole.log(objK);\n// якщо передати метод об*єкту як колбек ф-цію якій ф-кціїї то this колбека втратить свій контекст і стане віндов/андефайнед, тут і допоможе метод bind привязати контеrст об*єкта (якщо передаєм колбек (посилання на іншу ф-цію) у аргумент то допоможе тільки bind)\nconst userR = {\n  name: 'lalala',\n  showThis() {\n    return `this is ${this}`;\n  },\n};\nfunction logger(callback) {\n  console.log(callback);\n\n  return callback();\n}\nconsole.log(logger(userR.showThis.bind(userR)));\n// if don't use .bind() this - is undefined (because \"use strict\")\nconsole.log(logger(userR.showThis));\n\n// ex\nconst objJK = {\n  value: 0,\n  increment(num) {\n    return (this.value += num);\n  },\n  decrement(num) {\n    return (this.value -= num);\n  },\n};\n\nfunction updateObjJK(number, callback) {\n  return callback(number);\n}\nupdateObjJK(7, objJK.increment.bind(objJK));\nconsole.log(objJK);\nupdateObjJK(1, objJK.decrement.bind(objJK));\nconsole.log(objJK);\n\n// ..................................Прототип об*єкту\n// Object.create() - метод що створить об*єкт з (прототипу) та передасть йому властив та методит прототипу\n//  - властив об*єкта  - власна, властив прототипа - не власна\nconst hehehe = { smile: 'crazy' };\n\nconst hohoho = Object.create(hehehe);\nhohoho.type = 'positive';\nconsole.log(hohoho);\n// .hasOwnProperty() - поверне тру якщо властив власна і фолс якщо не власна\nconsole.log(hohoho.hasOwnProperty('smile'));\n// for in повертає разом і власні і не власні властив, щоб їх відфільтрув викор .hasOwnProperty()\nfor (const key in hohoho) {\n  if (hohoho.hasOwnProperty(key)) {\n    console.log(key);\n  }\n}\n// або Object.keys(obj) ПОВЕРТА ЛИШЕ ВЛАСНІ ВЛАСТИВ ОБ*ЄКТУ\nconst keysHohoho = Object.keys(hohoho);\nconsole.log(keysHohoho);\n\n// ланцюжки прототипів та успадкування властивостей і методів\nconst q = { q: 'q' };\nconst w = Object.create(q);\nw.w = 'w';\nconst e = Object.create(w);\ne.e = 'e';\nconst r = Object.create(e);\nr.r = 'r';\nconsole.log(r);\n\n// EX методи збільшення швидкості та зменшення швидкості\nconst cruiseControle = {\n  speed: 0,\n  brand: 'Audi',\n};\nfunction accelerate() {\n  this.speed += 10;\n  return `Автомобіль ${this.brand} прискорюється, швидкість ${this.speed} km/h`;\n}\nfunction decrease() {\n  if (this.speed <= 0) {\n    return `Авто зупинилось`;\n  } else {\n    this.speed -= 10;\n    return `Автомобіль ${this.brand} уповільнюється, швидкість ${this.speed} km/h`;\n  }\n}\naccelerate.call(cruiseControle);\nconsole.log(cruiseControle.speed);\ndecrease.call(cruiseControle);\nconsole.log(cruiseControle.speed);\n\n// ЕХ\nclass Carr {\n  static maxSPEED = 60;\n  constructor(par) {\n    this.brand = par.brand;\n    this.speed = par.speed;\n  }\n\n  speedSensor(maxSpeed) {\n    return this.speed >= maxSpeed\n      ? `Autention, ${this.brand} has the hight speed - ${this.speed}.`\n      : `${this.brand}'s speed is ${this.speed} - it's normal.`;\n  }\n}\n\nconst bMw = new Carr({ brand: 'bmw', speed: 70 });\nconst lexus = new Carr({ brand: 'lexus', speed: 50 });\nconsole.log(bMw, lexus);\n\nconsole.log(\n  bMw.speedSensor(Carr.maxSPEED),\n  'and',\n  lexus.speedSensor(Carr.maxSPEED)\n);\n\n// геттер - звертаэмось через . і метод повертає значення властивості\n// сеттер - звертаємось через властив = Єнове значенняЄ і метод відпрацює і перезапише властивість\n// сеттер краще чим просто присвоїти нові дані тим , що це метод і там можна виконувати додаткові перевірки\n//.................................... приватні методи (інкапсуляція) викор якщо зовні вони не мають сенсу\nclass CarsS {\n  #price;\n\n  constructor(par) {\n    this.brand = par.brand;\n    this.#price = par.price;\n  }\n  get price() {\n    return this.#price;\n  }\n  #typeOfPrice(data, type) {\n    if (typeof data === type) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  set price(newPrice) {\n    if (this.#typeOfPrice(newPrice, 'number')) {\n      this.#price = newPrice;\n      return;\n    } else {\n      return `Invalid`;\n    }\n  }\n}\n\nconst infinity = new CarsS({ brand: 'infiniti', price: 70000 });\n\nconsole.log((infinity.price = '9'));\nconsole.log(infinity);\n\n// ............................................статичні методи\n// статичний метод що відпрацьовує кожного разу коли створ екзкмпляр класу\n\nclass d {\n  static quantity = 0;\n  //  static increment(price){\n  // return d.quantity += this.price;\n  // }\n  static increment() {\n    return (d.quantity += 1);\n  }\n  constructor(par) {\n    this.name = par.name;\n    this.price = par.price;\n    // d.increment(price);\n    d.increment();\n  }\n}\n\n//  .............................................................наслідування класів\nclass Hero {\n  constructor(par) {\n    this.name = par.name;\n    this.xp = par.xp;\n  }\n  addXP(num) {\n    return `XP increment on ${(this.xp += num)}`;\n  }\n}\n\nclass Warior extends Hero {\n  // constructor(par) {\n  //   super({name: par.name, xp: par.xp});\n  //   this.spells = par.spells;\n  // }\n  constructor({ spells, ...rest }) {\n    super(rest);\n    this.spells = spells;\n  }\n}\n\nconst valhala = new Warior({ name: 'Valhala', xp: 500, spells: ['fireball'] });\nconsole.log(valhala);\n\n// ...................................................PRACTICE\n// ex this is object us\nconst us = {\n  name: 'Poly',\n  sayHi() {\n    let arrow = () => console.log(this.name);\n    arrow();\n  },\n};\n// good\nconst yyyyb = us.sayHi.bind(us);\nconsole.log(yyyyb);\n// undefined - not good\n// const yyyyb = us.sayHi();\n// console.log(yyyyb);\n\n// EX1 the function takes a parametr (is the array of names), she iterating the array and adding greeting for every names . the function return new array (\"name\" hello)\nfunction sayHi(array) {\n  return array.map(element => `${element} hello`);\n}\nconsole.log(sayHi(['Kate', 'Joe', 'Rocky']));\n// ex 2 check whether students  are over 18 y.o.\nconst studentsGroup = [\n  { name: 'Mike', age: 17, id: 123 },\n  { name: 'Juli', age: 20, id: 345 },\n  { name: 'Oddi', age: 19, id: 567 },\n  { name: 'Jone', age: 18, id: 789 },\n];\nconsole.log(studentsGroup.every(stud => stud.age > 18));\n\n// the fun takes par - the array of objUsers and the id; she find obj with this id and return name for this object or \"The user with this \"id\" is undefined\"\nfunction finedNameOfID(array, ID) {\n  const user = array.find(obj => obj.id === ID);\n  if (user) {\n    return user.name;\n  } else {\n    return `The user with ID ${ID} is undefined`;\n  }\n}\n\nconsole.log(finedNameOfID(studentsGroup, 3495));\n\n// EX collect all topics of all courses in array allTopics  and filtered this array that he has unice elements\nconst courses = [\n  { name: 'basic', topics: ['HTML', 'CSS', 'GitHub', 'VSCode'] },\n  {\n    name: 'intermediate',\n    topics: ['HTML', 'CSS', 'GitHub', 'React', 'JS', 'VSCode'],\n  },\n  {\n    name: 'basic JS',\n    topics: [\n      'HTML',\n      'CSS',\n      'GitHub',\n      'VSCode',\n      'JS',\n      'Type system',\n      'LOOPS',\n      'DOM',\n    ],\n  },\n  {\n    name: 'intermediate JS',\n    topics: ['HTML', 'CSS', 'VSCode', 'GitHub', 'NPM', 'AJAH', 'Bundlers'],\n  },\n];\n// indexOf(el) повертає перший індекс вказаного елементу ш метод filter перевіряє щоб індекси співпадали і відбирає ці унікальні елементи в масив\nconst allTopics = courses\n  .flatMap(obj => obj.topics)\n  .filter((el, indx, arr) => arr.indexOf(el) === indx);\nconsole.log(allTopics);\n\n// EX the function calculate the common age of boys (sex: male)\nconst peoples = [\n  { name: 'Naomi', age: 29, sex: 'female' },\n  { name: 'Quentine', age: 26, sex: 'male' },\n  { name: 'Kevin', age: 32, sex: 'male' },\n  { name: 'Lola', age: 27, sex: 'female' },\n];\nfunction getTotalBoysYers(array) {\n  return array\n    .filter(obj => obj.sex === 'male')\n    .reduce((acc, obj) => obj.age + acc, 0);\n}\nconsole.log(getTotalBoysYers(peoples));\n\n//  EX fined products that have price > 10 and than calculate their total cost\nconst products = [\n  { name: 'Cheese', price: 50 },\n  { name: 'Chiken', price: 80 },\n  { name: 'Losose', price: 100 },\n  { name: 'Carrot', price: 10 },\n  { name: 'Onion', price: 9 },\n];\nconst totalCost = products\n  .filter(item => item.price > 10)\n  .reduce((acc, item) => acc + item.price, 0);\nconsole.log(totalCost);\n\n// you need to call the method showInfo  that he displayed the information from each object\nconst tel_1 = {\n  regNumber: 'AE834567',\n  brand: 'Huavei',\n  showInfo(country) {\n    return `${country} ${this.regNumber} ${this.brand}`;\n  },\n};\nconst tel_2 = {\n  regNumber: 'DP725481',\n  brand: 'Samsung',\n};\n\nconst ue = tel_1.showInfo.bind(tel_2);\nconsole.log(ue('China'));\n// or\nconsole.log(tel_1.showInfo.call(tel_2, 'China'));\n// write the class Rectangle that has propertys - height and width and the methot that calculetes Rectangle area\nclass Rectangle {\n  constructor(par) {\n    this.height = par.height;\n    this.width = par.width;\n  }\n  areaOfTheRectangle() {\n    return this.height * this.width;\n  }\n}\n\nconst rect_1 = new Rectangle({ height: 18, width: 34 });\nconsole.log(rect_1.areaOfTheRectangle());\n\n//  EX create class Car that have constructor for saving properties - brand and year of production. 1)add method that calculate the age of car (current year - year of production ) and return `The age of this car - ${}` 2)add check if age>5 return `the car needs maintenance` else \"the car not needs the  maintenance now\" 3) add check if the year of production (>) current year return \"Error: the year of production can't be later than the current year\"\nconst now = new Date();\nconsole.log(now);\nconst currentYear = now.getFullYear();\nconsole.log(currentYear);\n\nclass Carrr {\n  constructor(par) {\n    this.brand = par.brand;\n    this.yearProd = par.yearProd;\n  }\n  chekAgeOfTheCar(currentYear) {\n    const ageCar = currentYear - this.yearProd;\n    return ageCar || `the age of ${this.brand} - ${ageCar}`;\n  }\n  checkActualityMaintenance(callback) {\n    const checkingAge = Number(callback);\n    if (this.yearProd > currentYear) {\n      return \"Error: the year of production can't be later than the current year\";\n    } else if (checkingAge > 5) {\n      return 'the car needs maintenance';\n    } else {\n      return 'the car not needs the  maintenance now';\n    }\n  }\n}\n\nconst subaru = new Carrr({ brand: 'Subaru', yearProd: 2019 });\nconsole.log(subaru);\n\nconsole.log(subaru.chekAgeOfTheCar(currentYear));\n\nconsole.log(\n  subaru.checkActualityMaintenance(subaru.chekAgeOfTheCar(currentYear))\n);\n// EX write the class Client1 wich create the object with properties - login , email. announce them like private properties. make access to them through get and set .\n\nclass Client1 {\n  #email;\n  #login;\n  constructor(par) {\n    this.#email = par.email;\n    this.#login = par.login;\n  }\n  get email() {\n    return this.#email;\n  }\n  set email(newEmail) {\n    return (this.#email = newEmail);\n  }\n  get login() {\n    return this.#login;\n  }\n  set login(newLogin) {\n    return (this.#login = newLogin);\n  }\n}\nconst client1 = new Client1({\n  email: 'fafaf.gmail.com',\n  login: 'fafafafafafa',\n});\nconsole.log(client1.login);\nconsole.log((client1.login = 'hohohohoh'));\n","'use strict';\n//                                MODUL 5 - Перебираючі методи масиву\n\nfunction greet(name) {\n  return `Welcome ${name}!`;\n}\n// Викликаємо функцію greet і виводимо результат у змінну\nconst result23 = greet('Mango'); // \"Welcome Mango!\"\n\n// Посилання на функцію greet передали у змінну, не викликаючи її\nconst funLink = greet; // ƒ greet() {return `Welcome ${name}!`}\n\n//..................................................КОЛБЕK ФУНКЦІЇ\n//........................................Функція зворотного виклику (callback, колбек) — це функція, яка передається іншій функції як аргумент через посилання, а та у свою чергу використовує передану функцію.\n// У прикладі функції greet і notify — це колбек-функції, тому що ми передаємо їх як аргумент у функцію registerGuest. Ім'я параметра для колбека може бути довільним, головне пам'ятати, що значенням буде функція.\n//........................................Функція вищого порядку (higher order function) — функція, яка приймає в якості параметрів інші функції або повертає функцію в якості результату.\n// У прикладі це функція registerGuest, тому що вона очікує іншу функцію як параметр і викликає її.\nfunction greet2(name) {\n  console.log(`Welcome ${name}!`);\n}\nfunction notify(name) {\n  console.log(`Dear ${name}, your room will be ready in 30 minutes`);\n}\nfunction registerGuest(name, callback) {\n  console.log(`Registering ${name}!`);\n  callback(name);\n}\nregisterGuest('Mango', greet2); // \"Registering Mango!\"\n// \"Welcome Mango!\"\nregisterGuest('Mango', notify); // \"Registering Mango!\"\n// \"Dear Mango, your room will be ready in 30 minutes\"\n//..........................................................Інлайн-колбеки\n// Інлайн-колбеки - callback функція оголошена безпосередньо на момент виклику функції, в яку передаємо колбек (якщо колбек-функція маленька і потрібна тільки для передачі аргументом). Вони будуть доступні тільки в якості значення параметра і більше ніде в коді.\nfunction registerGuest2(name, callback) {\n  console.log(`Registering ${name}!`);\n  callback(name);\n}\n// Передаємо інлайн-функцію greet у якості колбека\nregisterGuest2('Mango', function greet(name) {\n  console.log(`Welcome ${name}!`);\n});\n// Передаємо інлайн-функцію notify у якості колбека\nregisterGuest2('Poly', function notify(name) {\n  console.log(`Dear ${name}, your room will be ready in 30 minutes`);\n});\n\n//..................................................Метод forEach(callback)\n// Метод forEach(callback) — це метод перебирання масиву, який використовується для заміни циклів for і for...of в роботі з колекцією.\n// array.forEach(function callback(element, index, array) {\n//   // Тіло колбек-функції\n// });\n// -Поелементно перебирає масив array\n// -Викликає колбек-функцію для кожного елемента масиву\n// -Повертає undefined, навіть якщо явно задати вираз після return\n// Колбек-функція методу forEach() завжди отримує такі параметри: значення поточного елемента масиву element, його індекс index і власне посилання на вихідний масив array. Імена параметрів довільні, але дуже важлива їх послідовність!. Також не всі параметри обов*язково оголошувати. Якщо тобі потрібен тільки перший параметр element (це найчастіший випадок), то наступні параметри index та array можна не оголошувати.\n\n// ex Доповни виклик метода forEach, передавши йому колбек-функцію, яка на кожній ітерації додає до totalPrice значення поточного елемента масива orderedItems.\nfunction calculateTotalPrice(orderedItems) {\n  let totalPrice = 0;\n\n  orderedItems.forEach(function (element) {\n    totalPrice += element;\n  });\n\n  return totalPrice;\n}\nconsole.log(calculateTotalPrice([1, 2, 3]));\n\n// ex\nfunction filterArray(numbers, value) {\n  const newArray = [];\n  numbers.forEach(function callback(element) {\n    if (element > value) {\n      newArray.push(element);\n    }\n  });\n  return newArray;\n}\nconsole.log(filterArray([1, 2, 3, 4, 5, 6], 3));\n\n//................................................Стрілочні функції\n// Стрілочні функції (сленг — “стрілки”) мають скорочений, лаконічніший синтаксис, що зменшує обсяг коду, особливо коли функція маленька або якщо вона використовується як колбек. Cтрілки створюються як функціональний вираз, і їх необхідно присвоювати змінній.\n//   // Звичайне оголошення функції\n// function classicAdd(a, b, c) {\n//     return a + b + c;\n//   }\n\n//   // Те саме стрілочною функцією\n//   const arrowAdd = (a, b, c) => {\n//     return a + b + c;\n//   };\n// -Ключове слово function не використовується\n// -Одразу зазначається оголошення параметрів\n// -Після параметрів використовується символ => і тіло функції у фігурних дужках\n// -Якщо параметр один, його можна оголошувати без круглих дужок.\n// -Якщо параметри відсутні, то обов'язково повинні бути порожні круглі дужки.\nconst calculateTotalPrice2 = (quantity, pricePerItem) => {\n  return quantity * pricePerItem;\n};\n//                                               У стрілочної функції:\n//  1) явне повернення (explicit return) - запис функції з  фігурними дужками та обов*язково поставити return якщо вона має щось повернути.Такий синтаксис використовується в тому випадку, якщо в тілі функції потрібно виконати ще якісь інструкції, окрім повернення значення\nconst add8 = (a, b, c) => {\n  console.log(a, b, c);\n  return a + b + c;\n};\n// 2) неявне повернення (implicit return) - Якщо фігурні дужки відсутні, то повертається результат виразу, який стоїть після =>. return не використовується.він доречний тільки тоді, коли в тілі функції не потрібно виконувати жодних додаткових інструкцій, окрім повернення значення.\n// До\nfunction classicAdd(a, b, c) {\n  return a + b + c;\n}\n\n// Після\nconst arrowAdd = (a, b, c) => a + b + c;\n\n//   !!!!!!!!!!!!!!!!!!!!!!!!У стрілочних функцій немає локальної змінної arguments, що містить усі аргументи. Якщо необхідно зібрати всі аргументи в масив, використовується операція REST.\nconst add2 = (...args) => {\n  console.log(args);\n};\n//   ex\nconst calculateTotalPrice33 = (...orderedItems) => {\n  let totalPrice = 0;\n\n  orderedItems.forEach(item => (totalPrice += item));\n\n  return totalPrice;\n};\nconsole.log(calculateTotalPrice33(2, 3, 4, 5));\n\n//.....................................................Методи map і flatMap\n// ...............Функція з побічними ефектами — це функція, яка в процесі виконання може:\n// -змінювати або використовувати глобальні змінні\n// -змінювати значення аргументів посилального типу (arrays, objects)\n// -виконувати операції введення-виведення тощо\n// const dirtyMultiply = (array, value) => {\n//   for (let i = 0; i < array.length; i += 1) {\n//     array[i] = array[i] * value;\n//   }\n// };\n\n// const numbers = [1, 2, 3, 4, 5];\n// dirtyMultiply(numbers, 2);\n// // Відбулася мутація вихідних даних - масиву numbers\n// console.log(numbers); // [2, 4, 6, 8, 10]\n\n// Функція dirtyMultiply(array, value) множить кожен елемент масиву array на число value. Вона змінює (мутує) вихідний масив за посиланням.\n\n//...............Чиста функція (pure function) — це функція, результат якої залежить тільки від значень переданих аргументів. За умови однакових аргументів вона завжди повертає один і той самий результат і не має побічних ефектів, тобто не змінює значення аргументів.\n// const pureMultiply = (array, value) => {\n//     const newArray = [];\n\n//     array.forEach(element => {\n//       newArray.push(element * value);\n//     });\n\n//     return newArray;\n//   };\n\n//   const numbers = [1, 2, 3, 4, 5];\n//   const doubledNumbers = pureMultiply(numbers, 2);\n\n//   // Мутація вихідних даних не відбулася\n//   console.log(numbers); // [1, 2, 3, 4, 5]\n//   // Функція повернула новий масив зі зміненими даними\n//   console.log(doubledNumbers); // [2, 4, 6, 8, 10]\n\n// ex\nfunction changeEven(numbers, value) {\n  const newArray = [];\n  for (let i = 0; i < numbers.length; i += 1) {\n    if (numbers[i] % 2 === 0) {\n      newArray.push(numbers[i] + value);\n    } else {\n      newArray.push(numbers[i]);\n    }\n  }\n  return newArray;\n}\nconsole.log(changeEven([2, 8, 3, 7, 4, 6], 10));\n\n//   ...............................................Перебираючі методи масиву\n// У JavaScript є методи масивів, які прийшли з функціональних мов. Більшість із перебираючих методів масивів — це чисті функції. Вони створюють новий масив, заповнюють його, застосовуючи до значення кожного елемента зазначену колбек-функцію, після чого повертають цей новий масив.\n// array.method(callback(currentValue, index, array))\n// ......................................................Метод map()\n// Метод map(callback) використовується для трансформації масиву. Він викликає колбек-функцію для кожного елемента вихідного масиву, а результат її роботи записує в новий масив, який і буде результатом виконання методу.\n// array.map((element, index, array) => {\n//   // Тіло колбек-функції\n// });\n// -Поелементно перебирає оригінальний масив\n// -Не змінює оригінальний масив\n// -Результат роботи колбек-функції записується в новий масив\n// -Повертає новий масив такої ж довжини, як і в масиву, до якого він був застосований\n\n// Його можна використовувати для того, щоб змінити кожен елемент масиву. Оригінальний масив використовується як еталон, на основі якого можна зробити іншу колекцію.\nconst planets29 = ['Earth', 'Mars', 'Venus', 'Jupiter'];\n\nconst planetsInUpperCase = planets29.map(planet => planet.toUpperCase());\nconsole.log(planetsInUpperCase); // [\"EARTH\", \"MARS\", \"VENUS\", \"JUPITER\"]\n\n// ex щоб у змінній planetsLengths вийшов масив, що буде складатися з довжин назв кожної планети з масиву planets. Обов'язково використовуй метод map().\nconst planets45 = ['Earth', 'Mars', 'Venus', 'Jupiter'];\n\nconst planetsLengths = planets45.map(element => element.length);\n\n// .......................Масив об'єктів\n// map()\nconst books = [\n  {\n    title: 'The Last Kingdom',\n    author: 'Bernard Cornwell',\n    rating: 8.38,\n  },\n  {\n    title: 'Beside Still Waters',\n    author: 'Robert Sheckley',\n    rating: 8.51,\n  },\n  {\n    title: 'The Dream of a Ridiculous Man',\n    author: 'Fyodor Dostoevsky',\n    rating: 7.75,\n  },\n  { title: 'Redder Than Blood', author: 'Tanith Lee', rating: 7.94 },\n  { title: 'Enemy of God', author: 'Bernard Cornwell', rating: 8.67 },\n];\n\nconst titles = books.map(element => element.title);\nconsole.log(titles);\n\n// ............................................Метод flatMap()\n// Метод flatMap(callback) аналогічний методу map(), але застосовується у випадках, коли результат — це багатовимірний масив, який необхідно «розгладити».\n// - Метод flatMap викликає колбек-функцію для кожного елемента вихідного масиву, а результат її роботи записує в новий масив. Відмінність від map() полягає в тому, що новий масив «розгладжується» на глибину, що дорівнює одиниці (одна вкладеність). Цей розгладжений (плоский) масив і є результатом роботи flatMap().\nconst students = [\n  { name: 'Mango', courses: ['mathematics', 'physics'] },\n  { name: 'Poly', courses: ['science', 'mathematics'] },\n  { name: 'Kiwi', courses: ['physics', 'biology'] },\n];\nconst mappedCourses = students.map(student => student.courses);\nconsole.log(mappedCourses); // [[\"mathematics\", \"physics\"], [\"science\", \"mathematics\"], [\"physics\", \"biology\"]]\n\nconst flattenedCourses = students.flatMap(student => student.courses);\nconsole.log(flattenedCourses); // [\"mathematics\", \"physics\", \"science\", \"mathematics\", \"physics\", \"biology\"];\n\n//   ex\n\nconst users = [\n  {\n    name: 'Moore Hensley',\n    email: 'moorehensley@indexia.com',\n    eyeColor: 'blue',\n    friends: ['Sharron Pace'],\n    isActive: false,\n    balance: 2811,\n    skills: ['ipsum', 'lorem'],\n    gender: 'male',\n    age: 37,\n  },\n  {\n    name: 'Sharlene Bush',\n    email: 'sharlenebush@tubesys.com',\n    eyeColor: 'blue',\n    friends: ['Briana Decker', 'Sharron Pace'],\n    isActive: true,\n    balance: 3821,\n    skills: ['tempor', 'mollit', 'commodo', 'veniam', 'laborum'],\n    gender: 'female',\n    age: 34,\n  },\n  {\n    name: 'Ross Vazquez',\n    email: 'rossvazquez@xinware.com',\n    eyeColor: 'green',\n    friends: ['Marilyn Mcintosh', 'Padilla Garrison', 'Naomi Buckner'],\n    isActive: false,\n    balance: 3793,\n    skills: ['nulla', 'anim', 'proident', 'ipsum', 'elit'],\n    gender: 'male',\n    age: 24,\n  },\n  {\n    name: 'Elma Head',\n    email: 'elmahead@omatom.com',\n    eyeColor: 'green',\n    friends: ['Goldie Gentry', 'Aisha Tran'],\n    isActive: true,\n    balance: 2278,\n    skills: ['adipisicing', 'irure', 'velit'],\n    gender: 'female',\n    age: 21,\n  },\n  {\n    name: 'Carey Barr',\n    email: 'careybarr@nurali.com',\n    eyeColor: 'blue',\n    friends: ['Jordan Sampson', 'Eddie Strong'],\n    isActive: true,\n    balance: 3951,\n    skills: ['ex', 'culpa', 'nostrud'],\n    gender: 'male',\n    age: 27,\n  },\n  {\n    name: 'Blackburn Dotson',\n    email: 'blackburndotson@furnigeer.com',\n    eyeColor: 'brown',\n    friends: ['Jacklyn Lucas', 'Linda Chapman'],\n    isActive: false,\n    balance: 1498,\n    skills: ['non', 'amet', 'ipsum'],\n    gender: 'male',\n    age: 38,\n  },\n  {\n    name: 'Sheree Anthony',\n    email: 'shereeanthony@kog.com',\n    eyeColor: 'brown',\n    friends: ['Goldie Gentry', 'Briana Decker'],\n    isActive: true,\n    balance: 2764,\n    skills: ['lorem', 'veniam', 'culpa'],\n    gender: 'female',\n    age: 39,\n  },\n];\nconst getUserEmails = users.map(user => user.email);\nconsole.log(getUserEmails);\n\n//..............................................Метод filter()\n// Метод filter(callback) використовується для єдиної операції — фільтрації масиву. Під фільтрацією масиву мається на увазі відбір усіх елементів з колекції за певним критерієм.\n\n// array.filter((element, index, array) => {\n//   // Тіло колбек-функції\n// });\n// -Не змінює оригінальний масив.\n// -Поелементно перебирає оригінальний масив.\n// -Повертає новий масив.\n// -Додає в масив, що повертається, елементи, які задовольняють умову колбек-функції.\n// -Якщо колбек повернув true, елемент додається в масив, що повертається.\n// -Якщо колбек повернув false, елемент не додається в масив, що повертається.\n// -Якщо жоден елемент не задовольнив умову, повертає ПОРОЖНІЙ МАСИВ.\n\nconst values4 = [51, -3, 27, 21, -68, 42, -37];\nconst positiveValues = values4.filter(value => value >= 0);\nconsole.log(positiveValues); // [51, 27, 21, 42]\n// до positiveValues потрапили всі елементи масиву values, які задовольнили умову колбека, тобто були >= 0\n// Отже, метод filter викликає колбек-функцію для кожного елемента вихідного масиву. Якщо результат її виконання true, поточний елемент додається в новий масив.\n// ex\nconst numbers = [17, 24, 82, 61, 36, 18, 47, 52, 73];\n//                                             парні\nconst evenNumbers = numbers.filter(element => !(element % 2));\n//                                           непарні\nconst oddNumbers = numbers.filter(element => element % 2);\nconsole.log(evenNumbers, oddNumbers);\nconst arr45 = [2, 4, 6];\nconst result45 = arr45.filter(el => el * 2);\nconsole.log(result45);\n// ex\nconst books999 = [\n  {\n    title: 'The Last Kingdom',\n    author: 'Bernard Cornwell',\n    rating: 8.38,\n  },\n  {\n    title: 'Beside Still Waters',\n    author: 'Robert Sheckley',\n    rating: 8.51,\n  },\n  {\n    title: 'The Dream of a Ridiculous Man',\n    author: 'Fyodor Dostoevsky',\n    rating: 7.75,\n  },\n  { title: 'Redder Than Blood', author: 'Tanith Lee', rating: 7.94 },\n  { title: 'Enemy of God', author: 'Bernard Cornwell', rating: 8.67 },\n];\n\nconst MIN_RATING = 8;\nconst AUTHOR = 'Bernard Cornwell';\n\nconst topRatedBooks = books999.filter(book => book.rating >= MIN_RATING);\nconst booksByAuthor = books999.filter(book => book.author === AUTHOR);\nconsole.log(topRatedBooks, booksByAuthor);\n//   ex filter by color eyes\nconst users777 = [\n  {\n    name: 'Ross Vazquez',\n    email: 'rossvazquez@xinware.com',\n    eyeColor: 'green',\n    friends: ['Marilyn Mcintosh', 'Padilla Garrison', 'Naomi Buckner'],\n    isActive: false,\n    balance: 3793,\n    gender: 'male',\n    age: 14,\n  },\n  {\n    name: 'Elma Head',\n    email: 'elmahead@omatom.com',\n    eyeColor: 'green',\n    friends: ['Goldie Gentry', 'Aisha Tran'],\n    isActive: true,\n    balance: 2278,\n    gender: 'female',\n    age: 21,\n  },\n  {\n    name: 'Carey Barr',\n    email: 'careybarr@nurali.com',\n    eyeColor: 'blue',\n    friends: ['Jordan Sampson', 'Eddie Strong'],\n    isActive: true,\n    balance: 3951,\n    gender: 'male',\n    age: 29,\n  },\n  {\n    name: 'Sheree Anthony',\n    email: 'shereeanthony@kog.com',\n    eyeColor: 'brown',\n    friends: ['Goldie Gentry', 'Briana Decker'],\n    isActive: true,\n    balance: 2764,\n    gender: 'female',\n    age: 60,\n  },\n];\nconst getUsersWithEyeColor = (users777, color) => {\n  return users777.filter(user => user.eyeColor === color);\n};\nconsole.log(getUsersWithEyeColor(users777, 'green'));\n\n// ex filter by age in еру кфтпу (diapasone) (min && max)\nconst getUsersWithAge = (users, minAge, maxAge) => {\n  return users.filter(user => user.age >= minAge && user.age <= maxAge);\n};\nconsole.log(getUsersWithAge(users777, 22, 30));\n\n//...............................................Метод find()\n// Метод find(callback) дозволяє знайти і повернути перший відповідний елемент, що задовольняє умову, після чого перебирання масиву припиняється. Тобто він, на відміну від методу filter(callback), шукає до першого збігу.\n\n// array.find((element, index, array) => {\n//   // Тіло колбек-функції\n// });\n\n// -Не змінює оригінальний масив\n// -Поелементно перебирає оригінальний масив\n// -Повертає перший елемент, що задовольняє умову, тобто коли колбек повертає true\n// -Якщо жоден елемент не задовольнив умову, тобто для всіх елементів колбек повернув false, метод повертає UNDEFINDED\n\n// Метод find() використовується для одного завдання — пошуку першого елемента, який задовольняє умову. Наприклад, пошук користувача за поштою, автомобіля — за серійним номером, книги — за назвою тощо.\n// ex find the obj with this title or this author\nconst books3333 = [\n  {\n    title: 'The Last Kingdom',\n    author: 'Bernard Cornwell',\n    rating: 8.38,\n  },\n  {\n    title: 'Beside Still Waters',\n    author: 'Robert Sheckley',\n    rating: 8.51,\n  },\n  {\n    title: 'The Dream of a Ridiculous Man',\n    author: 'Fyodor Dostoevsky',\n    rating: 7.75,\n  },\n  { title: 'Redder Than Blood', author: 'Tanith Lee', rating: 7.94 },\n];\nconst bookTitel = 'The Dream of a Ridiculous Man';\nconst authorFind = 'Robert Sheckley';\n\nconst bookWithTitle = books3333.find(book => book.title === bookTitel);\nconst bookByAuthor = books3333.find(book => book.author === authorFind);\n\n// ex find the obj with this email\nconst users888 = [\n  {\n    name: 'Moore Hensley',\n    email: 'moorehensley@indexia.com',\n    eyeColor: 'blue',\n    friends: ['Sharron Pace'],\n    isActive: false,\n    balance: 2811,\n    gender: 'male',\n  },\n  {\n    name: 'Sharlene Bush',\n    email: 'sharlenebush@tubesys.com',\n    eyeColor: 'blue',\n    friends: ['Briana Decker', 'Sharron Pace'],\n    isActive: true,\n    balance: 3821,\n    gender: 'female',\n  },\n  {\n    name: 'Ross Vazquez',\n    email: 'rossvazquez@xinware.com',\n    eyeColor: 'green',\n    friends: ['Marilyn Mcintosh', 'Padilla Garrison', 'Naomi Buckner'],\n    isActive: false,\n    balance: 3793,\n    gender: 'male',\n  },\n  {\n    name: 'Elma Head',\n    email: 'elmahead@omatom.com',\n    eyeColor: 'green',\n    friends: ['Goldie Gentry', 'Aisha Tran'],\n    isActive: true,\n    balance: 2278,\n    gender: 'female',\n  },\n  {\n    name: 'Carey Barr',\n    email: 'careybarr@nurali.com',\n    eyeColor: 'blue',\n    friends: ['Jordan Sampson', 'Eddie Strong'],\n    isActive: true,\n    balance: 3951,\n    gender: 'male',\n  },\n  {\n    name: 'Blackburn Dotson',\n    email: 'blackburndotson@furnigeer.com',\n    eyeColor: 'brown',\n    friends: ['Jacklyn Lucas', 'Linda Chapman'],\n    isActive: false,\n    balance: 1498,\n    gender: 'male',\n  },\n  {\n    name: 'Sheree Anthony',\n    email: 'shereeanthony@kog.com',\n    eyeColor: 'brown',\n    friends: ['Goldie Gentry', 'Briana Decker'],\n    isActive: true,\n    balance: 2764,\n    gender: 'female',\n  },\n];\nconst getUserWithEmail = (users, email) => {\n  return users.find(user => user.email === email);\n};\nconsole.log(getUserWithEmail(users888, 'careybarr@nurali.com'));\n//...................................................................Метод every()\n// Метод every(callback) перевіряє, чи задовольняють усі елементи умову колбек-функції.\n// array.every((element, index, array) => {\n//   // Тіло колбек-функції\n// });\n\n// -Не змінює оригінальний масив\n// -Поелементно перебирає оригінальний масив\n// -Повертає true, ЯКЩО ВСІ ЕЛЕМЕНТИ МАСИВУ ЗАДОВІЛЬНЯЮТЬ УМОВУ\n// -Повертає false, якщо хоча б один елемент масиву не задовольняє умову\n// -Перебирання масиву припиняється, якщо колбек повертає false\n// ex перевіряємо, чи всі користувачі зараз активні (властивість isActive) і повертала true або false.\nconst isEveryUserActive = users => {\n  return users.every(user => user.isActive === true);\n};\nconsole.log(isEveryUserActive(users888));\n\n// .............................................Метод some()\n// Метод some(callback) перевіряє, чи задовольняє хоча б один елемент умову колбек-функції.\n// array.some((element, index, array) => {\n//   // Тіло колбек-функції\n// });\n\n// Не змінює оригінальний масив\n// Поелементно перебирає оригінальний масив\n// Повертає true, якщо ХОЧА Б ОДИН ЕЛЕМЕНТ МАСИВУ ЗАДОВІЛЬНЯЄ УМОВУ\n// Повертає false, якщо жоден елемент масиву не задовольняє умову\n// Перебирання масиву припиняється, якщо колбек повертає true\n\n// // Чи є хоча б один елемент, що більший або дорівнює нулю? - так\n// [-7, -20, 3, -10, -14].some(value => value >= 0); // true\n\n// // Чи є хоча б один елемент, що менший від нуля? - ні\n// [1, 2, 3, 4, 5].some(value => value < 0); // false\n\n// ex\nconst isAnyUserActive = users => {\n  return users.some(user => user.isActive === true);\n};\nconsole.log(isAnyUserActive(users888));\n\n// ......................................................................Метод reduce()\n// Метод reduce(callback, initialValue) використовується для послідовної обробки кожного елемента масиву із збереженням проміжного результату.\n// array.reduce((previousValue, element, index, array) => {\n//   // Тіло колбек-функції\n// }, initialValue);\n\n// -Не змінює оригінальний масив\n// -Поелементно перебирає оригінальний масив\n// -Повертає все, що завгодно (об*єкт, масив, рядок, число тощо)\n// -Може замінити функціонал будь-якого іншого перебираючого методу масиву та навіть їх комбінацію\n\n// Метод reduce() очікує 2 параметри:\n// 1-й параметр (обов*язковий) — колбек-функція, яка \"опрацьовує\" кожен елемент масиву;\n// 2-й параметр (не обов*язковий) — initialValue початкове значення акумулятора.\n\n// Колбек-функція з параметра редьюса очікує в свою чергу чотири параметри. Ці параметри, так само як і в колбеках інших перебираючих методів масиву, можна не оголошувати, якщо вони вам не потрібні, але не можна порушувати їх послідовність:\n// 1-й параметр (previousValue) — це акумулятор, тобто проміжний результат. Значення, яке поверне колбек-функція на поточній ітерації, буде значенням цього параметра на наступній ітерації;\n// 2-й параметр — поточний елемент масиву;\n// 3-й параметр — індекс поточної ітерації;\n// 4-й параметр — посилання на вихідний масив.\n\n// Найлегше уявити його роботу на прикладі підрахунку суми елементів масиву.\nconst total999 = [2, 7, 3].reduce((previousValue, number) => {\n  return previousValue + number;\n}, 0);\nconsole.log(total999); // 12\n// -Початкове значення акумулятора 0\n// -перша ітерація колбек-функції 0 + 2 поверне 2\n// -друга ітерація колбек-функції 2 + 7 поверне 9\n// -третя ітерація колбек-функції 9 + 3 поверне 12\n// ----\n// Результатом коду вище буде 12.\n// ---\n// Тобто метод reduce() використовується, коли необхідно взяти «багато» і привести до «одного». У повсякденних завданнях його застосування зводиться до роботи з числами.\n\n// ex find общее время (total time) than find среднее время (average time)\nconst players = {\n  mango: 1270,\n  poly: 468,\n  ajax: 710,\n  kiwi: 244,\n};\nconst playtimes = Object.values(players); // [1270, 468, 710, 244]\n\nconst totalPlayTime = playtimes.reduce(\n  (valueAcum, element) => valueAcum + element\n);\n\nconst averagePlayTime = totalPlayTime / playtimes.length;\n\n// ex розрахувати середній час, проведений в одній грі для кожного гравця, і отримати загальну суму цих значень часу у змінній totalAveragePlaytimePerGame. Розрахувати час для кожного з гравців можна, розділивши його час (властивість playtime) на кількість ігор (властивість gamesPlayed).\n// Поради: -Використовуй метод reduce() для ітерації по масиву players та обчислення загальної суми середнього часу на одну гру. -Усередині колбек функції reduce(), поділи playtime гравця на gamesPlayed, щоб отримати середній час, витрачений на одну гру кожним гравцем. -Накопичуй результат у змінній acc і повертай його в кінці кожної ітерації. - Ініціалізуй параметр acc методу reduce() початковим значенням 0, щоб уникнути отримання NaN при виконанні обчислень.\nconst players90 = [\n  { name: 'Mango', playtime: 1270, gamesPlayed: 4 },\n  { name: 'Poly', playtime: 469, gamesPlayed: 2 },\n  { name: 'Ajax', playtime: 690, gamesPlayed: 3 },\n  { name: 'Kiwi', playtime: 241, gamesPlayed: 1 },\n];\n\nconst totalAveragePlaytimePerGame = players90.reduce((total, player) => {\n  const acc = total + player.playtime / player.gamesPlayed;\n  return acc;\n}, 0);\nconsole.log(totalAveragePlaytimePerGame);\n\n// ex Доповни функцію calculateTotalBalance(users) таким чином, щоб вона рахувала і повертала суму всіх коштів (властивість balance), які зберігають користувачі з масиву users.\nconst calculateTotalBalance = users =>\n  users.reduce((total, user) => {\n    return total + user.balance;\n  }, 0);\n\n// .............................................Метод toSorted()\n// Метод toSorted() сортує елементи масиву.\n// array.toSorted();\n\n// -Сортує вихідний масив\n// -Повертає новий масив\n// -За замовчуванням сортує за зростанням\n\n//  за замовчуванням перед сортуванням метод toSorted() приводить усі елементи масиву до рядків, то фактично елементи сортуються як рядки, тобто на основі їхніх значень у таблиці Unicode. Стандартне сортування чисел виглядає незвично, коли ми думаємо про числа, але зрозуміло, якщо знати, що числа були перетворені на рядки.\n\nconst scores = [27, 2, 41, 4, 7, 3, 75];\n\nconsole.log(scores.toSorted()); // [2, 27, 3, 4, 41, 7, 75]\n// ........................Масив рядків\n// Масив рядків сортується за алфавітом.\nconst studentsS = ['Jacob', 'Artemis', 'Solomon', 'Adrian', 'Kai', 'Ganymede'];\nconsole.log(students.toSorted()); // [ \"Adrian\", \"Artemis\", \"Ganymede\", \"Jacob\", \"Kai\", \"Solomon\" ]\n\n// Водночас порядковий номер великих літер менший, ніж у малих.\nconst letters7 = ['b', 'B', 'a', 'A', 'c', 'C'];\nconsole.log(letters7.toSorted()); // [\"A\", \"B\", \"C\", \"a\", \"b\", \"c\"]\n\n// ..................Свій порядок сортування чисел\n// Для зазначення свого порядку сортування методу toSorted(compareFunction) потрібно передати колбек-функцію з двома параметрами:\n// a — перший елемент для порівняння.\n// b — другий елемент для порівняння.\n// Це функція порівняння (compare function), порядок сортування залежить від її результату. Метод toSorted() буде викликати її для двох довільних елементів.\n// array.toSorted((a, b) => {\n//   // Callback function body\n// });\n\n// ............Сортування за зростанням\n// Якщо виклик compareFunction(a, b) повертає будь-яке негативне значення, тобто a менше b, сортування поставить a перед b.\nconst scores3 = [61, 19, 74, 35, 92, 56];\nconst ascendingScores = scores3.toSorted((a, b) => a - b);\nconsole.log(ascendingScores); // [19, 35, 56, 61, 74, 92]\n\n// ...........Сортування за спаданням\n// Якщо виклик compareFunction(a, b) повертає будь-яке позитивне значення, тобто b більше a, сортування поставить b перед a.\nconst scores4 = [61, 19, 74, 35, 92, 56];\nconst descendingScores = scores4.toSorted((a, b) => b - a);\nconsole.log(descendingScores); // [92, 74, 61, 56, 35, 19]\n\n// Якщо виклик compareFunction(a, b) поверне 0, сортування залишить a і b незмінними по відношенню один до одного, але відсортує їх по відношенню до всіх інших елементів.\n\n// Зверни увагу, що при сортуванні масиву чисел і передачі в метод toSorted() кКОЛБЕК-ФУНКЦІЇ, числа вже не будуть приводитися до рядків, тобто їх сортування\n// ex ascendingReleaseDates за зростанням, descendingReleaseDates за спаданням\nconst releaseDates = [2016, 1967, 2008, 1984, 1973, 2012, 1997];\n\nconst ascendingReleaseDates = releaseDates.toSorted((a, b) => a - b);\n\nconst descendingReleaseDates = releaseDates.toSorted((a, b) => b - a);\n\n//                                                              метод рядків localeCompare()\n//.............Свій порядок сортування рядків\n// Для сортування рядків в алфавітному порядку, за зростанням або спаданням, використовується метод рядків localeCompare().\n// firstString.localeCompare(secondString)\n// Він викликається на рядку, який потрібно порівняти (firstString) з тим, що був переданий йому як аргумент (secondString).\n'a'.localeCompare('b'); // -1\n'b'.localeCompare('a'); // 1\n'a'.localeCompare('a'); // 0\n'b'.localeCompare('b'); // 0\n\n// - Повертає негативне значення, якщо firstString повинен бути перед secondString\n// - Повертає позитивне значення, якщо firstString повинен бути після secondString\n// - Якщо рядки однакові, повертається нуль і їх послідовність по відношенню один до одного не змінюється\n\n// Метод localeCompare() зручно використовувати для сортування рядків, оскільки метод toSorted() очікує такі самі значення від колбек-функції.\n\nconst students7 = ['Jacob', 'Artemis', 'Solomon', 'Adrian', 'Kai', 'Ganymede'];\n\nconst inAlphabetOrder = students7.toSorted((a, b) => a.localeCompare(b));\nconsole.log(inAlphabetOrder); // [ \"Adrian\", \"Artemis\", \"Ganymede\", \"Jacob\", \"Kai\", \"Solomon\" ]\n\nconst inReversedOrder = students7.toSorted((a, b) => b.localeCompare(a));\nconsole.log(inReversedOrder); // [ \"Solomon\", \"Kai\", \"Jacob\", \"Ganymede\", \"Artemis\", \"Adrian\" ]\n\n// ex сортування в алфавітному порядку та зворотньому\nconst authors99 = [\n  'Tanith Lee',\n  'Bernard Cornwell',\n  'Robert Sheckley',\n  'Fyodor Dostoevsky',\n  'Howard Lovecraft',\n];\n\nconst authorsInAlphabetOrder = authors99.toSorted((a, b) => a.localeCompare(b));\n\nconst authorsInReversedOrder = authors99.toSorted((a, b) => b.localeCompare(a));\nconsole.log(authorsInAlphabetOrder, authorsInReversedOrder);\n\n// ..........................................................Сортування об'єктів\n// Під час роботи з масивом об'єктів сортування виконується за числовим або рядковим значенням певної властивості.\n// ex відсортувати масив об'єктів за трьома різними сценаріями: 1)за зростанням кількості балів 2)за спаданням кількості балів 3)за ім'ям студента в алфавітному порядку\nconst students709 = [\n  { name: 'Mango', score: 83, courses: ['mathematics', 'physics'] },\n  { name: 'Poly', score: 59, courses: ['science', 'mathematics'] },\n  { name: 'Ajax', score: 37, courses: ['physics', 'biology'] },\n  { name: 'Kiwi', score: 94, courses: ['literature', 'science'] },\n];\n\nconst inAscendingScoreOrder = students709.toSorted(\n  (firstStudent, secondStudent) => firstStudent.score - secondStudent.score\n);\n\nconst inDescendingScoreOrder = students709.toSorted(\n  (firstStudent, secondStudent) => secondStudent.score - firstStudent.score\n);\n\nconst inAlphabeticalOrder = students709.toSorted(\n  (firstStudent, secondStudent) =>\n    firstStudent.name.localeCompare(secondStudent.name)\n);\n\n// ex сортуєм за алфавіт порядком авторів потім у зворотньому порядкуЖ та рейтинг книг за зростанням(a-b) потім за спаданням (b-a)\nconst sortedByAuthorName = books3333.toSorted((a, b) =>\n  a.author.localeCompare(b.author)\n);\nconst sortedByReversedAuthorName = books3333.toSorted((a, b) =>\n  b.author.localeCompare(a.author)\n);\nconst sortedByAscendingRating = books3333.toSorted(\n  (a, b) => a.rating - b.rating\n);\nconst sortedByDescentingRating = books3333.toSorted(\n  (a, b) => b.rating - a.rating\n);\nconsole.log(\n  sortedByAuthorName,\n  sortedByReversedAuthorName,\n  sortedByAscendingRating,\n  sortedByDescentingRating\n);\n\n// ............................................................Ланцюжки методів\n// Позбутися  «мертвих» (проміжних) змінних можна за допомогою групування викликів методів у ланцюжки. Кожний наступний метод буде виконуватися на основі результату роботи попереднього.\n\nconst names = students709\n  .toSorted((a, b) => a.score - b.score)\n  .map(student => student.name);\n\nconsole.log(names); // [\"Ajax\", \"Poly\", \"Mango\", \"Kiwi\"]\n// 1)На масиві викликаємо метод toSorted()\n// 2)До результату роботи методу toSorted() застосовуємо метод map()\n// 3)Змінній names присвоюється результат роботи методу map() - oтримаємо масив унікальних відвідуваних предметів, відсортований за алфавітом.\nconst uniqueSortedCourses = students709\n  .flatMap(student => student.courses)\n  .filter((course, index, array) => array.indexOf(course) === index)\n  .toSorted((a, b) => a.localeCompare(b));\n\nconsole.log(uniqueSortedCourses); // [\"biology\", \"science\", \"literature\", \"mathematics\", \"physics\"]\n// 1)На вихідному масиві викликаємо flatMap() і робимо розгладжений масив усіх курсів\n// 2)До результату методу flatMap() застосовуємо метод filter() для фільтрації унікальних елементів\n// 3)На результаті методу filter() викликаємо toSorted()\n// 4)Змінній uniqueSortedCourses присвоюється результат роботи методу toSorted()\n\n// ex  змінній names вийшов масив імен авторів в алфавітному порядку, рейтинг книг яких більший за значення змінної MIN_BOOK_RATING. Використовуй ланцюжок методів.\nconst MIN_BOOK_RATING = 8;\n\nconst namesAuthor = books3333\n  .filter(book => book.rating > MIN_BOOK_RATING)\n  .map(book => book.author)\n  .toSorted((a, b) => a.localeCompare(b));\n\nconsole.log(namesAuthor);\n\n//..........................................................PRACTICE\n// КОЛБЕК ФУНКЦІЯ\nfunction calc(a, b, callback) {\n  return callback + a ** b;\n}\nfunction math(x, y) {\n  return x ** y;\n}\n\nconsole.log(calc(3, 2, math(2, 3)));\n// callback створюємо зовні і потім під час виклику функції вищого порядку просто передаємо колбек функцію як аргумент\nfunction each(array, callback) {\n  const newArr = [];\n  for (const item of array) {\n    const res = callback(item);\n    newArr.push(res);\n  }\n  return newArr;\n}\nfunction easy(value) {\n  return value * 2;\n}\n\nconsole.log(each([1, 2, 3, 4], easy));\n//  передаємо колбек фунцію відразу як аргумент під час виклику функції вищого порядку\nfunction calc2(a, b, callback) {\n  const result = callback(a, b);\n  console.log(result);\n}\ncalc2(2, 3, function (x, y) {\n  return x ** y;\n});\n\n// оголошуємо колбек функцію за допомогою синтаксису стрілочної функції під час виклику функції вищого порядку (менше коду)\nconst example = (a, b, callback) => {\n  const result = callback(a, b);\n  console.log(result);\n\n  return result;\n};\nexample(2, 3, (x, y) => {\n  return x + y;\n});\n// те саме але стрілочна функція з неявним перетворенням (ще менше коду)\nexample(2, 34, (x, y) => x / y);\n\n// метод forEach(callback)\n// - поелементно перебирає вихідний масив\n// -нічого не повертає\n// - замінює класичний for, якщо не потрібно переривати цикл\n// - стрілочну ф-цію зручно передавати у forEach()\n\n// const arrey69 =[56, 34, 26, 49, 81, 93];\n// let multy = 1;\n// arrey69.forEach((element, index, array) => {\n//   console.log(element, index, array);\n//   multy *= element;\n//   console.log(multy);\n// });\n// коротший запис, можна опустити () якщо у нас один параметр (нам не потрібен індекс та посилання на масив) + опустили {} неявне повернення стрілочної ф-ції\nconst arrey69 = [56, 34, 26, 49, 81, 93];\nlet multy = 1;\narrey69.forEach(element => (multy *= element));\nconsole.log(multy);\n\n// рефакторинг (forEach + arrow function)\nconst items = ['Mango', 'Kiwi', 'Apple', 'Orange', 'Grape'];\n// function logItems(items) {\n//   console.log(items);\n//   for (let i=0; i<items.length; i++) {\n//     console.log(`${i+1} - ${items[i]}`);\n//   }\n// }\n// console.log(logItems(items));\nitems.forEach((element, index) => {\n  console.log(`${index + 1} - ${element}`);\n  return `${index + 1} - ${element}`;\n});\n// refactoring\n// function printContactsInfo({names, phones}) {\n//   const namesArr = names.split(\",\");\n//   const phonesArr = phones.split(\",\");\n//   for (let i=0; i<names.length; i++) {\n//     console.log(`${namesArr[i]} : ${phonesArr[i]}`);\n//   }\n//   return \"cycle for\";\n// }\n// printContactsInfo({\n//   names: \"Jacob,William,Mark\",\n//   phones: \"80956743333,80976743543,80509745558\"\n// });\n//\nconst printContactsInfo = ({ names, phones }) => {\n  const namesArr = names.split(',');\n  const phonesArr = phones.split(',');\n  namesArr.forEach((name, index) => {\n    console.log(`${name} : ${phonesArr[index]}`);\n  });\n};\nprintContactsInfo({\n  names: 'Jacob,William,Mark',\n  phones: '80956743333,80976743543,80509745558',\n});\n\n//\nconst calculateAvarege = (...args) => {\n  let total = 0;\n  args.forEach(item => (total += item));\n  return total / args.length;\n};\nconsole.log(calculateAvarege(23, 56, 41, 89));\n\n// ф-ція поверта масив моделей машин з об*єкту\nconst carsObj = [\n  {\n    model: 'INFINITI QX80',\n    year: 2025,\n    price: 0,\n    type: 'luxury SUV',\n    quantity: 0,\n  },\n  {\n    model: 'RANGE ROVER HSE',\n    year: 2024,\n    price: 7032687,\n    type: 'SUV',\n    quantity: 2,\n  },\n  {\n    model: 'Peugeot Landtrek',\n    year: 2024,\n    price: 1467300,\n    type: 'pickup truck',\n    quantity: 3,\n  },\n];\nconst getArreyOfCarsModel = obj => {\n  const arrModel = [];\n  obj.forEach(car => {\n    arrModel.push(car.model);\n  });\n  return arrModel;\n};\nconsole.log(getArreyOfCarsModel(carsObj));\n// на відміну від форич метод .map() повертає новий масив (довжина така ж як у визідного) тому щоб не створювати пустий масив доя форич можна відразу присвоїти змінній результат роботи метoду .map()\nconst getArreyOfCarsModelMap = obj => {\n  const result = obj.map(car => car.model);\n  return result;\n};\nconsole.log(getArreyOfCarsModelMap(carsObj));\n// ф-ція поверта новий масив об*єктів де прайс змінена на ціну зі знижкою\nconst makePriceWithDiscount = (arr, discount) => {\n  return arr.map(car => {\n    return {\n      // розгорнули в масив всі об*єкти машин\n      ...car,\n      // переприсвоїли нову ціну у кожному об*єкті машини\n      price: car.price * (1 - discount),\n    };\n  });\n};\nconsole.log(makePriceWithDiscount(carsObj, 0, 2));\n\n// збільшити к-ть годин графця за id\nconst playerIdToUpdate = 'player-3';\n\nconst plaers7 = [\n  { id: 'player-1', name: 'Poli', timePlayed: 230, online: true, grade: 3 },\n  { id: 'player-2', name: 'Kiwi', timePlayed: 30, online: true, grade: 1 },\n  { id: 'player-3', name: 'Banana', timePlayed: 170, online: false, grade: 2 },\n];\n\nconst updateTimePlayed = plaers7.map(player => {\n  if (player.id === playerIdToUpdate) {\n    return {\n      ...player,\n      timePlayed: player.timePlayed + 100,\n    };\n  }\n  return player;\n});\nconsole.log(updateTimePlayed);\n\n// МЕТОД .filter()\n// - поелементно перебирає оригінальний масив\n// - повертає новий масив (з елементами або порожній)\n// - додає в масив що повертається елементи які задовільняють умови колбек ф-ції:\n//           - якщо колбек повернув true ел додається в NEWмасив\n//            -                     false елемент НЕ додається в NEWмасив\nconst numbers41 = [21, 56, 89, 43];\nconst filtered = numbers41.filter((num, index) => {\n  if (Number.isFinite(num)) {\n    return true;\n  } else {\n    return false;\n  }\n});\nconsole.log(filtered);\n\n// Number.isFinite(num) -  функция определяет, является ли переданное значение конечным числом. Если необходимо, параметр сначала преобразуется в число.Если аргумент является NaN, положительной или отрицательной бесконечностью, метод вернёт false; иначе возвращается true.\n\n// EX\nconst findPrice = 0;\n// неявне повернення (implicit return)\nconst priceFiltered = (obj, x) => obj.filter(car => car.price === x);\nconsole.log(priceFiltered(carsObj, findPrice));\n\n// METHOD .find()\n// - поелементно перебирає оригінальний масив\n// - повертає першиЙ ЕЛЕМЕНТ що задовільняє умову або UNDEFINED  ЯКЩО НІЧОГО НЕ ЗАДОВІЛЬНЯЄ\nconst fined = numbers41.find(element => element > 15);\nconsole.log(fined);\n\n// METHOD .every()\n//  - поелементно перебирає вихідний масив\n// - поверта TRUE ЯКЩО ВСІ ЕЛЕМЕНТИ масиву задовільняють умову\n// EX\nconst isOnline = plaers7.every(player => player.online);\nconsole.log(isOnline);\n\n// METHOD .some()\n// - поелементно перебирає вихідний масив\n// - поверта TRUE ЯКЩО ХОЧАБ ОДИН ЕЛЕМЕНТ масиву задовільняє умову\nconst some = plaers7.some(player => player.online && player.grade === 3);\nconsole.log(some);\n\n// METHOD .reduce()\n// - поелементно перебирає вихідний масив\n// - значення що повертається залежить від розробника\n// - найчастіше викор щоб порах суму\n// повертає наступне значення акумулятора\n//                           акумулятор - місце збереження проміжного результату колбек ф-ції\n//                                          другий параметр (не обов*язковий)- початкове значення акумулятора, якщо його не передати то ним стане ПЕРШИЙ ел масиву\nconst total0 = numbers41.reduce((acc, el, indx, arr) => {\n  return acc + el;\n}, 0);\nconsole.log(total0);\n// те саме але поч знач акк = 1 і рез став на 1 більше\nconst total01 = numbers41.reduce((acc, el, indx, arr) => {\n  return acc + el;\n}, 1);\nconsole.log(total01);\n// те саме але поч знач акк = 2 і рез став на 2 більше\nconst total002 = numbers41.reduce((acc, el, indx, arr) => {\n  return acc + el;\n}, 2);\nconsole.log(total002);\n\n// рахуємо зп\nconst salary = {\n  mango: 100,\n  poly: 50,\n  ajax: 150,\n};\n//              створ масив із об*єкту     рах суму\nconst total = Object.values(salary).reduce((acc, num) => acc + num, 0);\nconsole.log(total);\n\n// рах заг к-ть год гравців , приклад де краще вказати початкове значення акк бо в против випадку значення акк візьметься з першого ел масиву - це об*єкт і вийде не сума а об*єкт+числа\nconst totalTimePlaed = plaers7.reduce((acc, el) => acc + el.timePlayed, 0);\nconsole.log(totalTimePlaed);\nconsole.log(plaers7);\n\n//\nconst cart35 = [\n  { label: 'banana', price: 100, quantity: 30 },\n  { label: 'pineapple', price: 200, quantity: 10 },\n  { label: 'dragon-fruit', price: 250, quantity: 5 },\n];\nconst getTotalOfCart = cart35.reduce((acc, el) => {\n  return acc + el.price * el.quantity;\n}, 0);\nconsole.log(getTotalOfCart);\n\n// METHOD .toSorted()\n//  - за замовчуванням сортує за зростанням\n//  - за замовч прирівнює елементи до рядка і сортує за табл Unicode\n","'use strict';\n//                                                        MODUL 4 - OBJECTS\n// У JavaScript є 8 основних типів даних.\n// Сім примітивних типів даних:\n// number для будь-яких чисел: цілих або з рухомою точкою. Цілі числа обмежені до ±(253-1).\n// bigint для цілих чисел довільної довжини.\n// string для рядків. Рядок може мати нуль або більше символів, немає окремого типу для одного символу.\n// boolean для true/false.\n// null для невідомих значень- автономний тип, який має єдине значення null.\n// undefined для не присвоєних значень - автономний тип, який має єдине значення undefined.\n// symbol для унікальних ідентифікаторів.\n\n// І один непримітивний тип даних:\n// object для складних структур даних.\n// На противагу цьому, об*єкти використовуються для зберігання ключів різних колекцій даних та складніших об*єктів.\n// Для оголошення об*єкта використовуються фігурні дужки {} — літерал об'єкта.\n// При створенні об'єкта до нього відразу можна додати властивості, але це не обов*язково. Кожна властивість обов*язково складається з пари ключ: значення.\n// Ключ також називають ім'ям властивості і це зазвичай рядок, якщо в імені більше 1 слова то його поміщають у лапки\"\".\n// Значенням властивості можуть бути будь-які типи: примітиви, масиви, об'єкти, булі, функції тощо.\n// Властивості між собою розділяються комою.\n// об*єкт apartment містить дані про квартиру і значення ключа owner - це об*єкт з ключами про інформацію власника\nconst apartment = {\n  'img Url': 'https://via.placeholder.com/640x480',\n  descr: 'Spacious apartment in the city center',\n  rating: 4,\n  price: 2153,\n  tags: ['premium', 'promoted', 'top'],\n  owner: {\n    name: 'Henry',\n    phone: '982-126-1588',\n    email: 'henry.carter@aptmail.com',\n  },\n};\n// Доступ до властивостей через крапку - використовується тоді, коли ми заздалегідь знаємо ім'я (ключ) властивості, до якої хочемо отримати доступ. СИНТАКСИС objectName.key.На місце звернення буде повернуте значення властивості з таким ключем.\nconst book = {\n  title: 'The Last Kingdom',\n  author: 'Bernard Cornwell',\n  genres: ['historical prose', 'adventure'],\n  isPublic: true,\n  rating: 8.38,\n};\n\nconst bookTitle = book.title;\nconsole.log(bookTitle); // \"The Last Kingdom\"\nconst bookGenres = book.genres;\nconsole.log(bookGenres); // [\"historical prose\", \"adventure\"]\nconst bookPrice = book.price;\nconsole.log(bookPrice); // undefined\n\n// Для доступу до вкладених властивостей\n// якщо вкладений об*єкт - використовується ланцюжок звернень «через крапку».Тобто «крапка» вказує наступну вкладеність.\nconst user = {\n  name: 'Jacques Gluke',\n  tag: 'jgluke',\n  location: {\n    country: 'Jamaica',\n    city: 'Ocho Rios',\n  },\n  hobbies: ['swimming', 'music', 'sci-fi'],\n};\n\nlet location22 = user.location;\nconsole.log(location22); // {country: \"Jamaica\", city: \"Ocho Rios\"}\n\nconst country = user.location.country;\nconsole.log(country); // \"Jamaica\"\n\n// Якщо значення властивості — це масив, то в нашому прикладі вище звернення до цього масиву буде: user.hobbies\nconst hobbies = user.hobbies;\nconsole.log(hobbies); // [\"swimming\", \"music\", \"sci-fi\"]\n// Отримати доступ до елементів масиву можна через квадратні дужки та індекс: user.hobbies[0];\nconst firstHobby = user.hobbies[0];\nconsole.log(firstHobby); // \"swimming\"\n// Можна використовувати властивості й методи масиву, наприклад отримати значення його довжини з властивості length: user.hobbies.length;\nconst numberOfHobbies = user.hobbies.length;\nconst lastHobies = user.hobbies[hobbies.length - 1];\nconsole.log(numberOfHobbies); // 3\n\nconst apartment2 = {\n  imgUrl: 'https://via.placeholder.com/640x480',\n  descr: 'Spacious apartment in the city center',\n  rating: 4,\n  price: 2153,\n  tags: ['premium', 'promoted', 'top'],\n  owner: {\n    name: 'Henry',\n    phone: '982-126-1588',\n    email: 'henry.carter@aptmail.com',\n  },\n};\n\nconst ownerName = apartment2.owner.name;\nconst ownerPhone = apartment2.owner.phone;\nconst ownerEmail = apartment2.owner.email;\nconst numberOfTags = apartment2.tags.length;\nconst firstTag = apartment2.tags[0];\n// const lastTag = apartment2.tags[tags.length - 1];\n\n//  Другий спосіб отримати доступ до властивості об'єкта через квадратні дужки — це синтаксис objectName[\"key\"]. ВІн використовується якщо назва ключа більша за 1 слово (\"назва ключа\"). Також такий спосіб спрацює з будь-яким ім*ям властивості:\nconst book3 = {\n  title: 'The Last Kingdom',\n  author: 'Bernard Cornwell',\n  genres: ['historical prose', 'adventure'],\n  isPublic: true,\n  rating: 8.38,\n};\n\nconsole.log(book3.title); // \"The Last Kingdom\"\nconsole.log(book3['title']); // \"The Last Kingdom\"\n\nconsole.log(book3.genres); // [\"historical prose\", \"adventure\"]\nconsole.log(book3['genres']); // [\"historical prose\", \"adventure\"]\n\nconst propKey = 'author';\nconsole.log(book3.propKey); // undefined\nconsole.log(book3[propKey]); // \"Bernard Cornwell\"\n// Після того як об'єкт створений, значення його властивостей можна змінити.Для цього необхідно звернутися до них за ключем, наприклад, «через крапку», і присвоїти нове значення.\nbook3.rating = 9;\nbook3.isPublic = false;\nbook3.genres.push('drama');\n// ex\nconst apartment3 = {\n  imgUrl: 'https://via.placeholder.com/640x480',\n  descr: 'Spacious apartment in the city center',\n  rating: 4,\n  tags: ['premium', 'promoted', 'top'],\n  owner: {\n    name: 'Henry',\n    phone: '982-126-1588',\n    email: 'henry.carter@aptmail.com',\n  },\n};\napartment3.price = 5000;\napartment3.rating = 4.7;\napartment3.owner.name = 'Henry Sibola';\napartment3.tags.push('trusted');\n// Додавання властивостей об*єкта нічим не відрізняється від зміни значення вже існуючої властивості. Якщо під час запису значення за ключем така властивість відсутня в об'єкті, вона буде створена.\n// якщо ви спробуєте додати властивості у ще не створеного об*єкта (властивості) то ви отримаєте помилку. Спочатку ініціалізуйте об*єкт-властивість як порожній об'єкт, а потім додавайте до нього властивості.\nbook3.pageCount = 836;\nbook3.originalLanguage = 'en';\nbook3.translations = ['ua', 'ru'];\n\nbook3.price = {};\nbook3.price = {\n  hardcover: 39,\n  softcover: 29,\n};\nconsole.log(book3.price);\n\n// Іноді під час створення об'єкта значення властивості необхідно взяти зі змінної або параметра функції з таким самим ім'ям, як і сама властивість.\n// Синтаксис коротких властивостей (shorthand properties) вирішує цю проблему, дозволяючи використовувати ім'я змінної як ім'я властивості, а її значення як значення властивості.\n// Тобто під час оголошення об'єкта достатньо вказати тільки ім'я властивості, а значення буде взято зі змінної з аналогічним ім'ям.\nconst name4 = 'Henry Sibola';\nconst age4 = 25;\n\nconst user4 = {\n  name4,\n  age4,\n};\nconsole.log(user4);\n\n// Обчислювальні властивості\n// Бувають ситуації, коли під час оголошення об'єкта необхідно додати властивість з ім'ям, яке ми заздалегідь не знаємо, тому що воно зберігається як значення змінної або як результат виконання функції.\n// Синтаксис обчислювальних властивостей (computed properties) допомагає уникнути зайвого коду і в деяких випадках спростити його. Значенням обчислювальної властивості може бути будь-який валідний вираз.\nconst propName = 'name';\nconst user5 = {\n  age: 25,\n  // ключ цієї властивості буде взято зі значення змінної propName\n  [propName]: 'Henry Sibola',\n};\nconsole.log(user5.name); // \"Henry Sibola\"\n\n//                                                      ПЕРЕБІР ОБ*ЄКТА\n//                                               - Цикл for...in\n// На відміну від масиву або рядка, об'єкт — це не ітерабельна сутність, тобто його не можна перебрати циклами for або for...of.\n// Для перебирання об'єктів використовується спеціальний цикл for...in, який перебирає ключі об'єкта object. ВІн має свої побічності - наприклад перебирає ключі прототипа через це додають перевірки.\nconst book5 = {\n  title: 'The Last Kingdom',\n  author: 'Bernard Cornwell',\n  genres: ['historical prose', 'adventure'],\n  rating: 8.38,\n};\n\nfor (const key in book5) {\n  console.log(key); // Ключ\n  console.log(book5[key]); // Значення властивості з таким ключем\n}\n// ex Перебери об'єкт apartment, використовуючи цикл for...in, і запиши в масив keys всі його ключі, а в масив values всі значення його властивостей.\nconst apartment4 = {\n  descr: 'Spacious apartment in the city center',\n  rating: 4,\n  price: 2153,\n};\n\nconst keys = [];\nconst values = [];\nfor (const key in apartment4) {\n  keys.push(key);\n  values.push(apartment[key]);\n}\n\nconsole.log(keys, values);\n//          - Метод Object.keys(object) приймає об'єкт і повертає масив ключів його властивостей. Якщо в об'єкті немає властивостей, метод поверне порожній масив.\n// Скомбінувавши результат Object.keys() і цикл for...of, можна зручно перебрати властивості об'єкта, не вдаючись до використання циклу for...in.\nconst book6 = {\n  author: 'Bernard Cornwell',\n  genres: ['historical prose', 'adventure'],\n  rating: 8.38,\n};\nconst keysArrayOfBook6 = Object.keys(book6);\n\nfor (const key of keysArrayOfBook6) {\n  console.log(key); // Ключ\n  console.log(book6[key]); // Значення властивості\n}\n// ex Перебери об'єкт apartment, використовуючи метод Object.keys() і цикл for...of. Запиши у змінну keys масив ключів властивостей об'єкта apartment, і додай в масив values всі значення його властивостей.\nconst apartment6 = {\n  descr: 'Spacious apartment in the city center',\n  rating: 4,\n  price: 2153,\n};\nconst apartmentArrayKeys = Object.keys(apartment6);\nconsole.log(apartmentArrayKeys);\n\nconst values2 = [];\nconst keys2 = [];\n\nfor (const key of apartmentArrayKeys) {\n  values2.push(apartment6[key]);\n  keys2.push(key);\n}\n\nconsole.log(values2, keys2);\n\n// Метод hasOwnProperty() возвращает логическое значение, указывающее, содержит ли объект указанное свойство.\n\n// ex РЕФАКТОРИНГ - використати метод Object.keys() і цикл for...of замість циклу for...in. Функція має повернути кількість властивостей в об'єкті object.\n// function countProps(object) {\n//   let propCount = 0;\n\n//   for (const key in object) {\n//     if (object.hasOwnProperty(key)) {\n//       propCount += 1;\n//     }\n//   }\n//   return propCount;\n// }\nfunction countProps(object) {\n  let propCount = 0;\n  const arraysKeysOfObject = Object.keys(object);\n\n  const keysObject = [];\n  const propertyObject = [];\n\n  for (const key of arraysKeysOfObject) {\n    keysObject.push(key);\n    propertyObject.push(object[key]);\n  }\n  propCount = propertyObject.length;\n  return propCount;\n}\nconst humanity = {\n  species: 'Homo sapiens',\n  height: {\n    male: 1.7,\n    female: 1.6,\n  },\n  'speed running': {\n    male: '13km/h',\n    female: '10km/h',\n  },\n};\nconsole.log(countProps(humanity));\n\n//  метод Object.values(object) повертає масив значень його властивостей. Якщо в об'єкті відсутні властивості, метод Object.values(object) поверне порожній масив. Масив значень властивостей також можна перебрати циклом for...of, наприклад для отримання загальної суми числових значень.\n// ex Функція countTotalSalary(salaries) приймає об'єкт зарплат (salaries) в якості параметра. Кожна властивість об'єкта salaries — це ключ, що містить ім'я співробітника, та значення - його відповідна зарплатня. function поверта загальну суму зарплат всіх співробітників.\nfunction countTotalSalary(salaries) {\n  let totalSalary = 0;\n  const arraySal = Object.values(salaries);\n  for (const sal of arraySal) {\n    totalSalary += Number.parseFloat(sal);\n  }\n  const arrayEmployee = Object.keys(salaries);\n  return `The total salaries ${totalSalary}$ for ${arrayEmployee.length} employees`;\n}\nconst salariesObject = {\n  Kate: '3200$',\n  Petya: '4500$',\n  Misha: '6700$',\n  Anna: '5900$',\n};\nconsole.log(countTotalSalary(salariesObject));\n\n//                                                          ARRAY OF OBJECTS\n// Для опису групи сутностей використовується масив об'єктів.\n// Mасив однотипних об'єктів - всі об'єкти в масиві гарантовано мають однаковий набір властивостей, але з різними значеннями.\n// Для перебору такого масиву використовується стандартний цикл for...of.\n\n// Значення властивостей кожного об'єкта можна отримати, використовуючи синтаксис «через крапку» (CONST VALUE = OBJECT.KEY), оскільки в кожному об'єкті набір властивостей та їх імена будуть однакові, відрізнятимуться тільки значення.\n// for (const book of books) {\n//   console.log(book); // Об'єкт книги\n//   console.log(book.title); // Назва\n//   console.log(book.author); // Автор\n//   console.log(book.rating); // Рейтинг\n// }\n// ex Масив colors містить колекцію кольорів (objects). Кожен колір представлений об'єктом і має властивості hex і rgb з відповідними для цього формату і кольору значеннями.Перебери масив об'єктів colors, використовуючи цикл for...of. Додай у масив hexColors значення властивостей hex, а в масив rgbColors - значення властивостей rgb з усіх об'єктів масиву colors.\nconst colors = [\n  { hex: '#f44336', rgb: '244,67,54' },\n  { hex: '#2196f3', rgb: '33,150,243' },\n  { hex: '#4caf50', rgb: '76,175,80' },\n  { hex: '#ffeb3b', rgb: '255,235,59' },\n];\nconst hexColors = [];\nconst rgbColors = [];\nfor (const color of colors) {\n  hexColors.push(color.hex);\n  rgbColors.push(color.rgb);\n}\nconsole.log(hexColors, rgbColors);\n\n// Пошук об'єкта за значенням властивості. Наприклад, потрібно знайти книгу за її автором. Для цього необхідно:\n// - перебрати масив у циклі;\n// - додати умову, виконання якої означатиме успішний результат пошуку.\nconst books6 = [\n  { title: 'The Last Kingdom', author: 'Bernard Cornwell' },\n  { title: 'Beside Still Waters', author: 'Robert Sheckley' },\n  { title: 'The Dream of a Ridiculous Man', author: 'Fyodor Dostoevsky' },\n];\nconst authorToSearchFor = 'Robert Sheckley';\nfor (const book of books6) {\n  if (book.author === authorToSearchFor) {\n    console.log(book);\n    console.log(book.title);\n  }\n}\n\n// ex Функція getProductPrice(productName) приймає один параметр productName - назва продукту. Функція містить масив об'єктів products з такими властивостями, як name — ім'я товару, price — ціна і quantity — кількість. Доповни код функції так, щоб вона шукала об'єкт продукту з певним ім'ям (властивість name) в масиві products і повертала його ціну (властивість price). Якщо продукт з такою назвою не знайдений, функція повинна повертати null.\nfunction getProductPrice(productName) {\n  const products = [\n    { name: 'Radar', price: 1300, quantity: 4 },\n    { name: 'Scanner', price: 2700, quantity: 3 },\n    { name: 'Droid', price: 400, quantity: 7 },\n    { name: 'Grip', price: 1200, quantity: 9 },\n  ];\n  let price;\n  for (const product of products) {\n    if (productName === product.name) {\n      price = product.price;\n    }\n  }\n  return price;\n}\nconsole.log(getProductPrice('Radar'));\n\n//РІЗНИЦЯ МІЖ FOR...IN TA FOR...OF\n// Новый синтаксис добавлен для перебора итерируемых коллекций. Можете написать свою коллекцию с реализацией итератора и использовать for..of для ее перебора.\nlet arr = [`a`, `b`, `c`, `d`, `e`];\n\nfor (const elem in arr) {\n  console.log(elem); // 0 1 2 3 4\n}\n\nfor (const elem of arr) {\n  console.log(elem); // a b c d e\n}\n\n// масив всіх значень певної властивості об'єктів. Наприклад, взяти з масиву об'єктів, які описують книги, усі назви або рейтинг.\n// Для цього необхідно:\n// Створити новий порожній масив для зберігання значень властивостей.\n// Перебрати масив об'єктів у циклі.\n// На кожній ітерації додати в новий масив значення необхідної властивості.\n\n// ex Напиши функцію getAllPropValues(propName), яка приймає один параметр propName - ім'я (ключ) властивості. Функція повинна повернути масив усіх значень властивості з таким ім'ям з кожного об'єкта в масиві products. Якщо в об'єктах відсутні властивості з таким ім'ям, функція повинна повернути порожній масив.\nfunction getAllPropValues(propName) {\n  const products = [\n    { nameE: 'Radar', price: 1300, quantity: 4 },\n    { nameE: 'Scanner', price: 2700, quantity: 3 },\n    { nameE: 'Droid', price: 400, quantity: 7 },\n    { nameE: 'Grip', price: 1200, quantity: 9 },\n  ];\n  let array = [];\n\n  for (const product of products) {\n    if ('nameE' === propName) {\n      array.push(product.nameE);\n    } else if ('price' === propName) {\n      array.push(product.price);\n    } else if ('quantity' === propName) {\n      array.push(product.quantity);\n    } else {\n      array = [];\n    }\n  }\n  return array;\n}\nconsole.log(getAllPropValues('quantity'));\n// ex Функція calculateTotalPrice(productName) приймає один параметр productName- назва товару. Функція містить масив об'єктів products з такими властивостями, як name — ім'я товару, price — ціна і quantity — кількість. Function поверта загальну вартість (ціна * кількість) товару з таким ім'ям з масиву products.Якщо продукту з такою назвою немає, то функція повинна повертати рядок \"Product <productName> not found!\" , де <productName> — це ім'я товару.\nfunction calculateTotalPrice4(productName) {\n  const products = [\n    { name: 'Radar', price: 1300, quantity: 4 },\n    { name: 'Scanner', price: 2700, quantity: 3 },\n    { name: 'Droid', price: 400, quantity: 7 },\n    { name: 'Grip', price: 1200, quantity: 9 },\n  ];\n  let totalPrice;\n  for (const product of products) {\n    if (productName === product.name) {\n      return (totalPrice = product.price * product.quantity);\n    }\n  }\n  return `Product ${productName} not found!`;\n}\nconsole.log(calculateTotalPrice4('Raar'));\n\n//                                                 METHODS OF OBJECTS\n// Об'єкти можуть зберігати не тільки дані, але й функції для роботи з цими даними.\n// Метод об*єкта - це звичайна функція, оголошена як властивість об'єкта, а не як окрема змінна. Для звернення до методу об'єкта використовується стандартний синтаксис із крапкою.\n// const obj = {\n// \tmethod(value) {\n// \t\tconsole.log(`I'm a method with ${value}!`);\n// \t}\n// };\n// obj.method(5); // \"I'm a method with 5!\"\n// obj.method(10); // \"I'm a method with 10!\"\n// Об'єкти, які пов'язують дані та методи для роботи з цими даними, можна назвати «моделями».\n// ex\nconst atTheOldToad = {\n  potions: [],\n  getPotions() {\n    return 'List of all available potions';\n  },\n  addPotion(potionName) {\n    return `Adding ${potionName}`;\n  },\n};\n// Виклик методу atTheOldToad.getPotions() повертає рядок \"List of all available potions\"\n// Виклик методу atTheOldToad.addPotion(\"Invisibility\") повертає рядок \"Adding Invisibility\"\n\n// Для доступу до об'єкта в методі використовується не ім'я змінної цього об*єкта, наприклад bookShelf, а ключове слово this. Ключове слово this в середині методу містить посилання на об'єкт, що його викликав.\n// Для доступу до властивостей об'єкта в методах звертаємось до нього через this і далі, стандартно, «через крапку» до властивостей.\n\n// ex Об'єкт atTheOldToad має наступні властивості: -potions — масив рядків, з назвами зілль; - getPotions() — метод, який повертає рядок \"List of all available potions\". Зміни код метода об'єкта getPotions() так, щоб він повертав значення властивості potions\nconst atTheOldToad2 = {\n  potions: ['Speed potion', 'Stone skin'],\n  getPotions() {\n    return this.potions;\n  },\n};\nconsole.log(atTheOldToad2.getPotions());\n\n//   ex\nconst atTheOldToad21 = {\n  potions: [\n    { name: 'Speed potion', price: 460 },\n    { name: 'Stone skin', price: 520 },\n  ],\n  getPotions() {\n    return this.potions;\n  },\n  addPotion(newPotion) {\n    return this.potions.push(newPotion);\n  },\n  getTotalPrice() {\n    let totalPrice = 0;\n    for (const potion of this.potions) {\n      totalPrice += potion.price;\n    }\n    return totalPrice;\n  },\n};\nconsole.log(atTheOldToad21.addPotion({ e: 'tt', u: 'yi' }));\nconsole.log(atTheOldToad21.potions);\n\n//                                            Масив об*єктів\nconst bookShelf = {\n  books: [\n    { title: 'The Last Kingdom', rating: 8 },\n    { title: 'The Mist', rating: 6 },\n  ],\n  getBooks() {\n    return this.books;\n  },\n  addBook(newBook) {\n    this.books.push(newBook);\n  },\n};\nbookShelf.addBook({ title: 'Dream Guardian', rating: 9 });\n// При переборі масиву у властивості books треба пам'ятати, що це масив об'єктів.\n\n// Наприклад, додамо метод getAverageRating(), який повертатиме середній рейтинг книг. Для цього:\n// - Оголосимо новий метод getAvarageRating в об'єкті.\n// -  Оголосимо змінну totalRating для зберігання загального рейтингу.\n// - Переберемо масив книг за посиланням this.books у циклі for...of.\n// - На кожній ітерації додамо до загального рейтингу - рейтинг книги.\n// - Після завершення циклу повернемо результат ділення загального рейтингу на кількість книг.\nconst bookShelf2 = {\n  books: [\n    { title: 'The Last Kingdom', rating: 8 },\n    { title: 'The Mist', rating: 6 },\n    { title: 'Dream Guardian', rating: 9 },\n  ],\n  getAvarageRating() {\n    let totalRating = 0;\n    for (const book of this.books) {\n      totalRating += book.rating;\n    }\n    return totalRating / this.books.length;\n  },\n};\n\nbookShelf2.getAvarageRating(); // 7\n//   ex додали метод що поверта суму із властивості ціни\nconst atTheOldToad23 = {\n  potions: [\n    { name: 'Speed potion', price: 460 },\n    { name: 'Stone skin', price: 520 },\n  ],\n  getPotions() {\n    return this.potions;\n  },\n  addPotion(newPotion) {\n    this.potions.push(newPotion);\n  },\n  getTotalPrice() {\n    let totalPrice = 0;\n    for (const potion of this.potions) {\n      totalPrice += potion.price;\n    }\n    return totalPrice;\n  },\n};\n\n//   Зміна об'єкта в масиві\n// Процес зміни властивостей об*єкта в масиві починається з таких кроків:\n// 1) Перебір масиву об'єктів у циклі, наприклад for...of.\n// 2) Додавання перевірки збігу значення властивості об'єкта на поточній ітерації і заданого значення.\n// 3) При виконанні if ми можемо бути впевнені, що на даній ітерації в змінній book знаходиться посилання на необхідний нам об'єкт, оскільки об'єкти передаються за посиланнями. Тепер достатньо звернутися до властивості цього об'єкта і прирівняти йому нове значення.\nconst bookShelf24 = {\n  books: [\n    { title: 'The Last Kingdom', rating: 8 },\n    { title: 'The Mist', rating: 6 },\n  ],\n  changeRating(bookName, newRating) {\n    for (const book of this.books) {\n      if (book.title === bookName) {\n        book.rating = newRating;\n      }\n    }\n  },\n};\n\nbookShelf24.changeRating('The Mist', 9);\nbookShelf24.changeRating('The Last Kingdom', 4);\n//   ex метод updatePotionName(oldName, newName) , щоб він оновлював назву зілля з oldName на newName в масиві зілля у властивості potions.\nconst atTheOldToad25 = {\n  potions: [\n    { name: 'Speed potion', price: 460 },\n    { name: 'Stone skin', price: 520 },\n  ],\n  getPotions() {\n    return this.potions;\n  },\n  updatePotionName(oldName, newName) {\n    for (const potion of this.potions) {\n      if (oldName === potion.name) {\n        potion.name = newName;\n      }\n    }\n    return newName;\n  },\n};\n\n//                                             Синтаксис spread і rest\n// Залишкові параметри\n// Ми вже знаємо, що викликати функцію можна з будь-якою кількістю аргументів незалежно від того, як її було визначено. Зайві аргументи не викличуть помилку.\nfunction multiply(a, b) {\n  console.log(a, b);\n}\nmultiply(1, 2); // 1 2\nmultiply(1, 2, 3); // 1 2\nmultiply(1, 2, 3, 4); // 1 2\n// У прикладі вище проблема в тому, що аргументів більше, ніж параметрів. І будуть використані лише перші два аргументи — за кількістю оголошених параметрів. Ми вже вміємо розв'язувати такі завдання, використовуючи псевдомасив ------ arguments, у який збираються всі передані аргументи.\nfunction multiply3() {\n  console.log(arguments);\n}\nmultiply3(1, 2); // псевдомасив [1, 2]\nmultiply3(1, 2, 3); // псевдомасив [1, 2, 3]\nmultiply3(1, 2, 3, 4); // псевдомасив [1, 2, 3, 4]\n\n// Починаючи зі стандарту ES6, з'явилася концепція залишкових параметрів (...rest). Cинтаксис (...rest). який дозволяє зібрати групу незалежних елементів у масив. Вільні параметри можуть бути позначені через три крапки .... Буквально це означає: \"збери параметри, що залишилися, і поклади їх у масив\". Ім'я параметра може бути довільним. Найчастіше його називають args або rest\nfunction multiply2(numb1, numb2, ...args) {\n  console.log(args);\n}\n\nmultiply2(1, 2, 3, 4, 5); //[3, 4, 5]\n\n//   ex Використовуючи синтаксис залишкових параметрів, доповни код функції add() так, щоб вона приймала будь-яку кількість аргументів у параметр args і повертала їхню суму.\nfunction add(...args) {\n  let totalRest = 0;\n  for (const item of args) {\n    totalRest += item;\n  }\n  return totalRest;\n}\n\nconsole.log(add(15, 27));\nconsole.log(add(1, 2, 3));\n\n//  Функція addOverNum() приймає довільну кількість аргументів чисел.Доповни код функції таким чином, щоб вона обчислювала суму тільки тих аргументів, які більші за задане число. Це число завжди буде передано першим аргументом.\nfunction addOverNum(first, ...args) {\n  let total = 0;\n  for (const item of args) {\n    if (item > first) total += item;\n  }\n  return total;\n}\n\n//  Входження параметрів\n// Інколи потрібно зробити протилежне — передати масив поелементно у функцію, яка викликається. Наприклад, є вбудована функція Math.max(), яка шукає та повертає найбільший з аргументів (чисел), тобто очікує не масив значень, а довільну кількість аргументів.\n// оператор розпилення ...spread - при використанні при виклику функції, він перетворює масив на список аргументів.\nconst temps = [14, -4, 25, 8, 11];\n\nconsole.log(...temps); // 14 -4 25 8 11  набір окремих чисел\n\n// ✅ Передамо колекцію елементів у якості окремих аргументів\nconsole.log(Math.max(...temps)); // 25\n\n// ex Функція getExtremeScores(scores) приймає масив оцінок (чисел) у параметрі scores; вона поверта об'єкт із двома властивостями:- best має містити найбільше число з масиву scores; - worst має містити найменше число з масиву scores Використовуй оператор (...spread) і методи Math.max() і Math.min().\nfunction getExtremeScores(scores) {\n  const best = Math.max(...scores);\n  const worst = Math.min(...scores);\n  const object = {\n    best,\n    worst,\n  };\n  return object;\n}\nconsole.log(getExtremeScores([89, 64, 42, 17, 93, 51, 26]));\n\n//                      Створення копії масиву\n// Операція ...spread дозволяє створити копію масиву або «склеїти» довільну кількість масивів в один новий. Досі для цього використовувалися методи slice() і concat(), але операція розпилення дозволяє зробити те саме в коротшій формі.\nconst arrayNumb = [14, -4, 25, 8, 11];\n// Це точна, але незалежна копія масиву temps\nconst copyOfarrayNumb = [...arrayNumb];\nconsole.log(copyOfarrayNumb); // [14, -4, 25, 8, 11]\n\n//                      Склеювання 2х і більше масивів в один\nconst array1 = [14, 25, 11];\nconst array2 = [23, 17, 18];\nconst commonArray = [...array1, ...array2];\nconsole.log(commonArray); // [14, 25, 11, 23, 17, 18]\n\n// ex\n// У змінній allScores зберігався масив всіх результатів від першої до третьої групи включно.\n// У змінній bestScore був найвищий загальний бал.\n// У змінній worstScore був найнижчий загальний бал.\nconst firstGroupScores = [64, 42, 93];\nconst secondGroupScores = [89, 14, 51, 26];\nconst thirdGroupScores = [29, 47, 18, 97, 81];\n\nconst allScores = [\n  ...firstGroupScores,\n  ...secondGroupScores,\n  ...thirdGroupScores,\n];\nconst bestScore = Math.max(...allScores);\nconst worstScore = Math.min(...allScores);\n//                                       Створення об'єкта\n// Операція spread дозволяє розпилити властивості довільної кількості об'єктів в один новий.\nlet object1 = { A: 5, B: 10 };\nlet object2 = { C: 15 };\nlet object3 = { ...object1, ...object2 };\nconsole.log(object3); // { A: 5, B: 10, C: 15 }\n// Порядок розподілу має значення. Імена властивостей об'єкта — унікальні, тому властивості об'єкта, що розпиляються, можуть перезаписати значення вже існуючої властивості, якщо їх імена збігаються.\nobject1 = { A: 5, B: 10, C: 50 };\nobject2 = { C: 15, D: 20 };\n\nobject3 = { ...object1, ...object2 };\nconsole.log(object3); // { A: 5, B: 10, C: 15, D: 20 }\n\nlet object4 = { ...object2, ...object1 };\nconsole.log(object4); // { A: 5, B: 10, C: 50, D: 20 }\n\n// Під час розпилення можна додавати властивості в довільне місце. Головне пам'ятати про унікальність імені властивості і про те, що її значення може бути перезаписане.\nconst first = { propA: 5, propB: 10, propC: 50 };\nconst second = { propC: 15 };\n\nconst third = { propB: 20, ...first, ...second };\nconsole.log(third); // { propA: 5, propB: 10, propC: 15 }\n\nconst fourth = { ...first, ...second, propB: 20 };\nconsole.log(fourth); // { propA: 5, propB: 20, propC: 15}\n\n// ex Виконано\n// В конструкторі можна створювати нові тести, для яких є налаштування за замовчуванням, які зберігаються у змінній defaultSettings. Під час створення тесту, усі або частину налаштувань можна перевизначити, користувацькі налаштування зберігаються у змінній overrideSettings.\n\n// Для того щоб отримати фінальні налаштування тесту, необхідно взяти налаштування за замовчуванням і поверх них застосувати перевизначені користувацькі налаштування. Доповни код таким чином, щоб у змінній finalSettings утворився об'єкт фінальних налаштувань тесту.\nconst defaultSettings = {\n  theme: 'light',\n  public: true,\n  withPassword: false,\n  minNumberOfQuestions: 10,\n  timePerQuestion: 60,\n};\nconst overrideSettings = {\n  public: false,\n  withPassword: true,\n  timePerQuestion: 30,\n};\n\nconst finalSettings = { ...defaultSettings, ...overrideSettings };\nconsole.log(finalSettings);\n\n// ex banking's APP - переписати таски ы виконати )\n// const trasactionType = {\n//     deposit: \"deposit\",\n//     withdraw: \"withdraw\",\n// };\n\n// const account = {\n// balance: 0,\n// transactions: [],\n// createTransaction(amount, type) {},\n// deposit (amount) {},\n// withdraw(amount) {},\n// getBalance() {},\n// getTransactionDetails(id) {},\n// getTransactionTypeTotal(type) {},\n\n// };\n\n//                                                       PRACTICE\n// EX 1 функція створює і повертає масив за вказаною довжиною і наповнює вказаним значенням\nfunction createArrey(length, value) {\n  const arrayJust = [];\n  for (let i = 0; i < length; i++) {\n    arrayJust.push(value);\n  }\n  return arrayJust;\n}\nconsole.log(createArrey(3, 'a'));\n\n// EX 2 функція що створ новий масив в якому не буде значень що приводяться до фалс\nfunction clearArray(...values) {\n  const clearArray = [];\n  for (const value of values) {\n    // замість if (Boolean(value) === !false)\n    if (value) {\n      clearArray.push(value);\n    }\n  }\n  return clearArray;\n}\nconsole.log(clearArray(null, 1, undefined, 0, false, 3));\n\n// EX3 скрипт порівнює два масива і виводить результат тру якщо всі елементи однакові і фалс в ін випадку\nfunction arrayComparison(arr1, arr2) {\n  let message;\n  for (let i = 0; i < arr1.length; i++) {\n    // якщо порядок не важливий\n    if (arr1.length === arr2.length && arr1.includes(arr2[i])) {\n      //      ((arr1.length === arr2.length) && (arr1[i] === arr2[i])) якби порядок був важливий\n      message = true;\n    } else {\n      message = false;\n    }\n  }\n  return message;\n}\nconst arr11 = [1, 3, 2, 4];\nconst arr21 = [1, 2, 3, 4];\nconsole.log(arrayComparison(arr11, arr21));\n// другий варіант щоб швидше працював 1 - порівнюєм довжини 2 - порівнюєм самі елементи\nfunction arrayComparison2(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (const item of arr1) {\n    if (!arr2.includes(item)) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\nconsole.log(arrayComparison2(arr11, arr21));\n// EX 4 функцыя приймаэ довыльну к-ть аргументыв ы повертаэ ъх середнэ значення до того ж перевыряэ щоб це були числа\nfunction calculateAvarage(...rest) {\n  let total = 0;\n  let numbers = 0;\n  for (const item of rest) {\n    if (typeof item === 'number') {\n      total += item;\n      numbers += 1;\n    }\n  }\n  const avarage = total / numbers;\n  return `The avarage of arguments is ${avarage}`;\n}\nconsole.log(calculateAvarage(1, 2, '8', 3, true, '', 4, 5, 6, 'what', 7));\n\n// EX 5\nconst book7 = {\n  title: 'To kill a Mockingbird',\n  author: 'Harper Lee',\n  genre: 'Southern gothic',\n  yearPublished: 1960,\n  isBestseller: true,\n};\nbook7.rating = 4.8;\nbook7.genre = 'Classic fiction';\nbook7.isBestseller = false;\n\nconst keysOfBook7 = Object.keys(book7);\nfor (const item of keysOfBook7) {\n  console.log(`${item} : ${book7[item]}`);\n}\n\n// EX 6 функція приймає 2 парам - об*єкт і ключ , перебирає об*єкт і якщо він містить цей ключ то повертає тру в іншому випадку - фолс\nfunction checkKeyInObject(obj, key2) {\n  for (const key1 in obj) {\n    if (key1 === key2) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\nconsole.log(checkKeyInObject(book7, 'Genre'));\n// EX 6 другий варіант\nfunction checkKeyInObject2(obj, key) {\n  const check = Object.keys(obj).includes(key);\n  return check;\n}\nconsole.log(checkKeyInObject2(book7, 'Genre'));\n\n// EX 7 add the method in the object\nconst user6 = {\n  name: 'Peter',\n  surname: 'Parker',\n  age: 27,\n  potions: 'spider-man',\n  getInfo() {\n    const arr = [];\n    for (const key in this) {\n      arr.push(`${key}:${this[key]}`);\n    }\n    return arr.join(',');\n  },\n};\nconsole.log(user6.getInfo());\n\n// EX 8\nconst calculator = {\n  read(a, b) {\n    return (this.a = a) && (this.b = b);\n  },\n  sum() {\n    let total = 0;\n    const arrayOfValue = Object.values(this);\n    for (const value of arrayOfValue) {\n      if (typeof value === 'number') {\n        total += value;\n      }\n    }\n    return total;\n  },\n  mult() {\n    let mult = 1;\n    const arrayOfValue = Object.values(this);\n    for (let i = 0; i < arrayOfValue.length; i++) {\n      if (typeof arrayOfValue[i] === 'number') {\n        mult *= arrayOfValue[i];\n      }\n    }\n    return mult;\n  },\n};\nconsole.log(calculator.read(9, 10));\nconsole.log(calculator.sum());\nconsole.log(calculator);\nconsole.log(calculator.mult());\n\n// EX 9 Визначити загальну суму замовлення у змінну . якщо об*єкт порожній результат буде 0\nconst cart = {\n  apple: 50,\n  banana: 38,\n  orange: 40,\n  total() {\n    let totalCost = 0;\n    for (const value in this) {\n      console.log(`${this[value]} - ${value}`);\n      if (typeof this[value] === 'number') {\n        totalCost += this[value];\n      }\n    }\n    return totalCost;\n  },\n  // total() {\n  //     let totalCost = 0;\n  //     const arr = Object.values(this);\n  //     console.log(arr);\n\n  //     for (const value of arr) {\n  //         if (typeof value === \"number\") {\n  //         totalCost += value;\n  //         }\n  //     }\n  //     return totalCost;\n  // },\n};\nconsole.log(cart.total());\n// EX 10 розраз заг суму всіх замовлень в масиві об*єктів та вивести її у шаблонний рядок\nconst orders = [\n  { id: 1, item: 'футболка', quantity: 2, price: 15 },\n  { id: 2, item: 'шорти', quantity: 3, price: 20 },\n  { id: 3, item: 'кросівки', quantity: 1, price: 50 },\n];\nfunction totalOrders() {}\nlet totalAmount = 0;\nfor (const order of orders) {\n  totalAmount += order.quantity * order.price;\n}\nconsole.log(`Загальна сума всіх замовлень: ${totalAmount}`);\n","'use strict';\n//                                             MODUL 3. ARRAY (МАСИВ)\n// Масив — це впорядкована структура даних, яка використовується для зберігання колекції елементів. Масиви можуть містити елементи різних типів даних, таких як числа, рядки, булеві значення тощо. Для створення масиву в JavaScript використовується літерал масиву: квадратні дужки [].\n// Щоб отримати доступ до значення елемента масиву, ми використовуємо синтаксис квадратних дужок:\n// arrayName[index]\nconst planetss = ['Earth', 'Mars', 'Venus'];\nconsole.log(planetss[0]); // 'Earth'\nconsole.log(planetss[1]); // 'Mars'\n// Результат звернення до елемента масиву можна зберегти у змінну і використовувати його надалі.\nconst planetsss = ['Earth', 'Mars', 'Venus'];\nconst firstElement = planetsss[0];\nconsole.log(firstElement); // 'Earth'\n\n// Перевизначення значення елемента - Елементи масиву можна змінювати, звернувшись до них за індексом і присвоївши нове значення.\nconst planets = ['Earth', 'Mars', 'Venus', 'Uranus'];\nplanets[0] = 'Jupiter';\nplanets[2] = 'Neptune';\nconsole.log(planets); // ['Jupiter', 'Mars', 'Neptune', 'Uranus']\n// Довжина масиву -  кількість його елементів, зберігається у властивості length. Це динамічна величина, яка автоматично змінюється під час додавання або видалення елементів.\nconst planets44 = ['Earth', 'Mars', 'Venus'];\nconsole.log(planets44.length); // 3\n\nconst yhuuu = ['a', 'b', 'c'];\n//                             [1] = \"b\"\nconsole.log(yhuuu[yhuuu.length - 2]);\n// ex Функція приймає  параметр array - масив довільних значень.  щоб вона повертала новий масив з двох елементів: - перший елемент - це індекс останнього елементу у масиві array; - другий елемент - це значення останнього елементу у масиві array\nfunction getLastElementMeta(array) {\n  const newArray = [array.length - 1, array[array.length - 1]];\n  return newArray;\n}\nconsole.log(getLastElementMeta(['a', 'b', 'c', 'd']));\n// ex щоб вона повертала масив з двох елементів - першого і останнього елементів параметра array.\nfunction getExtremeElements(array) {\n  const newArray = [array[1], array[array.length - 1]];\n  return newArray;\n}\nconsole.log(getExtremeElements(['strange', 'wild', 'wakcy', 'freak']));\n//                                      METHODS OF ARRAYS\n// join(delimiter) об'єднує елементи масиву в рядок\n// split(delimiter) - перетворити рядок на масив\n// slice(begin, end) повертає новий масив, що містить копію частини вихідного масиву/ не змінює вихідний масив\n// splice(індекс з якого почати, к-ть елементів які вирізати , елемент який хочемо додати) - вирізає і повертає елементи з масиву, ЗМІНЮЄ ВИХІДНИЙ МАСИВ,/ або просто додає елементи (2, 0, \"новий елемент/-и\")\n// concat(arr1, arr2, ..., arrN) - для об'єднання двох або більше масивів.\n// indexOf(elem) використовується для визначення індексу першого входження елемента elem у масиві\n// push()  для додавання одного або більше елементів у кінець масиву. ВІН ПОВЕРТАЄ ДОВЖИНУ нового масиву\n// .pop() вирізає останній елемент масиву і повертає його (присвоївши новій змінній )\n// shift() -- видаляє елемент із початку,\n// unshift() - додає елементи на початок.\n// splice(index, deleteIndex, ...arr) -- починаючи з індексу index, видаляє deleteIndex елементів і вставляє arr.\n// includes() використовується для перевірки наявності певного елемента в масиві.  повертає л true, або false.\n// Array.from(), який створить масив із псевдомасиву\n// toReversed() - повертає новий масив з елементами у зворотньому порядку.\n//  УНАРНИЙ ПЛЮС (поставити +перед зиінною) - можна замість методу Number() для перетворення рядка на число але краще Number.parseFloat(value)\n\n// Цикл for...of — це зручний спосіб перебору масиву. Тіло циклу буде виконуватися на кожному елементі масиву. Це гарна заміна циклу for, якщо не потрібен доступ до лічильника.Цикл for...of завжди перебирає масив від першого і до останнього елемента, задати умову припинення циклу не можна. Якщо необхідно закінчити виконання циклу передчасно, використовується оператор break.\n// Ітерація по масиву з використанням циклу for дозволяє перебрати елементи масиву і виконати певну дію для кожного елемента.\n//\n\n// METHOD масиву join(delimiter) об'єднує елементи масиву в рядок. У результуючому рядку елементи будуть розділені символом або групою символів, зазначених у delimiter.\nconst words2 = ['JavaScript', 'is', 'amazing'];\nconsole.log(words2.join('')); // 'JavaScriptisamazing'\nconsole.log(words2.join(' ')); // 'JavaScript is amazing'\nconsole.log(words2.join('-')); // 'JavaScript-is-amazing'\n\n// METHOD Метод рядків split(delimiter) - перетворити рядок на масив, розбивши його за вказаним роздільником delimiter. Якщо роздільник є порожнім рядком (рядком, у якому нема символів), то вийде масив окремих символів рядка.\nconst name = 'Mango';\nconst letters = name.split(''); // [\"M\", \"a\", \"n\", \"g\", \"o\"]\n\nconst message2 = 'JavaScript essentials';\nconst words = message2.split(' '); // [\"JavaScript\", \"essentials\"]\n\nconst slug = 'amazing*french*recipes';\nconst slugParts = slug.split('*'); // [\"amazing\", \"french\", \"recipes\"]\n\nconsole.log(letters, words, slugParts);\n\n// Метод масиву slice(begin, end) повертає новий масив, що містить копію частини вихідного масиву, не змінюючи його. Копія створюється від індексу begin до, але не включаючи індекс end.\nconst planets54 = ['Earth', 'Mars', 'Venus', 'Jupiter', 'Saturn'];\nplanets54.slice(0, 2); // ['Earth', 'Mars']\nplanets54.slice(0, 4); // ['Earth', 'Mars', 'Venus', 'Jupiter']\nplanets54.slice(1, 3); // ['Mars', 'Venus']\n// Якщо не вказати параметри begin і end, буде створено повну копію вихідного масиву:\nconst planets2 = ['Earth', 'Mars', 'Venus', 'Jupiter', 'Saturn'];\nplanets2.slice(); // [\"Earth\", \"Mars\", \"Venus\", \"Jupiter\", \"Saturn\"]\n// Якщо не вказати end, копіювання відбуватиметься від begin до кінця масиву:\nconst planets3 = ['Earth', 'Mars', 'Venus', 'Jupiter', 'Saturn'];\nplanets3.slice(1); // [\"Mars\", \"Venus\", \"Jupiter\", \"Saturn\"]\nplanets3.slice(2); // [\"Venus\", \"Jupiter\", \"Saturn\"]\n// Якщо значення begin негативне, а end не вказано, будуть скопійовані останні begin елементів (тобто стільки елементів з кінця, скільки вказано в параметрі begin):\nconst planets4 = ['Earth', 'Mars', 'Venus', 'Jupiter', 'Saturn'];\nplanets4.slice(-2); // [\"Jupiter\", \"Saturn\"]\n\nconst fruits = ['apple', 'plum', 'pear', 'orange', 'banana'];\n// ex1 firstTwoEls - масив із перших двох елементів, nonExtremeEls - масив з усіх елементів, крім першого та останнього, lastThreeEls - масив із трьох останніх елементів:\nconst firstTwoEls = fruits.slice(0, 2);\nconst nonExtremeEls = fruits.slice(1, fruits.length - 1);\nconst lastThreeEls = fruits.slice(-3);\n\n// Метод concat(arr1, arr2, ..., arrN) - для об'єднання двох або більше масивів.\n\nlet firstArray = ['Mercury', 'Venus'];\nlet secondArray = ['Mars', 'Jupiter'];\nlet result2 = firstArray.concat(secondArray); // [\"Mercury\", \"Venus\", \"Mars\", \"Jupiter\"];\n// Зверни увагу, що вихідні масиви firstArray і secondArray залишаються незмінними після виклику concat(). Метод concat() створює і повертає новий масив, що містить усі елементи об'єднаних масивів.\n// Порядок аргументів методу визначає порядок розташування елементів у новому масиві.\nfirstArray = ['Mercury', 'Venus'];\nsecondArray = ['Mars', 'Jupiter'];\nlet thirdArray = ['Saturn', 'Neptune'];\n\nconsole.log(firstArray.concat(secondArray, thirdArray));\n// ['Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Neptune'];\n\nconsole.log(firstArray.concat(thirdArray, secondArray));\n// ['Mercury', 'Venus', 'Saturn', 'Neptune', 'Mars', 'Jupiter', ];\n\n// Метод масиву indexOf(elem) використовується для визначення індексу першого входження елемента elem у масиві. Він повертає індекс елемента, якщо він знайдений, або -1, якщо елемент не знайдений. Метод indexOf() виконує сувору рівність (===) при порівнянні елементів.\nconst clients = ['Mango', 'Ajax', 'Poly', 'Kiwi', 'Poly'];\nconsole.log(clients.indexOf('Poly')); // 2\nconsole.log(clients.indexOf('Monkong')); // -1\n// ex Доповни код функції getSlice(array, value) так, щоб вона виконувала пошук значення value у масиві array і повертала: - порожній масив, якщо в array немає елемента зі значенням value; - підмасив, що починається з початку array і до елемента зі значенням value включно, якщо такий елемент є в array\nfunction getSlice(array, value) {\n  if (array.indexOf(value) === -1) {\n    const newArray = [];\n    return newArray;\n  } else {\n    const indexValue = array.indexOf(value) + 1;\n    const newArray = array.slice(0, indexValue);\n    return newArray;\n  }\n}\nconsole.log(\n  getSlice(['You', 'are', 'a', 'freak', 'like', 'everyone', 'else'], 'freak')\n);\nconsole.log(\n  getSlice(['You', 'are', 'a', 'freak', 'like', 'everyone', 'else'], 'uhh')\n);\nconsole.log(getSlice(['Mango', 'Poly', 'Ajax'], 'Ajax'));\n\n// Метод масиву push() використовується для додавання одного або більше елементів у кінець масиву.\nlet planetsS = ['Earth', 'Mars', 'Venus'];\nplanetsS.push('Jupiter');\nconsole.log(planetsS); // ['Earth', 'Mars', 'Venus', 'Jupiter']\n\nplanetsS.push('Saturn', 'Neptune');\nconsole.log(planetsS); // ['Earth', 'Mars', 'Venus', 'Jupiter', \"Saturn\", \"Neptune\"]\n// За допомогою циклу ми можемо виконувати повторювані операції і використовувати метод push для додавання нових елементів у масив на кожній ітерації. Це дуже корисно, коли нам потрібно створити масив з елементами, які можна динамічно додавати.\nconst tags = [];\nfor (let i = 0; i < 3; i += 1) {\n  tags.push(`tag-${i}`);\n}\nconsole.log(tags); // [\"tag-0\", \"tag-1\", \"tag-2\"]\n\nconst friends = ['Rachel', 'Monika', 'Phoebe', 'Joey', 'Chandler', 'Ross'];\nfor (let i = 0; i < friends.length; i++) {\n  friends[i] += '!';\n}\nconsole.log(friends); // [\"Rachel!\", \"Monika!\", \"Phoebe!\", \"Joey!\", \"Chandler!\",\"Ross!\"]\n\n// ex щоб вона повертала масив усіх цілих чисел від значення min до max включно.\nfunction createArrayOfNumbers(min, max) {\n  let numbers = [];\n  for (let i = min; i <= max; i += 1) {\n    numbers.push(i);\n  }\n  return numbers;\n}\nconsole.log(createArrayOfNumbers(1, 3));\n\n//  Ітерація по масиву з використанням циклу for дозволяє перебрати елементи масиву і виконати певну дію для кожного елемента.\nconst planets7 = ['Earth', 'Mars', 'Venus'];\nfor (let i = 0; i < planets7.length; i += 1) {\n  console.log(planets7[i]);\n}\n// ex параметр order - масив чисел. Функція, щоб  поверта загальну суму елементів з масиву order.\nfunction calculateTotalPrice(order) {\n  let sum = 0;\n  for (let i = 0; i < order.length; i += 1) {\n    console.log(order[i]);\n    sum += order[i];\n  }\n  return sum;\n}\nconsole.log(calculateTotalPrice([15, 20, 15]));\n// ex Функція getEvenNumbers(start, end) має два параметри start та end, які є цілими числами. Доповни код функції так, щоб вона повертала масив усіх парних чисел від start до end. Якщо жодного парного числа немає, то масив має бути пустим. Парним вважається число, яке ділиться на 2 без остачі (10 % 2 === 0). Використовуй цикл for.\n// function getEvenNumbers2(start, end) {\n//   let arry = [];\n//   for (let i = start; i <= end; i += 1) {\n//     if (i % 2 === 0) {\n//       arry.push(i);\n//       console.log(arry);\n//     } else {\n//       arry = [];\n//     }\n//   return arry;\n// }\n// }\n// console.log(getEvenNumbers2(2, 10));\n\n// Метод масиву includes() використовується для перевірки наявності певного елемента в масиві. Він повертає логічне значення true, якщо елемент знайдено в масиві, і false, якщо елемент відсутній.\nconst planetas = ['Earth', 'Mars', 'Venus'];\n\nconsole.log(planetas.includes('Earth')); // true\nconsole.log(planetas.includes('Mars')); // true\nconsole.log(planetas.includes('Venus')); // true\nconsole.log(planetas.includes('Jupiter')); // false\n// ex Функція checkStorage(storage, item) приймає два параметри: - storage - масив рядків, що описує доступні товари на складі; - item - рядок з назвою товара, наявність якого потрібно перевірити. Доповни код функції таким чином, щоб вона перевіряла, чи присутній такий товар в масиві storage і повертала: - рядок \"<item> is available to order!\", де item - це назва товара, якщо товар було знайдено; - рядок \"Sorry! We are out of stock!\", якщо такого товара немає в масиві/    Зроби так, щоб пошук за ім'ям товару був незалежний від регістру, тобто наприклад \"plum\" і \"pLuM\" мають бути знайдені у масиві [\"apple\", \"plum\", \"pear\"].\n// function checkStorage(storage, item) {\n//   const storageNorm = storage.toLowerCase;\n//   const itemNorm = item.toLowerCase;\n//   const message = storageNorm.includes(itemNorm) ? `${item} is available to order!` : 'Sorry! We are out of stock!';\n//   return message;\n// }\n\n// function checkStorage2(storage2List, itemm) {\n//   let storage2ListNorm = storage2List.toLowerCase;\n//   let itemmNorm = itemm.toLowerCase;\n//   const message = storage2ListNorm.includes(itemmNorm) ? `${itemmNorm} is available to order!` : 'Sorry! We are out of stock!';\n// return message;\n// }\n\n// function checkStorage2(storage2List, itemm) {\n//   let storage2ListNorm = storage2List.toLowerCase;\n//   console.log(storage2ListNorm);\n\n//   let itemmNorm = itemm.toLowerCase;\n//   if (storage2ListNorm.includes(itemmNorm)) {\n//     return `${itemmNorm} is available to order!`;\n//   }  else {\n//   return 'Sorry! We are out of stock!';\n//   }\n// }\n// console.log(checkStorage2([\"a\", \"b\", \"c\"], \"C\"));\n//   console.log(checkStorage2([\"a\", \"b\", \"c\"], \"t\"));\n\n// Цикл for...of — це зручний спосіб перебору масиву. Тіло циклу буде виконуватися на кожному елементі масиву. Це гарна заміна циклу for, якщо не потрібен доступ до лічильника.Цикл for...of завжди перебирає масив від першого і до останнього елемента, задати умову припинення циклу не можна. Якщо необхідно закінчити виконання циклу передчасно, використовується оператор break.\nconst planetsSS = ['Earth', 'Mars', 'Venus'];\nfor (const planet of planetsSS) {\n  console.log(planet);\n}\n// ex функція, що поверта загальну суму чисел в масиві order. Використай цикл for...of для перебору масиву.\nfunction calculateTotalPrice21(order) {\n  let total = 0;\n  for (const item of order) {\n    total += item;\n  }\n  return total;\n}\nconsole.log(calculateTotalPrice21([21, 44, 6, 78, 53]));\n\n// Псевдомасив arguments - Доступ до списку всіх аргументів можна отримати за допомогою спеціальної змінної arguments.  Змінна arguments автоматично створюється всередині функції під час виклику функції з аргументами і заповнюється переданими значеннями аргументів..\n// Ця колекція схожа на масив, але насправді є псевдомасивом, тобто: - у неї є деякі властивості масивів, наприклад length; - у неї є можливість звернутися до елемента за індексом; - у неї немає методів для роботи з масивом; - її можна перебирати за допомогою циклів.\n// arguments потрібен нам коли в аргументах під час виклику функції довільна їх кількість тоді через arguments ми можемо створити їх псевдомасив потім через Array.from() перетворити псевдомасив на масив і працювати вже з ним\nfunction multiply() {\n  let total = 1;\n  for (const arg of arguments) {\n    total *= arg;\n  }\n  return total;\n}\nconsole.log(multiply(1, 2, 3)); //  6\nconsole.log(multiply(1, 2, 3, 4)); //  24\nconsole.log(multiply(1, 2, 3, 4, 5)); //  120\n\n// метод Array.from(), який створить масив із псевдомасиву, якщо під час роботи з arguments потрібно використовувати методи масиву.\n// метод Array.isArray(те що перевірятиметься ) - використовують щоб перевірити що це масив, він поверне тру якщо це масив і фолс якщо ні\nfunction makeArrayofArguments() {\n  // У змінній args буде повноцінний масив з усіх аргументів\n  const args = Array.from(arguments);\n  return args.join('-');\n}\nconsole.log(makeArrayofArguments(1, 2, 3)); // Поверне \"1-2-3\"\n\n//  метод масиву toReversed() - повертає новий масив з елементами у зворотньому порядку.\n// ex функція приймає довільну кількість аргументів і повертає масив усіх аргументів, які ідуть у зворотному порядку.\nfunction createReversedArray() {\n  const ars = Array.from(arguments);\n  return ars.toReversed();\n}\nconsole.log(createReversedArray('битися', 'не можна', ',', 'відступити'));\n\n//                                             FUNCTION'S PROPERTIES\n// Параметри за замовчуванням - необов'язкові параметри. Ці значення використовуються в тому випадку, якщо функція викликається без передавання відповідного аргументу для цього параметра. Значенням за замовчуванням може бути будь-який тип даних.\nfunction greet(username = 'Guest') {\n  console.log(`Hello, ${username}!`);\n}\ngreet('Jacob'); // \"Hello, Jacob!\"\ngreet(); // \"Hello, Guest!\"\n// ex amount - число, сума від якої потрібно обчислити податок (oбов'язковий параметр).taxRate - число, податкова ставка(nеобов'язковий параметр). За замовчуванням його значення має бути 0.2.функція повертає суму податку\nfunction calculateTax(amount, taxRate = 0.2) {\n  return amount * taxRate;\n}\n\n// Функціональний вираз (function expression) — звичайне оголошення змінної, значенням якої буде функція. Це альтернативний спосіб оголошення функції.\n// const multiply = function (x, y, z) {\n//   console.log(x * y * z);\n// };\n// Синтаксис оголошення функції, який ти вже знаєш (function declaration):\nfunction multiplyY(x, y, z) {\n  console.log(x * y * z);\n}\n// Різниця в тому, що function expression не можна викликати до місця його створення, тільки після, тому що це буквально оголошення const змінної. A оголошення функції (function declaration) можна викликати до місця її створення в коді.\n// Не важливо, який синтаксис використовувати, головне, щоб код у проєкті був однорідним. Тобто необхідно намагатися не змішувати оголошення функції (function declaration) з функціональними виразами (function expression), щоб писати більш стандартизований зрозумілий код.\n\n//                                        SCOPE (Область видимості)\n// Область видимості (scope) — механізм, який визначає доступність змінних у коді, що виконується.\n// Ланцюжок областей видимості (scope chain) — області видимості утворюють ієрархію, так що дочірні області мають доступ до змінних із батьківських областей, але не навпаки.\n// Інтерпретатор намагається спочатку знайти змінну в тій області видимості, в якій до неї звернулися. Якщо такої змінної в локальній області видимості немає, то він виходить назовні, на один рівень за спробу, доки не знайде значення або не дійде до самої верхньої області видимості (глобальної) і зрозуміє, що змінну з таким ідентифікатором неможливо знайти, тому що її просто немає, тоді буде помилка про те, що змінна не оголошена.\n\n//                                              Стек викликів\n\n// JavaScript — однопотокова мова, тобто в одну одиницю часу може виконуватися тільки одна інструкція. Це означає, що вже викликані функції, які не закінчили своє виконання, повинні чекати виконання функцій, викликаних усередині себе, для того щоб продовжити свою роботу.\n// Стек викликів(call stack) -  механізм зберігання списку функцій, які були викликані, але ще не закінчили своє виконання, і механізм управління послідовністю виконання цих функцій, щоб код працював контрольовано й очікувано.\n// Стек — структура даних, яка працює за принципом LIFO (Last-In-First-Out), тобто останнім прийшов — першим вийшов. Останнє, що додається на стек, буде видалено з нього першим, значить, можна додати або видалити елементи тільки з верхівки стека.\n// Стек викликів (call stack) — це структура даних, яка допомагає інтерпретатору відстежувати послідовність і стан викликів функцій у програмі. Він показує, яка функція зараз виконується і яка буде викликана наступною.\n// 1) в коді викликається функція, інтерпретатор додає її в стек викликів і починає виконання. 2)Будь-які функції, викликані виконуваною функцією, додаються до стеку викликів і виконуються, щойно відбувається їхній виклик. 3)Коли виконання функції завершено, інтерпретатор знімає її зі стеку викликів і відновлює виконання коду з тієї точки, де зупинився до цього. 4)Далі починає виконуватися функція, запис якої лежить наступною на стеку.\n// Stack frame (кадр стека, запис стека) — структура, яка додається на стек при виклику функції, вона зберігає службову інформацію (ім'я функції та номер рядка, у якому стався виклик).\n// Переповнення стека (stack overflow) - помилка в консолі \"Uncaught RangeError: Maximum call stack size exceeded\", стек викликів не безмежний, йому відводиться кінцевий обсяг пам'яті.\n// Рекурсія - функція викликає сама себе, якщо йдуть нескінченні виклики функцій і результат не повертається, то стек збільшується. По досягненню межі кількості записів стека і виникне  помилка переповнення стека, і скрипт \"падає\".\n\n// Шпаргалка з оголошення функцій у JS:\n// Функціональний вираз (function expression)\n// const greet = function (name) {\n//  return `Hello, ${name}`;\n// };\n// Оголошення функції (function declaration)\n// function greet(name) {\n//  return `Hello, ${name}!`;\n// }\n// Для того, щоб щось повернути з функції/методу або умови, можна використовувати оператор return. Також з функції можна повертати відразу будь-який тип даних, наприклад return 'hello' // (повернемо рядок) чи return true // (повернемо буль) чи return [1, 2] // (повернемо масив)\n// Паттерн раннє повернення, говорить про те, що якщо умова всередині нашего if повертає true, то нам одразу же треба щось повернути із тіла цієї умови, з допомогою return.\n// Не забувайте, що оператор = це оператор присвоєння, а не порівняння.\n// Декілька лайфхаків при роботі з масивами.\n// Як швидко очистити масив\n// const fruits = ['banana', 'apple', 'orange', 'watermelon', 'apple', 'orange', 'grape', 'apple'];\n// fruits.length = 0;\n// console.log(fruits); // поверне []\n// Як об'єднати більше двох масивів\n// const fruits = ['apple', 'banana', 'orange'];\n// const meat = ['poultry', 'beef', 'fish'];\n// const vegetables = ['potato', 'tomato', 'cucumber'];\n// const food = [...fruits, ...meat, ...vegetables];\n// console.log(food); // поверне [\"apple\", \"banana\", \"orange\", \"poultry\", \"beef\", \"fish\", \"potato\", \"tomato\", \"cucumber\"]\n// Як отримати рандомне значення масиву\n// const fruits = [ 'banana', 'apple', 'orange', 'watermelon', 'apple', 'orange', 'grape', 'apple', ];\n// const randomFruit = fruits[Math.floor(Math.random() * fruits.length)];\n// console.log(randomFruit); // поверне рандомний фрукт із масиву\n\n//                                                   Lections modul #3\n// ex напиши скрипт для обчислення площі прямокутника сторони якого подаються у типі рядка , цифри розділені пробілом.\nfunction squareOfRectangle(valueLengthOfFigure) {\n  const arrayValue = valueLengthOfFigure.split(' ');\n  let square = 0;\n  for (let i = 0; i < arrayValue.length; i += 1) {\n    square =\n      Number.parseFloat(arrayValue[0]) * Number.parseFloat(arrayValue[1]);\n  }\n  return `The square of rectangle is ${square}`;\n}\nconsole.log(squareOfRectangle('5см 7.2см'));\n\n// скрипт пыдраховуэ суму всых парних елементів у масиві\nfunction totalOfElementss(array) {\n  let total = 0;\n  for (const element of array) {\n    // або !(element % 2)\n    if (element % 2 === 0) {\n      total += element;\n    }\n  }\n  return total;\n}\nconsole.log(totalOfElementss([2, 3, 4, 5]));\n// варіант 2 - якщо непарне число то воно потрапляє в дужки иф де оператор континью тобто переходимо до наступного елемента, якщо він парний то в тіло іф не потрапляє а потрапляє в тіло фор і додається в суму парних чисел\nfunction totalOfElementssі(array) {\n  let total = 0;\n  for (const element of array) {\n    if (element % 2 !== 0) {\n      continue;\n    }\n    total += element;\n  }\n  return total;\n}\n\n// скрипт виводить ім*я та телефон користувача , у змінних name, phone зберігаються рядки розділені комами.Порядковий номер тел та імені відповідні і кількість їх однакова.\nconst namee = 'Neo, Clar, Jacob';\nconst phonee = '0956717633, 0990345678, 0632456766';\nconst arrayNamee = namee.split(',');\nconst arrayPhonee = phonee.split(',');\nfor (let i = 0; i < arrayNamee.length; i++) {\n  console.log(`${arrayNamee[i]} - ${arrayPhonee[i]}`);\n}\n\n// скрипт виводить у консоль всі слова рядка крім першого і останнього, результуючий рядок не повинен починатися або закінчуватися символом пробілу.\nconst stringS =\n  '  Це різниця між (function expression) та (function declaration) в тому, що function expression не можна викликати до місця його створення, тільки після, тому що це буквально оголошення const змінної';\nconst stringApdate = stringS.trim().split(' ');\nconst shifted = stringApdate.shift();\nconst popped = stringApdate.pop();\nconsole.log(stringApdate);\nconst strinGGG = stringApdate.join(' ').trim();\nconsole.log(strinGGG);\n// ex\nfunction numberOfItemsFromArray(items) {\n  for (let i = 0; i < items.length; i++) {\n    console.log(`${i + 1} - ${items[i]}`);\n  }\n}\nconsole.log(numberOfItemsFromArray(['mango', 'apple', 'peach', 'banana']));\n\n// ex функція переведе кількість хвилин у рядок у форматі годин та хвилин ХХ:ХХ\nfunction formatTime2(totalMinutes) {\n  const hourS = Math.floor(totalMinutes / 60);\n  const minuteS = totalMinutes % 60;\n  const hoursString = String(hourS).padStart(2, '0');\n  const minutesString = String(minuteS).padStart(2, '0');\n  return `${hoursString}:${minutesString}`;\n}\nconsole.log(formatTime2(1030));\n// функція розбиває масив на потрібну кількість елементів розділяючи на декілька масивів , приймає 2 параметри - масив і потрібну к-ть ел в масиві. Повертає масив масивів.\nfunction arrayCut(arrar, count) {\n  const arrayCommun = [];\n  for (let i = 0; i < arrar.length; i += count) {\n    const arraySubordinate = arrar.slice(i, i + count);\n    arrayCommun.push(arraySubordinate);\n  }\n  return arrayCommun;\n}\nconsole.log(\n  arrayCut(\n    [\n      'apple',\n      'banana',\n      'orange',\n      'poultry',\n      'beef',\n      'fish',\n      'potato',\n      'tomato',\n      'cucumber',\n    ],\n    3\n  )\n);\n","'use strict';\n// const username = \"Vika\";\n// const age = 25;\n// const message = `Hello ${username}! Your age is ${age}.`;\n// console.log(message);\n// const agePets = null;\n// console.log(typeof typeof agePets);\n\n// Statement if\nfunction checkPassword(password, userName) {\n  const truePassword = 'hellokitty21';\n  if (password === truePassword) {\n    return `Welcome ${userName}!`;\n  }\n}\n\nconst result1 = checkPassword('hsgirl37', 'Kris');\nconst result = checkPassword('hellokitty21', 'Viktoriia');\nconsole.log(result);\nconsole.log(result1);\n\n// Statement if...else - якщо умова (condishion) перетворюється до true то виконується код блоку if (if block statments); якщо умова (condishion) перетворюється до false то виконується код блоку else (else block statments);\nfunction checkAccountBalance(cashBalance) {\n  if (cashBalance > 250) {\n    return 'You can to connect a Premium subscription.';\n  } else {\n    return 'Top up your account with $250 to activate a premium subscription.';\n  }\n}\nconst cheking1 = checkAccountBalance(0);\nconst cheking2 = checkAccountBalance(400);\n\nconsole.log(cheking1, cheking2);\n\n//  Statement else...if використовуємо коли більше 1 умови. Як тільки якась умова задовільняється то інструкція припиняється.\nfunction checkStorage(available, ordered) {\n  if ((available > 0, ordered === 0)) {\n    return 'There are no products in the order!';\n  } else if (ordered > available) {\n    return 'Your ordered is too large, there are not enough items in stock!';\n  } else {\n    return 'The ordered is accepted, our manager will contact you.';\n  }\n}\nlet a = checkStorage(3, 0);\nlet b = checkStorage(30, 50);\nlet c = checkStorage(60, 10);\n\nconsole.log(a, b, c);\n\n//  Тернарний оператор - коротша заміна if...else, у нього може бути тільки 2 сценарія - condition ? expression if condition is TRUE : expression if condition is FALSE\nlet type;\nconst age = 20;\nif (age >= 18) {\n  type = 'adult';\n} else {\n  type = 'child';\n}\nconsole.log(type);\n// EXAMPLE 1\nconst yourAge = 20;\nconst yourType = age >= 18 ? 'adult' : 'child';\nconsole.log(yourType);\n// EXAMPLE 2\nfunction checkPassword2(password) {\n  const correctPassword = 'jqueryismyjam';\n  return password === correctPassword\n    ? 'Access granted'\n    : 'Access denied, wrong!';\n}\nconst a1 = checkPassword2('incorrectPassword');\nconst a2 = checkPassword2('jqueryismyjam');\n\nconsole.log(a1, a2);\n\n// Operator switch - дозволяє виконувати різні дії залежно від значення виразу (expression). Якщо значення виразу відповідає значенню в блоці case то виконується код цього блоку. Оператор break, щоб вийти зі switc (це запобігає виконанню клоду у наступних блоках case). Якщо жодне значення не відповідає виразу то виконується код з блоку default в самому кінці (якщо він є).\nfunction yourCountry(country) {\n  switch (country) {\n    case 'Ukraine':\n      console.log('Вітаю, як ся маєш?');\n      break;\n    case 'England':\n      console.log('Hello, how are you?');\n      break;\n    case 'Spain':\n      console.log('Hola, cómo estás?');\n      break;\n    case 'Belgium':\n      console.log('Hallo, hoe gaat het?');\n      break;\n    case 'Germany':\n      console.log('Hallo, wie geht es dir?');\n      break;\n    case 'France':\n      console.log('Salut comment vas-tu?');\n      break;\n    default:\n      console.log('Hello, how are you?');\n  }\n}\nyourCountry('Spain');\nyourCountry('Ukraine');\nyourCountry('Belgium');\n\n//  fall-through - провалювання коду, якщо не вказати оператор break у блоці switch то виконання коду продовжиться у наступному  case; це якщо потрібно щоб кілька блоків case виконували один і той самий код\nconst expression = 10 - 5;\nswitch (expression) {\n  case 2:\n\n  case 5:\n    console.log('The result is less than 8');\n    break;\n\n  case 8:\n    console.log('The result is 8');\n    break;\n  default:\n    console.log('The result does not exist');\n}\n// The result is less than 8\n\n// Boolean operators: &&(і) ||(або) !(ні) ??\n// expression1 && expression2 - бінарний оператор і зліва направо перевіряє почергово обидва операнди на істинність та повертає або значення останнього істинного (тільки правого) операнда, або першого хибного (лівого чи правого) на якому він запнувся. Якщо операндами є вирази то спочатку обчисл вирази а потім їх порівнюють\nfunction typeScreen(screenWidth) {\n  const sm = 320;\n  const md = 768;\n  const lg = 1200;\n\n  if (screenWidth <= sm) {\n    return 'Mobile screen';\n  } else if (screenWidth > sm && screenWidth <= md) {\n    return 'Tablet screen';\n  } else if (screenWidth > md && screenWidth <= lg) {\n    return 'Desktop screen';\n  } else {\n    return 'Godzilla screen';\n  }\n}\nconst ba = typeScreen(200);\nconst bb = typeScreen(420);\nconst bc = typeScreen(980);\nconst bd = typeScreen(1800);\n\nconsole.log(ba, bb, bc, bd);\n// EXAMPLE 2 && - функція повертає результат входження числаNumber у числовий проміжок від start до end\nfunction isNumberInRange(start, end, number) {\n  return number >= start && number <= end;\n}\n\nconst ca = isNumberInRange(20, 150, 40);\nconst cb = isNumberInRange(25, 35, 15);\n\nconsole.log(ca, cb);\n// expression1 || expression2 - бінарний оператор або перетворює всі операнди до логічного типу (true або false) і повертає значення одного з них. Як тільки оператор або знайшов  перший операнд що перетворюється на true він зупиняється та пповертає його значення. Якщо всі операнди перетворюються на false то результатом буде значення крайнього правого операнда\nconst f = 'mango' || 0;\nconsole.log(f, typeof f);\n\nconst v = undefined || 2;\nconsole.log(v, typeof v);\n\nconst y = true || false;\nconsole.log(y, typeof y);\n\nconst g = '' || null;\nconsole.log(g, typeof g);\n// EXAMPLE 1\nfunction checkAccess(subType) {\n  return subType === 'pro' || 'vip';\n}\nconst h = checkAccess('pro');\nconst j = checkAccess('super');\n\nconsole.log(h, j, typeof h, typeof j);\n// !expression - унарний (один операнд) логічний оператор ні приводить до логічного значення (true або false) і потім заперечує його(змінює на протилежне значення).\nconsole.log(!true);\nconsole.log(!false);\nconsole.log(!'');\nconsole.log(!3);\nconsole.log(!null);\nconsole.log(!undefined);\nconsole.log(!'Masha');\n// На практиці логчне заперечення викор для перевірки від зворотнього, напр можна дозволити написати повідомлення в чаті лише якщо користувач НЕ заблокований\nfunction chat(isBlocked) {\n  const canChat = !isBlocked;\n  if (canChat) {\n    return 'Can type in chat.';\n  } else {\n    return 'Blocked from typing in chat!';\n  }\n}\n\nconst la = chat(false);\nconst lo = chat(true);\n\nconsole.log(la, lo);\n\n// Оператор нульового злиття (??) - Це логічний оператор, що повертає значення правого операнда, якщо значення лівого операнда містить null або undefined, інакше повертається значення лівого операнда.\nlet firstName = null;\nlet nickName = 'Super';\nconsole.log(firstName ?? nickName ?? 'Anonim');\nconsole.log(nickName ?? firstName ?? 'Anonim');\n\nconst foo = null ?? 'string';\nconst valB = '' ?? 'B';\nconsole.log(foo);\nconsole.log(valB); // \"\" (поскольку пустая строка не приравнивается к null или undefined)\n\nconst valC = 42 ?? 0;\nconst baz = 0 ?? 42;\nconsole.log(valC); // 42\nconsole.log(baz); // 0\n\n// Methods of strings:\n// The method indexOf() - для пошуку першого входження підрядка в рядок. Він повертає: -індекс першого входження (індекс першого символу) підрядка, якщо він знайдений або: -1, якщо підрядок не виявлено.\n// The method slice() - для створення копії частини або всього рядка без зміни оригінального рядка. Він дозволяє витягувати підрядок з вихідного рядка, вказуючи початковий та кінцевий індекси. str.slice(startIndex, endIndex), де: str — вихідний рядок, з якого робитиметься копія. startIndex — індекс, з якого починається копіювання елементів рядка.endIndex — індекс, до якого (не включаючи) йде копіювання елементів рядка. Якщо викликати метод slice() без аргументів, він створює точну копію рядка і повертає її.\nfunction getFileName(file) {\n  const fileCheck = file.indexOf('.');\n  if (fileCheck === -1) {\n    return file.slice();\n  } else {\n    return file.slice(0, file.indexOf('.'));\n  }\n}\nconst yy = getFileName('index.app');\nconst xx = getFileName('script');\nconsole.log(yy, xx);\n\n//   Methods toLowerCase() та toUpperCase() використовуються для зміни регістру символів у рядку. Обидва методи не змінюють вихідний рядок, а повертають новий рядок у відповідному регістрі. Нормалізація введення - можна зробити «нормалізацію» введеного користувачем рядка, тобто перетворити всі його символи у верхній або нижній регістр:\nconst brandName = 'samsung';\nconst userInput = 'saMsUng';\nconst lowercaseInput = userInput.toLowerCase();\n// EXAMPLE of using methods\nfunction normalizeInput(input, to) {\n  switch (to) {\n    case 'upper':\n      return input.toUpperCase();\n      break;\n    case 'lower':\n      return input.toLowerCase();\n      break;\n  }\n}\nconst rr = normalizeInput(\"This ISN'T SpaM\", 'lower');\nconst dd = normalizeInput(\"This ISN'T SpaM\", 'upper');\nconsole.log(rr, dd);\n\n//   The method includes() - використовується для перевірки наявності підрядка у рядку. Він повертає логічне значення true, якщо підрядок знайдено, і false, якщо підрядок відсутній.\n// Example 1\nconst message = 'Please buy our stuff!';\nconst hasSpam = message.includes('buy');\n\nif (hasSpam) {\n  console.log('Warning: This message contains forbidden words.');\n} else {\n  console.log('You can safely open this message.');\n}\n// Ex 2\nfunction checkForName(fullName, firstName) {\n  fullName = fullName.toUpperCase();\n  firstName = firstName.toUpperCase();\n  return fullName.includes(firstName);\n}\n\n// Methods startsWith() і endsWith() - призначені для перевірки початку й закінчення рядка відповідно. Вони повертають булеве значення true або false, залежно від того, чи відповідає початок або кінець рядка заданому значенню. Чутливі до регістру (зроби нормалізацію).\nfunction checkFileExtension(fileName, ext) {\n  if (fileName.endsWith(ext)) {\n    return 'File extension matches';\n  } else {\n    return 'File extension does not match';\n  }\n}\nconst jj = checkFileExtension('styles');\nconst uu = checkFileExtension('script', '.js');\nconst ll = checkFileExtension('index.html', '.html');\nconsole.log(jj, uu, ll);\n// The method trim() - для видалення початкових і кінцевих пробілів із рядка. Це дозволяє \"очистити\" рядок від зайвих пробілів.\nfunction createFileName(name, ext) {\n  const pureName = name.trim();\n  const pureExt = ext.trim();\n  return `${pureName}.${pureExt}`;\n}\nconst hh = createFileName('  index   ', '   html');\nconsole.log(hh);\n\n// Області видимості - глобальна (її змінні буде видно в локальних) та локальна (її значення доступні тільки в її області і їх не видно в глобальній обл). Коли ми викликаємо якусь змінну то система перевіряє її видимість тільки піднімаючись по вкладеності на вищі рівні - тобто якщо локальна обл №2 вкладена в локальну обл №1 то буде видно змінну з локальної№1 у локальній№2 але не буде видно локальну#2 e kjrfkmysq #1.\nif ('#1') {\n  const a = 5;\n\n  if ('#2') {\n    const b = 7;\n    console.log(a);\n  }\n}\n// Cicles\n// Цикл — керуюча конструкція, призначена для організації багаторазового виконання набору інструкцій. Тіло циклу — послідовність інструкцій, призначена для багаторазового виконання. Ітерація — одиничне виконання тіла циклу. Умова виходу — вираз, що визначає, чи буде в черговий раз виконуватися ітерація, або цикл завершиться.\n\n// Цикл while - kонструкція while створює цикл, який виконує блок коду в тілі циклу, поки умова для виходу оцінюється як true.Якщо умова оцінюється як false, виконання циклу переривається і скрипт продовжує виконувати інструкції після циклу. Цикл while часто використовується, коли точна кількість ітерацій заздалегідь не відома. Отже, цикл має виконуватися до виконання певної умови.      Цикл while — це цикл з передумовою, тобто він виконується доки істинна певна умова, зазначена перед його початком. Цю умову перевіряють до виконання тіла циклу, тому тіло може бути не виконано жодного разу, якщо умова від самого початку хибна.\n// EXAMPLE of cicle while\nlet count = 0;\nwhile (count < 10) {\n  console.log(`Count: ${count}`);\n  count += 1;\n}\n// Ex 2\nlet clientRoom = 18;\nconst maxRooms = 25;\nwhile (clientRoom < maxRooms) {\n  console.log(clientRoom);\n  clientRoom += 1;\n}\n// Ex3 Функція calculateSum(number) приймає ціле число (параметр number). Доповни код функції так, щоб вона повертала суму всіх цілих чисел від одиниці до цього числа включно. Наприклад, якщо number дорівнює 3, то сума - це 1 + 2 + 3, тобто 6.\nfunction calculateSum(number) {\n  let counter = 0;\n  let total = 0;\n  while (counter <= number) {\n    total += counter;\n    counter++;\n  }\n  return total;\n}\nconst pf = calculateSum(3);\nconsole.log(pf);\n\n// Цикл do…while - відмінність від while - код у тілі циклу виконується принаймні один раз, навіть якщо умова не виконується з самого початку. Блок коду всередині do виконується в перший раз незалежно від виконання умови, потім після кожної ітерації, перевіряється умова. Якщо умова оцінюється як true, цикл продовжує виконуватися; якщо — як false, цикл завершується.\n// do {\n//   statement // код, який буде виконуватися\n// } while (condition);\n\n// let numb = 0;\n\n// do {\n// \tconsole.log(`Numb: ${numb}`);\n// \tnumb += 1;\n// } while (numb < 5);\n\n// Цикл for на відміну від циклів while і do…while -  має змінну-лічильник. Змінна-лічильник оголошується за допомогою ключового слова let (const видасть помилку). На кожній ітерації після виконання коду з тіла циклу вона змінює своє значення від заданого початкового до кінцевого з певним кроком. Синтаксис циклу for:\n// for (initialization; condition; afterthought) {\n//   statement // Тіло циклу\n// }\n// Ініціалізація — виконується один раз перед початком циклу. Тут оголошується змінна-лічильник і вказується її початкове значення.\n// Умова — це вираз, який оцінюється перед кожною ітерацією (повторенням) циклу. Якщо умова перетворюється на**true**, то виконується тіло циклу. Якщо умова перетворюється на false, то цикл завершується.\n// Пост-вираз — це вираз, який виконується в кінці кожної ітерації циклу, перед перевіркою умови. Використовується для оновлення значення змінної-лічильника.\n// for (let i = 0; i <= 20; i += 5) {\n//   console.log(i);\n// }\n// У наведеному прикладі циклу for змінна i ініціалізується значенням 0. Цикл виконується доти, доки i менша або дорівнює 20. Після кожної ітерації значення i збільшується на 5. У результаті в консоль будуть виведені числа 0, 5, 10, 15 і 20.\n// Example calculateTotal(number) приймає ціле число (параметр number) Використовуючи цикл for, доповни код функції так, щоб вона повертала суму всіх цілих чисел від одиниці до цього числа включно. Наприклад, якщо number дорівнює 3, то сума - це 1 + 2 + 3, тобто 6.\nfunction calculateTotal(number) {\n  let sum = 0;\n  for (let i = 1; i <= number; i += 1) {\n    sum += i;\n  }\n  return sum;\n}\nconst yeh = calculateTotal(3);\nconsole.log(yeh);\n// EXAMPLE CYCLE FOR - функція рахує суму(тотал) чисел що кратні 2(діляться націло на 2) і знаходять в діапазоні від мін до мах\nfunction Calc(min, max) {\n  let total = 0;\n  for (let i = min; i <= max; i++) {\n    if (i % 2 === 0) {\n      total += i;\n    }\n  }\n  return total;\n}\n\nlet ghhg = Calc(0, 5);\nconsole.log(\"OMG it's total!\", ghhg);\n\n// Виводимо НЕПАРНІ ЧИСЛА за допомогою  логічного заперечення ! та нічого з ними не робимо а через оператор контінью просто продовжуємо ітерацію циклю таким чином ми будемо збільшувати непарні числа на крок 1 і матимемо ПАРНІ ЧИСЛА. після завершення циклу рахуємо суму\nfunction Calc2(min, max) {\n  let total = 0;\n  for (let i = min; i <= max; i++) {\n    if (i % 2 !== 0) {\n      continue;\n    }\n    console.log(i);\n    total += i;\n  }\n  return total;\n}\n\nlet pppp = Calc2(0, 5);\nconsole.log(\"OMG these're numbers!\", pppp);\n\n// EXAMPLE виводимо індекси символів із рядка за допомогою цикла FOR\nfunction strJust(justString) {\n  for (let i = 0; i < justString.length; i++) {\n    console.log(justString[i], i);\n  }\n}\nconst justSymbolsOfString = strJust(\n  'You are the better version yourself today'\n);\n\n// //\n// function calculateEvenTotal(number) {\n//   let sum = 0;\n//   let count = 1;\n//   for (let i = 1; i <= number; i += 1) {\n//     count++;\n//     if (count % 2 === 0) {\n//       sum += count;\n//     }\n//   }\n//   return sum;\n// }\n// const www = calculateEvenTotal(18);\n// console.log(www);\n\n// Інкремент постфіксний - спочатку матем вираз рахується потім інкремент змінної (+1). При наступному використанні ця змінна буде збільшена вже на одиницю\nfunction calcNum(f, d, b) {\n  //          2 + 9 = 11\n  const sum = f++ + d * b;\n  //         11 + (2+1) = 14\n  return sum + f;\n}\nconst yee = calcNum(2, 3, 3);\nconsole.log(yee);\n\n// // Інкремент префіксний - спочатку (змінна +1) потім рахується математ вираз\nfunction calcNum2(f, d, b) {\n  //       (2+1) +   9    = 12\n  const sum = ++f + d * b;\n  //       12  + 3 = 15\n  return sum + f;\n}\nconst yee2 = calcNum2(2, 3, 3);\nconsole.log(yee2);\n\n//                                             CONTENT OF THE WORK\nfunction communication(client, status, age) {\n  let speech;\n  if ((status = 'smokes cigarettes' && age >= 18)) {\n    switch (client) {\n      case 'premium':\n        return (speech =\n          'В наявності Marlboro Tach у чорному дизайні та новому форматі у 6 та 4 мг за ціною 100 грн. Продукти мають фільтр з повітряною камерою та ущільненою стінкою.');\n      case 'medium' && 'capsuls':\n        return (speech =\n          \"У L&M та Chesterfield з'явились новинки з капсулами за ціною 85 та 87 грн, вони мають фільтр з повітряною камерою та коричневу обгортку з відновленого тютюну.\");\n      case 'Philip Morris' && !'capsuls':\n        return (speech =\n          'У травні 2024 року компанія Філіп Морріс відновила власне виробництво в Україні! Перші продукти з нової фабрики вже в продажу.');\n      default:\n        return (speech =\n          \"Проходьте опитування за QR-кодом та залишайтесь на зв'язку зі своїм брендом. За витрачений час ви отримаєте поповнення мобільного на 30 грн.\");\n    }\n  } else {\n    return (speech = 'Гарного дня!');\n  }\n}\n\n// function communication(client, status, age) {\n// let speech1 = \"В наявності Marlboro Tach у чорному дизайні та новому форматі у 6 та 4 мг за ціною 100 грн. Продукти мають фільтр з повітряною камерою та ущільненою стінкою.\";\n// let speech2 = \"У L&M та Chesterfield з'явились новинки з капсулами за ціною 85 та 87 грн, вони мають фільтр з повітряною камерою та коричневу обгортку з відновленого тютюну.\";\n// let speech3 = \"У травні 2024 року компанія Філіп Морріс відновила власне виробництво в Україні! Перші продукти з нової фабрики вже в продажу.\";\n// let speech4 = \"Проходьте опитування за QR-кодом та залишайтесь на зв'язку зі своїм брендом. За витрачений час ви отримаєте поповнення мобільного на 30 грн.\";\n// let speech5 = \"Гарного дня!\";\n//  if (status = \"smokes cigarettes\" && age >= 18) {\n//   switch (client) {\n//     case \"premium\":\n//       return speech1;\n//     case \"medium\" && \"capsuls\":\n//       return speech2;\n//     case \"Philip Morris\" && !\"capsuls\":\n//       return speech3;\n//     default:\n//       return speech4;\n//   }\n// } else {\n//   return speech5;\n// }\n// }\n\n// function friendlyTalk(opposition) {\n//   if (opposition = \"Вже пробував Мальборо - мені не сподобалось\") {\n//     return \"А що саме вам не сподобалось? Це нові пропозиції від бренду в абсолютно новому форматі та дизайні, можливо саме вони вас зацікавлять\"\n//   } else if (opposition = \"Я вже пробував Мальборо Тач\") {\n//     return \"Дійсно, бренд має Тач у компактному форматі, проте наші новинки мають довшу сигарету, фільтр з повітряною камерою та новий дизайн. Єдине що залишається незмінним - це оригінальний тютюн Мальборо.\"\n//   } else if (opposition = \"Що таке фільтр з повітряною камерою?\") {\n//     return \"Це фільтр, що складається з 3 частин: ацетатної, вугільної та повітряної камери. Конструкція фільтру забезпечує самк тютюну більш м'яким та збалансованим.\"\n//   } else if (opposition = \"\") {\n//     return \"\"\n//   } else if (opposition = \"\") {\n//     return \"\"\n//   }\n// }\n\n//                                                   PRACTICE MODUL 1-2\n// eX1\nfunction typeOF(parametr) {\n  if (parametr === 'string') {\n    return 'string';\n  } else if (parametr === 'number') {\n    return 'number';\n  } else {\n    return 'unknown';\n  }\n}\n// ex2 функція визначає парне чи ні число\nfunction doubleNum(number) {\n  //або  number % 2 === 0\n  return !(number % 2) ? 'Парне число' : 'Непарне число';\n}\nconsole.log(doubleNum(2));\nconsole.log(doubleNum(3));\n// ex3\nfunction calculateSquare(value) {\n  if (typeof value === 'number') {\n    return `The square ${value} is ${Math.pow(value, 2)}`;\n  } else if (!(typeof value === 'number') && !(typeof value === 'string')) {\n    const valueNumb = Number(value);\n    return `The square ${valueNumb} is ${Math.pow(valueNumb, 2)}`;\n  } else if (typeof value === 'string' && value.includes('.')) {\n    const valueNumb = Number.parseFloat(value);\n    return `The square ${valueNumb} is ${Math.pow(valueNumb, 2)}`;\n  } else if (!(typeof value === 'number')) {\n    const valueNumb = Number(value);\n    return `The square ${valueNumb} is ${Math.pow(valueNumb, 2)}`;\n  } else {\n    return 'Invalide square';\n  }\n}\nconsole.log(calculateSquare(2));\nconsole.log(calculateSquare(true));\nconsole.log(calculateSquare(null));\nconsole.log(calculateSquare(''));\nconsole.log(calculateSquare('Hello'));\nconsole.log(calculateSquare('3'));\nconsole.log(calculateSquare('3.3px'));\n\n// ex 3 (variable too is not so complex as you wrote...;/)\nfunction calculateSquare2(value) {\n  const valueNumb = Number.parseFloat(value);\n  if (Number.isNaN(valueNumb)) {\n    return 'Invalide square';\n  } else {\n    return `The square ${valueNumb} is ${Math.pow(valueNumb, 2)}`;\n  }\n}\nconsole.log(calculateSquare2(10));\nconsole.log(calculateSquare2(true));\nconsole.log(calculateSquare2(null));\nconsole.log(calculateSquare2(''));\nconsole.log(calculateSquare2('Hello'));\nconsole.log(calculateSquare2('3'));\nconsole.log(calculateSquare2('3.3px'));\n\nconsole.log(Number(''));\n// Method isNan - Функция isNaN() определяет является ли литерал или переменная нечисловым значением (NaN) или нет. При работе с функцией необходимо проявлять осторожность так как она имеет свои особенности. В качестве альтернативы можно использовать метод Number.isNaN() из ECMAScript 6, или дополнительно проверять литерал или переменную на нечисловое значение при помощи typeof.\n//  метод Math.pow() (степінь) повертає значення основи, піднесене до степеня. Тобто: 𝙼𝚊𝚝𝚑.𝚙𝚘𝚠(𝚡,𝚢) підведе х у степінь у. Або використати оператор **.\n// ex4\nfunction checkString(value) {\n  if (typeof value === 'string' && !value.includes('$')) {\n    return `The length of string is ${value.length} symbols`;\n  } else {\n    return 'Undefined value';\n  }\n}\nconsole.log(checkString('Hello'));\nconsole.log(checkString('Hello$'));\nconsole.log(checkString(6));\n// ex 5\nconst string = 'abcde';\nif (string[1] === 'b') {\n  console.log('Yes');\n} else {\n  console.log('No');\n}\n// ex6 вивели парні числа у проміжку 50-23\nlet max = 50;\nlet min = 23;\nfor (let i = max; i >= min; i--) {\n  if (i % 2 === 0) {\n    console.log(i);\n  } else {\n    ('Nothing');\n  }\n}\n// ex7 знайшли суму всіх парних чисел у проміжку\nmax = 50;\nmin = 0;\nlet sum = 0;\nfor (let i = 0; i <= max; i++) {\n  if (i % 2 === 0) {\n    //      sum=sum+i\n    console.log((sum += i));\n  }\n}\n// ex8\nsum = 0;\nfor (let i = 1; i <= 100; i++) {\n  if (i % 3 === 0 || i % 5 === 0) {\n    sum += i;\n    console.log(`Сума чисел, які діляться на 3 або на 5 від 1 до 100: ${sum}`);\n  }\n}\n// ex9 задані хвилини виводимо у цілих годинах та залишок хвилин\nfunction formatMinutesToTime(minutes) {\n  // получаем часы из минут при помощи метода вывода целого числа\n  const hours = Math.floor(minutes / 60);\n  // приводимо до рядка щоб використати метод рядків padStart()для підставлення на початок рядка 00 замість одного 0\n  let modHours = String(hours).padStart(2, '0');\n  let modMinutes = minutes % 60;\n  modMinutes = String(modMinutes).padStart(2, '0');\n  return `${modHours}:${modMinutes}`;\n}\nconsole.log(formatMinutesToTime(61));\n\n// метод рядків padStart() заполняет c начала текущую строку другой строкой (несколько раз, если нужно) так, что итоговая строка достигает заданной длины. Заполнение осуществляется в начале (слева) текущей строки. перше значення це загальна кількість символів що буде у рядку а друге значення - те що потрібно підставити\n'abc'.padStart(10); // \"       abc\"\n'abc'.padStart(10, 'foo'); // \"foofoofabc\"\n'abc'.padStart(6, '123465'); // \"123abc\"\n// Метод padEnd() дополняет с конца текущую строку с помощью заданной строки (в конечном счёте повторяя), так чтобы результирующая строка достигла заданной длины. Дополнение применяется в конце (справа) текущей строки.\n'abc'.padEnd(10); // \"abc       \"\n'abc'.padEnd(10, 'foo'); // \"abcfoofoof\"\n'abc'.padEnd(6, '123456'); // \"abc123\"\n// ex 10 Функція findNumber(start, end, divisor) приймає три параметра, які є цілими числами.Доповни код функції таким чином, щоб вона - повертала перше число у діапазоні від start до end включно, яке ділиться на divisor без остачі; -не використовуй оператор break\nfunction findNumber(start, end, divisor) {\n  for (let i = start; i <= end; i++) {\n    console.log(i);\n    if (i % divisor === 0) {\n      return i;\n    }\n  }\n}\nconsole.log(findNumber(10, 100, 7));\n// ex 10 Доповни код таким чином, щоб у змінну number записувалося перше число у проміжку від start до end, яке ділиться на 5 без остачі.\nconst start = 6;\nconst end = 17;\nlet number;\nfor (let i = start; i <= end; i++) {\n  if (i % 5 === 0) {\n    number = i;\n    break;\n  }\n}\nconsole.log(number);\n","import './js/modul-12.js';\nimport './js/modul-11.js';\nimport './js/modul-10.js';\nimport './js/modul-9.js';\nimport './js/modul-8.js';\nimport './js/modul-7.js';\nimport './js/modul-6.js';\nimport './js/modul-5.js';\nimport './js/modul-4.js';\nimport './js/modul-3.js';\nimport './js/modul-2.js';\n\nconst btnMenuOpen = document.querySelector('.btn-menu-open');\nconst containerMenu = document.querySelector('.mob-menu');\nbtnMenuOpen.addEventListener('click', handleOpenMenu);\nfunction handleOpenMenu(event) {\n  containerMenu.classList.add('isVisibleMenu');\n  if (event.target.classList.contains('.item-nav')) {\n    console.log('mda');\n\n    containerMenu.classList.remove('isVisibleMenu');\n  }\n}\n\n// const btnCloseMenu = document.querySelector('.btn-menu-close');\n// btnCloseMenu.addEventListener('click', handleCloseMenu);\n// function handleCloseMenu(event) {\n//   containerMenu.classList.remove('isVisibleMenu');\n// }\nconst menu = document.querySelector('.mob-menu');\nmenu.addEventListener('click', handleMenuInteractive);\nfunction handleMenuInteractive(event) {\n  console.log(event.target);\n\n  if (\n    event.target.classList.contains('link-nav') ||\n    event.target.classList.contains('use-icon-close')\n  ) {\n    containerMenu.classList.remove('isVisibleMenu');\n  }\n}\n// const list = document.querySelectorAll('.nav-list');\n// list.addEventListener('click', handleMoveForLink);\n// function handleMoveForLink(event) {\n//   console.log('MODAL');\n//   if (!event.target.classList.contains('.item-nav')) {\n//     return;\n//   }\n//   containerMenu.classList.remove('isVisibleMenu');\n// }\n"],"names":["axios","response","error","myApiKey","fetchUsers","users","fetchUsers3","fetchUsers4","doStuff","fetchPostsBtn","postList","page","perPage","posts","fetchPosts3","renderPosts","params","markup","id","title","body","userId","pagee","limit","totalPages","iziToast","fetchPosts4","renderPosts3","BASE_URL_JSONPLACEHOLDER","foo6","todo1","todo2","todo3","data","foo7","prpmisesArr","par","res","todos","arr1","arr2","arr3","todoForm","todoContainer","handleServise","event","createTodoMarkup","array","todo","completed","handlePostDataToService","userSTask","err","handlePatch","parent","handleDeletTask","API_Read_Access_Token","filmsList","END_POINT","options","observer","handleLoadMoreMovie","guard","pageMovie","fetchService","method","createMovieMarkup","poster_path","release_date","overview","vote_average","entries","entry","cardHeight","options69","fetchUsersBtn","userList","user","listJsonPlaceholder","createMarkup2","arr","params3","foo2","url","pixabayList","PIXABAY_KEY","params5","createMarkupPixabay","previewURL","tags","WHEATHER_KEY","BASE_URL","weatherList","wheatherForm","handleSearchWheather","cityWheather","quantityDays","fetchWheather","createWheatherMarkup","city","days","paramsWheather","forecastday","date","avgtemp_c","icon","text","setBtn","clearBtn","timeoutId","handleAsync","handleClearAsync","date2","parForTime","promise","resolve","reject","promise2","value","promise3","promise4","promise5","i","delay","logger2","time","name","logger2Id","elementByManipulation","showElement","delayForHiddenID","handleClickToHide","date1","startBtn","stopBtn","areaForShowTheTimer","isActive","intervalID","startTimer","startTime","differencceBetweenTimes","getTimeComponent","displayTimeInArea","timeInMs","seconds","padStart","minutes","hours","stopTimer","instancePromis","random","success","instancePromis2","fin","makeOrder","dish","result","makeOrder2","res1","differenceTime","res2","res3","startGameBtn","containerForBoxsGame","areaResultByGame","handleStartGame","promisesArray","items","isWinner","item","obj","index","USER_DATA","formExample1","btnFormLog","inpEmail","inpPassword","handleLogin","emailVal","passVal","email","password","form9","textarea","handleSaveMessage","MessageGoBackAfterReloadThePage","messageByLocalStorage","handleMessage","jewelry","LS_KEY","container9","createMarkup9","price","brand","description","year","pic","handleAddToTheBasket","itemId","currentProduct","productsArr","indexByProductInArray","colorPalette","outputColor","selectColor","selectedColor","createPaletteItems","color","getRandomHexColor","letters","container","handleClick","kittyElementBtn","inputShow","btnShow","btnClear","spanOutput","handleShow","handleClear","inputAlert","btnAlert","handleChange","boxBySize","btnDecrease","btnIncrease","handleDecrease","handleIncrease","btnDouble","itemAll","handleDouble","el","form","handleFormSubmit","divCheckbox","listContacts","allContacts","inputFilter","handleFilter","inputVal","searchedItem","contact","movieList","moviesForm","moviesList","markupFilms","handleSearchFilm","itemFilms","inputValue","filmCoincidenced","selector","image","allSelectors","allDivisions","header","spanHeader","arraySpanHeader","link","navItemElement","navItemLink","menu","divContainer","createButtons","option","buttonEl","allKeys","textForAllKeys","key","accounts","transactionTable","createMarkup","tr","td","clearLogBtn","logList","keypressCounter","logMessage","reset","type","code","incrementKeypressCounter","registerForm","handleSubmit2","login","select","textOutput","valueOutput","setOutput","selectedOptionValue","selectedOptionIndex","selectedOptionText","textInput","output","textInputt","setFocusBtn","removeFocusBtn","formComment","handleSubmit","elements","emailValue","passwordValue","textareaValue","info","handleKeyPress","box","box2","addClass","remuvClass","cars","car","ulCars","formCars","handleSearch","query","createBoxes","amount","size","coloredDiv","boxes","input","btnCreate","btnDestroy","create","destroyBoxes","btnMoveKitty","btnGoBackKitty","divKitty","handleMove","step","handleGoBack","pizzaPalace","pizzaName","showThis","user1","greet","context","mango","poly","customer","greet1","library","showBooks","animal","dog","animal2","dog2","objC","objB","objA","apartment21","condo","Car","infiniti","Client","param","c01","Sound","p","newRating","s01","User4","__publicField","__privateAdd","_email","__privateSet","mangoj","User3","_User3_instances","__privateGet","newEmail","__privateMethod","validateEmail_fn","mango3","_Car7","_price","newPrice","Car7","audi","_Car8","_maxPrice","Car8","audiT","bmw","Animal","speed","Rabbit","earLength","whiteRabbit","blackRabbit","User8","Admin","mango8","User10","Admin2","mango9","yyyy","objX","chopShop","nameStone","stone","propNam","changeColor","objL","objK","varChangeColor","userR","logger","callback","objJK","num","updateObjJK","number","hehehe","hohoho","keysHohoho","q","w","e","r","cruiseControle","accelerate","decrease","Carr","maxSpeed","bMw","lexus","CarsS","_CarsS_instances","typeOfPrice_fn","infinity","Hero","Warior","spells","rest","valhala","us","yyyyb","sayHi","element","studentsGroup","stud","finedNameOfID","ID","courses","allTopics","indx","peoples","getTotalBoysYers","acc","products","totalCost","tel_1","country","tel_2","ue","Rectangle","rect_1","now","currentYear","Carrr","ageCar","checkingAge","subaru","Client1","_login","newLogin","client1","greet2","notify","registerGuest","registerGuest2","calculateTotalPrice","orderedItems","totalPrice","filterArray","numbers","newArray","calculateTotalPrice33","changeEven","planets29","planetsInUpperCase","planet","planets45","books","titles","students","mappedCourses","student","flattenedCourses","getUserEmails","values4","positiveValues","evenNumbers","oddNumbers","arr45","result45","books999","MIN_RATING","AUTHOR","topRatedBooks","book","booksByAuthor","users777","getUsersWithEyeColor","getUsersWithAge","minAge","maxAge","books3333","bookTitel","authorFind","users888","getUserWithEmail","isEveryUserActive","isAnyUserActive","total999","previousValue","players","playtimes","totalPlayTime","valueAcum","players90","totalAveragePlaytimePerGame","total","player","scores","letters7","scores3","ascendingScores","a","b","scores4","descendingScores","releaseDates","students7","inAlphabetOrder","inReversedOrder","authors99","authorsInAlphabetOrder","authorsInReversedOrder","students709","firstStudent","secondStudent","sortedByAuthorName","sortedByReversedAuthorName","sortedByAscendingRating","sortedByDescentingRating","names","uniqueSortedCourses","course","MIN_BOOK_RATING","namesAuthor","calc","math","x","y","each","newArr","easy","calc2","example","arrey69","multy","printContactsInfo","phones","namesArr","phonesArr","calculateAvarege","args","carsObj","getArreyOfCarsModel","arrModel","getArreyOfCarsModelMap","makePriceWithDiscount","discount","playerIdToUpdate","plaers7","updateTimePlayed","numbers41","filtered","findPrice","priceFiltered","fined","isOnline","some","total0","total01","total002","salary","totalTimePlaed","cart35","getTotalOfCart","apartment","bookTitle","bookGenres","bookPrice","location22","hobbies","firstHobby","numberOfHobbies","book3","propKey","name4","age4","user4","propName","user5","book5","apartment4","keys","values","book6","keysArrayOfBook6","apartment6","apartmentArrayKeys","values2","keys2","countProps","object","propCount","arraysKeysOfObject","propertyObject","humanity","countTotalSalary","salaries","totalSalary","arraySal","sal","arrayEmployee","salariesObject","colors","hexColors","rgbColors","books6","authorToSearchFor","getProductPrice","productName","product","elem","getAllPropValues","calculateTotalPrice4","atTheOldToad2","atTheOldToad21","newPotion","potion","bookShelf","newBook","bookShelf2","totalRating","bookShelf24","bookName","multiply","multiply3","multiply2","numb1","numb2","add","totalRest","temps","getExtremeScores","best","worst","arrayNumb","copyOfarrayNumb","array1","array2","commonArray","object1","object2","object3","object4","first","second","third","fourth","defaultSettings","overrideSettings","finalSettings","createArrey","length","arrayJust","clearArray","arrayComparison","message","arr11","arr21","arrayComparison2","calculateAvarage","book7","keysOfBook7","checkKeyInObject","key2","key1","checkKeyInObject2","user6","calculator","arrayOfValue","mult","cart","orders","totalAmount","order","planetss","planetsss","firstElement","planets","planets44","yhuuu","getLastElementMeta","getExtremeElements","words2","message2","words","slug","slugParts","firstArray","secondArray","thirdArray","clients","getSlice","indexValue","planetsS","friends","createArrayOfNumbers","min","max","planets7","sum","planetas","planetsSS","calculateTotalPrice21","arg","makeArrayofArguments","createReversedArray","username","squareOfRectangle","valueLengthOfFigure","arrayValue","square","totalOfElementss","namee","phonee","arrayNamee","arrayPhonee","stringS","stringApdate","strinGGG","numberOfItemsFromArray","formatTime2","totalMinutes","hourS","minuteS","hoursString","minutesString","arrayCut","arrar","count","arrayCommun","arraySubordinate","checkPassword","userName","result1","checkAccountBalance","cashBalance","cheking1","cheking2","checkStorage","available","ordered","c","yourType","checkPassword2","a1","a2","yourCountry","expression","typeScreen","screenWidth","ba","bb","bc","bd","isNumberInRange","start","end","ca","cb","f","v","g","checkAccess","subType","h","j","chat","isBlocked","la","lo","nickName","foo","valB","valC","baz","getFileName","file","yy","xx","normalizeInput","to","rr","dd","hasSpam","checkFileExtension","fileName","ext","jj","uu","ll","createFileName","pureName","pureExt","hh","clientRoom","maxRooms","calculateSum","counter","pf","calculateTotal","yeh","Calc","ghhg","Calc2","pppp","strJust","justString","calcNum","d","yee","calcNum2","yee2","doubleNum","calculateSquare","valueNumb","calculateSquare2","checkString","string","formatMinutesToTime","modHours","modMinutes","findNumber","divisor","btnMenuOpen","containerMenu","handleOpenMenu","handleMenuInteractive"],"mappings":"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"}